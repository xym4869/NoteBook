---
typora-root-url: D:\Typora文件库\Typora图库\Web前端
---

# 基础

## ⼀、HTML、HTTP、web综合问题

### 1 前端需要注意哪些SEO

- 合理的**title 、description 、keywords ：搜索对着三项的权重逐个减⼩**， title值强调重点即可，重要关键词出现不要超过2次，⽽且要靠前，不同⻚⾯title 要有所不同； description 把⻚⾯内容⾼度概括，⻓度合适，不可过分堆砌关键词，不同⻚⾯description 有所不同； keywords 列举出重要关键词即可
- 语义化的HTML 代码，符合**W3C规范**：语义化代码让搜索引擎容易理解⽹⻚
- 重要内容HTML 代码放在最前：搜索引擎抓取HTML 顺序是从上到下，有的搜索引擎对抓取⻓度有限制，保证重要内容⼀定会被抓取
- 重要内容不要⽤js 输出：爬⾍不会执⾏js获取内容
- 少⽤iframe ：搜索引擎不会抓取iframe 中的内容
- ⾮装饰性图⽚必须加alt
- 提⾼⽹站速度：⽹站速度是搜索引擎排序的⼀个重要指标

### 2 `<img>` 的title 和alt 有什么区别？物理元素和逻辑元素；b和strong,i与em的区别

title 和alt：

- 通常当⿏标滑动到元素上的时候显示
- alt 是<img> 的特有属性，是图⽚内容的等价描述，**⽤于图⽚⽆法加载时显示**、读屏器阅读图⽚。可提图⽚⾼可访问性，**除了纯装饰图⽚外都必须设置有意义的值**，搜索引擎会重点分析。

 **物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。** 

 **物理元素所强调的是一种物理行为**，比如说我把一段文字用b标记加粗了，我的意思是告诉浏览器应该给我加粗了显示这段文字 ， b是Bold(加粗)的简写，所以这个B标记所传达的意思只是加粗，没有任何其它的作用。  而Strong我们从字面理解就可以知道他是强调的意思，所以我们**用这个标记向浏览器传达了一个强调某段文字的消息**，而这个Strong就是我们所说的逻辑元素，他是**强调文档逻辑的，并非是通知浏览器应该如何显示**。 

  用在网页上，默认情况下它们起的均是加粗字体的作用，二者所不同的是，`<b>`标签是一个实体标签，它所包围的字符将被设为bold（粗体），而`<strong>`标签是一个逻辑标签，它的作用是加强字符的语气，一般来说，加强字符的语气是通过将字符变为bold（粗体）来实现的。

 *当盲人使用屏幕阅读器上时能够明显能体现出B与Strong的不同。遇到B时与处理一般词语一样进行阅读，遇到Strong时回加重与停顿*. 

并不是说有了strong，就淘汰了b，b就因为自己表示的是字体加粗，恰巧跟strong默认情况下强调的效果一致，其实这个strong完全可以定义成别的样式的强调效果。但是**为了符合现在W3C的标准，还是推荐使用strong标签**。

- strong : 视觉效果加粗。HTML语义为强调，表示语气上的强调、加重。
-  b标签：视觉效果加粗。本身不具备HTML语义。

- em :斜体强调标签，更强烈强调，表示内容的强调点
- i标签：视觉效果斜体，本身不具备HTML语义。

### 3 HTTP的⼏种请求⽅法⽤途

**GET ⽅法：发送⼀个请求来取得服务器上的某⼀资源**
**POST ⽅法：向URL 指定的资源提交数据或附加新的数据**
**PUT ⽅法：跟POST ⽅法很像**，也是向服务器提交数据。但是，它们之间有不同。**PUT 指定了资源在服务器上的位置，⽽POST 没有**

HEAD ⽅法：只请求⻚⾯的⾸部
DELETE ⽅法：删除服务器上的某资源
OPTIONS ⽅法：它⽤于获取当前URL 所⽀持的⽅法。如果请求成功，会有⼀个Allow 的头包含类似“GET,POST” 这样的信息
TRACE ⽅法：TRACE ⽅法被⽤于激发⼀个远程的，应⽤层的请求消息回路
**CONNECT ⽅法：把请求连接转换到透明的TCP/IP 通道**

**Post和Get有什么区别？**  

1、 GET主要用于从服务器查询数据，POST用于向服务器提交数据
 2、 GET通过URL传递数据，POST通过http请求体传递数据
 3、 GET传输数据量有限制，不能大于2kb，POST传递的数据量较大，一般大量的数据提交都是通过POST方式
 4、 GET安全性较低，容易在URL中暴漏数据，POST安全性较高 

GET和POST是什么？HTTP协议中的两种发送请求的方法。

HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

GET和POST还有一个重大区别，简单的说：

**GET产生一个TCP数据包；POST产生两个TCP数据包。**

长的说：

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

GET与POST都有自己的语义，不能随便混用。

据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

### 4 从浏览器地址栏输⼊url到显示⻚⾯的步骤

基础版本：

- 浏览器根据请求的URL 交给DNS 域名解析，找到真实IP ，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等）；
- 浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，建⽴相应的内部数据结构（如HTML 的DOM ）；
- 载⼊解析到的资源⽂件，渲染⻚⾯，完成。

详细版：

1. 在浏览器地址栏输⼊URL
2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   1. 如果资源未缓存，发起新请求
   2. 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。
   3. 检验新鲜通常有两个HTTP头进⾏控制Expires 和Cache-Control ：
     - HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期
     - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最⼤新鲜时间

3. 浏览器解析URL获取协议，主机，端⼝，path
4. 浏览器组装⼀个HTTP（GET）请求报⽂
5. 浏览器获取主机ip地址，过程如下：
   1. 浏览器缓存
   2. 本机缓存
   3. hosts⽂件
   4. 路由器缓存
   5. ISP DNS缓存
   6. DNS递归查询（可能存在负载均衡导致每次IP不⼀样）

6. 打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：
   1. 客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝
   2. 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
   3. 客户端发送ACK=Y+1， Seq=Z
7. TCP链接建⽴后发送HTTP请求
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序
9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将响应报⽂通过TCP连接发送回浏览器
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四
    次握⼿如下：
    1. 主动⽅发送Fin=1， Ack=Z， Seq= X报⽂
    2. 被动⽅发送ACK=X+1， Seq=Z报⽂
    3. 被动⽅发送Fin=1， ACK=X， Seq=Y报⽂
    4. 主动⽅发送ACK=Y， Seq=X报⽂
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，进⾏缓存
15. 对响应进⾏解码（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML⽂档）
17. 解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严格的先后顺序，以下分别解释
18. 构建DOM树：
    1. Tokenizing：根据HTML规范将字符流解析为标记
    2. Lexing：词法分析将标记转换为对象并定义属性和规则
    3. DOM construction：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图⽚、样式表、js⽂件，启动下载
20. 构建CSSOM树：
    1. Tokenizing：字符流转换为标记流
    2. Node：根据标记创建节点
    3. CSSOM：节点创建CSSOM树
21. 根据DOM树和CSSOM树构建渲染树:
    1. 从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身不可⻅的标签。2)被css隐藏的节点，如display: none
    2. 对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤
    3. 发布可视节点的内容和计算样式
22. js解析如下：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此时document.readystate为loading
    2. HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的⽂档内容
    3. 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤document.write()，它们可以访问⾃⼰script和之前的⽂档元素
    4. 当⽂档完成解析，document.readState变成interactive
    5. 所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤document.write()
    6. 浏览器在Document对象上触发DOMContentLoaded事件
    7. 此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊并且所有异步脚本完成载⼊和执⾏，document.readState变为complete，window触发load事件
23. 显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）

详细简版：

1. 从浏览器接收url 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程之间的关系）
2. 开启⽹络线程到发出⼀个完整的HTTP 请求（这⼀部分涉及到dns查询， TCP/IP 请求，五层因特⽹协议栈等知识）
3. 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
4. 后台和前台的HTTP 交互（这⼀部分包括HTTP 头部、响应码、报⽂结构、cookie 等知识，可以提下静态资源的cookie 优化，以及编码解码，如gzip 压缩等）
5. 单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catchcontrol
    等）

6. 浏览器接收到HTTP 数据包后的解析流程（解析html -词法分析然后解析成dom 树、解析css ⽣成css 规则树、合并成render 树，然后layout 、painting 渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded 和DOMContentLoaded 等）
7. CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）
8. JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作⽤域链、回收机制等等）
9. 其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）

### 5 如何进⾏⽹站性能优化

content ⽅⾯：减少HTTP 请求：合并⽂件、CSS 精灵、inline Image；减少DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名；减少DOM 元素数量
Server ⽅⾯：使⽤CDN；配置ETag；对组件使⽤Gzip 压缩

Cookie ⽅⾯：减⼩cookie ⼤⼩

css ⽅⾯：将样式表放到⻚⾯顶部不使⽤CSS 表达式；使⽤`<link>` 不使⽤@import
Javascript ⽅⾯：将脚本放到⻚⾯底部；将javascript 和css 从外部引⼊；压缩javascript 和css；删除不需要的脚本；减少DOM 访问

图⽚⽅⾯：优化图⽚：根据实际颜⾊需要选择⾊深、压缩；优化css 精灵不要在HTML 中拉伸图⽚



（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。

（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数   

（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。   

（4） 当需要设置的样式很多时设置className而不是直接操作style。   

（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。   

（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。   

（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

### 6 HTTP状态码及其含义

1XX ：信息状态码

- 100 Continue 继续，⼀般在发送post 请求时，已发送了http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
-  **101 SC_SWITCHING_PROTOCOLS 是指服务器将按照其上的头信息变为一个不同的协议。** 

2XX ：成功状态码

- **200 OK 正常返回信息**
- **204 （无内容） 服务器成功处理了请求，但没有返回任何内容。**
- **206 （部分内容） 服务器成功处理了部分 GET 请求。**

3XX ：重定向

- **301 Moved Permanently 请求的⽹⻚已永久移动到新位置。**
- **302 Found 临时性重定向。**
- 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
- **304 Not Modified ⾃从上次请求后，请求的⽹⻚未修改过。可以让客户端使用缓存**
- 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4XX ：客户端错误

- **400 Bad Request 服务器⽆法理解请求的格式，客户端不应当尝试再次使⽤相同的内容发起请求。**
- **401 Unauthorized 请求未授权。**
- **403 Forbidden 禁⽌访问。**
- 404 Not Found 找不到如何与 URI 相匹配的资源。

5XX: 服务器错误

- **500 Internal Server Error 最常⻅的服务器端错误。**
- **502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。**
- 503 Service Unavailable 服务器端暂时⽆法处理请求（可能是过载或维护）。
-  504 错误代表网关超时 ， 正常情况下，是由于被请求服务器发送超时引起。 

**2**开头 **（请求成功）表示成功处理了请求的状态代码。**

200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。

**3**开头 **（请求被重定向）表示要完成请求，需要进一步操作。** **通常，这些状态代码用来重定向。**

300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**4**开头 **（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

**5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 **这些错误可能是服务器本身的错误，而不是请求出错。**

 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

#### 301和302

301：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

302：请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

两者都是一个POST请求经过 301/302 后会被浏览器转为GET请求

缓存： 对于301请求，浏览器是默认给一个很长的缓存。而302是不缓存的。 

搜索引擎：

301: 旧地址A的资源不可访问了(永久移除), 重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。

302: 旧地址A的资源仍可访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取B网址内容，但是会将网址保存为A的。

安全：

 尽量使用301跳转，以防止网址劫持！ 

 一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。 

####  **什么情况下会返回304状态码？** (http请求图)

 ![Alt text](/../../../../Typora图库/Web前端/http请求图.png) 

**1、是否禁止缓存**

**禁止缓存**指的是缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。

在请求头中，`Cache-Control: no-store`与`Pragma: no-cache`都可以禁止缓存，但两者也有区别

- `Pragma: no-cache`可以兼容`http 1.0` ，而`Cache-Control: no-store`是`http 1.1`提供的。
- 因此，`Pragma: no-cache`可以应用到`http 1.0`和`http 1.1`,而`Cache-Control: no-store`只能应用于`http 1.1`。

**2、是否检查本地副本是否过期**

**是否检查本地版本是否过期**主要由`Cache-Control` 的 `no-cache`和`must-revalidate`这两个可选值控制，其中：

> - `no-cache`: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。
> - `must-revalidate`：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。

**3、本地副本是否过期**

想要知道本地副本是否过期，我们就需要了解**缓存的过期机制**：

(1)、过期机制中，最重要的指令是 `max-age=`,它表示资源能够被缓的最大时间；它通常会和`must-revalidate`一起使用，使用起来就像下面这样：

```js
Cache-Control: max-age=60, must-revalidate
```

(2)、如果不含有`max-age`属性，则会去查看是否包含`Expires`属性，，通过比较`Expires`的值和头里面`Date`属性的值来判断是否缓存还有效。



![Alt text](/../../../../Typora图库/Web前端/Expires.png)

(3)、如果 `max-age` 和 `expires` 属性都没有，找找头里的` Last-Modified`信息。如果有，缓存的寿命就等于头里面 `Date`的值减去`Last-Modified`的值除以10.



![Alt text](/../../../../Typora图库/Web前端/Last-modified.png)



**4、如果本地副本没有过期**

如果本地副本没有过期，则会直接重缓存中读取资源，并返回200状态码。

**5、如果本地副本过期**

如果本地副本过期，则会进行**到源服务器进行有效性校验的前期准备**。

首先，会在请求头里寻找`If-None-Match`字段，其值为服务器上次返回的`ETag`响应头的值:

![Alt text](/../../../../Typora图库/Web前端/if-none-match.png)

![Alt text](/../../../../Typora图库/Web前端/etag.png)



如果请求头里没有`If-None-Match`字段，则会在请求头中寻找`If-Modified-Since`字段，其值为服务器上次返回的`Last-Modified`响应头中的日期值：

![Alt text](/../../../../Typora图库/Web前端/last-modified2.png)

![Alt text](/../../../../Typora图库/Web前端/if-modified-since.png)

如果`If-None-Match`与`If-Modified-Since`都没有，则会直接向服务器请求数据。

**6、到源服务器进行有效性校验**

如果请求头中带有`If-None-Match`或`If-Modified-Since`，则会到源服务器进行有效性校验，**如果源服务器资源没有变化，则会返回304；如果有变化，则返回200；**

**7、上述的一些流程还可以用下图来表示**

![Alt text](/../../../../Typora图库/Web前端/304流程.png)

#### 私有缓存和公共缓存

在`Cache-Control`还有两个值：`private`与`public`，其中：

- `public` 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了 `public` ，则一些通常不被中间人缓存的页面（因为默认是 `private`）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。
- 而 `private` 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

#### Etag与Cache-Control的区别

Cache-Control: max-age=1000 ：请求完成，响应完毕后，响应体保存1000秒，时间一到缓存就没有了，需要从新请求服务器，去拿对应的数据。1000秒期间，浏览器不会再次发送任何请求，只在本地缓存拿数据。

ETag：对比本地与服务器端的MD5返回值，若一致，不需要重新加载响应体，若不一致（说明文本发生了改变）则重新下载响应体。当数据没发生改变的时候，每次请求虽然不会重新加载响应体，但是还是发送了请求。

如果资源没过期，前者根本不会发送请求，后者会发送请求。

### 7 语义化的理解

⽤正确的标签做正确的事情！
HTML **语义化就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析**；
在没有样式CSS 情况下也以⼀种⽂档格式显示，并且是容易阅读的。
搜索引擎的爬⾍依赖于标记来确定上下⽂和各个关键字的权重，利于 SEO 。
使阅读源代码的⼈对⽹站更容易将⽹站分块，便于阅读维护理解

### 8 浏览器内核的理解：渲染引擎和JS 引擎

主要分成两部分：渲染引擎( layout engineer 或Rendering Engine )和JS 引擎

- 渲染引擎：负责取得⽹⻚的内容（ HTML 、XML 、图像等等）、整理讯息（例如加⼊CSS 等），以及计算⽹⻚的显示⽅式，然后会输出⾄显示器或打印机。浏览器的内核的不同对于⽹⻚的语法解释会有不同，所以渲染的效果也不相同。所有⽹⻚浏览器、电⼦邮件客户端以及其它需要编辑、显示⽹络内容的应⽤程序都需要内核

- JS 引擎：解析和执⾏javascript 来实现⽹⻚的动态效果

最开始渲染引擎和JS 引擎并没有区分的很明确，后来JS引擎越来越独⽴，内核就倾向于只指渲染引擎

### 9 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下？

在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤户机器上的缓存⽂件

原理： HTML5 的离线存储是**基于⼀个新建的.appcache ⽂件的缓存机制**(不是存储技术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像cookie ⼀样被存储了下来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示

如何使⽤：

- ⻚⾯头部像下⾯⼀样加⼊⼀个manifest 的属性；
- 在cache.manifest ⽂件的编写离线存储的资源
- 在离线状态时，操作window.applicationCache 进⾏需求实现

浏览器是怎么对HTML5 的离线储存资源进⾏管理和加载的呢：

- 在线的情况下，浏览器发现html 头部有manifest 属性，它会请求manifest ⽂件
  - 如果是第⼀次访问app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏离线存储。
  - 如果已经访问过app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的manifest ⽂件与旧的manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。
- 离线的情况下，浏览器就直接使⽤离线存储的资源。

### 10  cookies ， sessionStorage 和 localStorage 的区别？cookie和session的区别

- cookie 是**⽹站为了标示⽤户身份⽽储存在⽤户本地终端（Client Side）上的数据（通常经过加密）**
- cookie数据**始终在同源的http请求中携带**（即使不需要），记会在浏览器和服务器间来回传递
- sessionStorage 和localStorage 不会⾃动把数据发给服务器，**仅在本地保存**
-  IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 更接近 NoSQL 数据库。 （ 现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。 ）
- 存储⼤⼩：

  - cookie 数据⼤⼩不能超过4k

  - sessionStorage 和localStorage 虽然也有存储⼤⼩的限制，但⽐cookie ⼤得多，可以达到5M或更⼤
- 有期时间：
	- localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据
	- sessionStorage 数据在当前浏览器窗⼝关闭后⾃动删除
	- cookie 设置的cookie 过期时间之前⼀直有效，即使窗⼝或浏览器关闭

![](/../../../../Typora图库/Web前端/cookie和localSrorage、session、indexDB.png)
对于 cookie ，我们还需要注意安全性

![](/../../../../Typora图库/Web前端/cookie安全性.png)

**cookie 和session 有什么区别？**  

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、建议：
  将登陆信息等重要信息存放为SESSION
  其他信息如果需要保留，可以放在COOKIE中

一般来说,登陆验证信息,客户的私人信息,如姓名,电话等,应该放在Session中.

Cookie则用于用户登陆网站时的自动登陆以及类似"购物车"的处理.使用Cookie保存信息时最好通过加密形式来保存数据,同时是否保存登陆信息,需要由用户自行选择。

### 11 iframe有那些缺点？

- iframe 会阻塞主⻚⾯的Onload 事件
- 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于SEO
- iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载
- 使⽤iframe 之前需要考虑这两个缺点。如果需要使⽤iframe ，最好是通过javascript 动态给iframe 添加src 属性值，这样可以绕开以上两个问题

### 12  对web标准、可⽤性、可访问性的理解

标签闭合、标签⼩写、不乱嵌套、使⽤外链css 和js 、结构⾏为表现的分离

- 可⽤性（Usability）：产品是否容易上⼿，⽤户能否完成任务，效率如何，以及这过程中⽤户的主观感受可好，是**从⽤户的⻆度来看产品的质量**。可⽤性好意味着产品质量⾼，是企业的核⼼竞争⼒
- 可访问性（Accessibility）：Web内容对于**残障⽤户**的可阅读和可理解性
- 可维护性（Maintainability）：⼀般包含两个层次，⼀是**当系统出现问题时，快速定位并解决问题的成本**，成本低则可维护性好。⼆是**代码是否容易被⼈理解**，是否容易修改和增强功能。

### 13 Doctype作⽤? 严格模式与混杂模式如何区分？它们有何意义?

- `<!DOCTYPE>` 声明位于⽂档中的最前⾯，处于 `<html>` 标签之前。**告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档**
- **严格模式**的排版和 JS 运作模式是 **以该浏览器⽀持的最⾼标准运⾏**
- 在**混杂模式**中，⻚⾯**以宽松的向后兼容的⽅式显示**。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。 DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现

### 14 ⾏内元素有哪些？块级元素有哪些？ 空(void)元素有那些？⾏内元素和块级元素有什么区别？

- ⾏内元素有：` <a> <b> <span> <img> <input> <select> <strong>`
- 块级元素有： `<div> <ul> <ol> <li> <dl> <dt> <dd> <h1> <h2> <h3> <h4>… <p>`
- 空元素：` <br> <hr> <img> <input> <link> <meta>`
- ⾏内元素不可以设置宽⾼，不独占⼀⾏
- 块级元素可以设置宽⾼，独占⼀⾏

### 15 HTML全局属性(global attribute)有哪些

- class :为元素设置类标识
- data-* : 为元素增加⾃定义属性
- draggable : 设置元素是否可拖拽
- id : 元素id ，⽂档内唯⼀
- lang : 元素内容的的语⾔
- style : ⾏内css 样式
- title : 元素相关的建议信息

### 16 Canvas和SVG有什么区别？

- svg 绘制出来的每⼀个图形的元素都是**独⽴的DOM 节点**，能够⽅便的绑定事件或⽤来修改。canvas 输出的是**⼀整幅画布**
- svg 输出的图形是**⽮量图形**，后期可以修改参数来⾃由放⼤缩⼩，不会失真和锯⻮。⽽canvas 输出**标量画布**，就像⼀张图⽚⼀样，放⼤会失真或者锯⻮

### 17 如何在⻚⾯上实现⼀个圆形的可点击区域？

svg
border-radius
纯js 实现 需要求⼀个点在不在圆上简单算法、获取⿏标坐标等等

### 18 ⽹⻚验证码是⼲嘛的，是为了解决什么安全问题

- 区分⽤户是计算机还是⼈的公共全⾃动程序。可以防⽌恶意破解密码、刷票、论坛灌⽔
- 有效防⽌⿊客对某⼀个特定注册⽤户⽤特定程序暴⼒破解⽅式进⾏不断的登陆尝试

### 19 viewport

```javascript
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimu
// width 设置viewport宽度，为⼀个正整数，或字符串‘device-width’
// device-width 设备宽度
// height 设置viewport⾼度，⼀般设置了宽度，会⾃动解析出⾼度，可以不⽤设置
// initial-scale 默认缩放⽐例（初始缩放⽐例），为⼀个数字，可以带⼩数
// minimum-scale 允许⽤户最⼩缩放⽐例，为⼀个数字，可以带⼩数
// maximum-scale 允许⽤户最⼤缩放⽐例，为⼀个数字，可以带⼩数
// user-scalable 是否允许⼿动缩放
```

-  移动端浏览器通常都在一个比屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是viewport，目的是**正常展示没有做移动端适配的网页**，可以让他们完整的展现给用户。我们有时用移动设备访问桌面版网页就会看到一个横向滚动条，这里可显示区域的宽度就是viewport的宽度。 
- 延伸提问
  - 怎样处理 移动端 1px 被 渲染成 2px 问题
- 局部处理
- mate 标签中的 viewport 属性 ， initial-scale 设置为 1
- rem 按照设计稿标准⾛，外加利⽤transfrome 的scale(0.5) 缩⼩⼀倍即可；
- 全局处理
  - mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5
  - rem 按照设计稿标准⾛即可

### 20 渲染优化

- 禁⽌使⽤iframe （阻塞⽗⽂档onload 事件）
  - iframe 会阻塞主⻚⾯的Onload 事件
  - 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于SEO
  - iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载
  - 使⽤iframe 之前需要考虑这两个缺点。如果需要使⽤iframe ，最好是通过javascript
  - 动态给iframe 添加src 属性值，这样可以绕开以上两个问题
- 禁⽌使⽤gif 图⽚实现loading 效果（降低CPU 消耗，提升渲染性能）
- 使⽤CSS3 代码代替JS 动画（尽可能避免重绘重排以及回流）
- 对于⼀些⼩图标，可以使⽤base64位编码，以减少⽹络请求。但不建议⼤图使⽤，⽐较耗费CPU
  
    - ⼩图标优势在于：减少HTTP 请求；避免⽂件跨域；修改及时⽣效
- ⻚⾯头部的`<style></style> <script></script>` 会阻塞⻚⾯；（因为 Renderer进程中 JS 线程和渲染线程是互斥的）
- ⻚⾯中空的 href 和 src 会阻塞⻚⾯其他资源的加载 (阻塞下载进程)
- ⽹⻚gzip ， CDN 托管， data 缓存 ，图⽚服务器
- 前端模板 JS+数据，减少由于HTML 标签导致的带宽浪费，前端⽤变量保存AJAX请求结果，每次操作本地变量，不⽤请求，减少请求次数
- ⽤innerHTML 代替DOM 操作，减少DOM 操作次数，优化javascript 性能
- 当需要设置的样式很多时设置className ⽽不是直接操作style
  
-  少⽤全局变量、缓存DOM 节点查找的结果。减少IO 读取操作

### 21 浏览器的内核分别是什么?

- IE : trident 内核
- Firefox ： gecko 内核

- Safari : webkit 内核
- Opera :以前是presto 内核， Opera 现已改⽤Google - Chrome 的Blink 内核
- Chrome:Blink (基于webkit ，Google与Opera Software共同开发)

### 22 div+css的布局较table布局有什么优点？

改版的时候更⽅便 只要改css ⽂件。
⻚⾯加载速度更快、结构化清晰、⻚⾯显示简洁。
表现与结构相分离。
易于优化（ seo ）搜索引擎更友好，排名更容易靠前。

### 23 渐进增强和优雅降级的不同吗

渐进增强：针对低版本浏览器进⾏构建⻚⾯，保证最基本的功能，然后再针对⾼级浏览器进⾏效果、交互等改进和追加功能达到更好的⽤户体验。
优雅降级：⼀开始就构建完整的功能，然后再针对低版本浏览器进⾏兼容。

区别：优雅降级是从复杂的现状开始，并试图减少⽤户体验的供给，⽽渐进增强则是从⼀个⾮常基础的，能够起作⽤的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；⽽渐进增强则意味着朝前看，同时保证其根基处于安全地带

### 24 为什么利⽤多个域名来存储⽹站资源会更有效？

CDN 缓存更⽅便
突破浏览器并发限制
节约cookie 带宽
节约主域名的连接数，优化⻚⾯响应速度
防⽌不必要的安全问题

### 25 src与href的区别

- **src ⽤于替换当前元素，href⽤于在当前⽂档和引⽤资源之间确⽴联系。**
- src 是source 的缩写，指向外部资源的位置，**指向的内容将会嵌⼊到⽂档中当前标签所在位置**；**在请求src 资源时会将其指向的资源下载并应⽤到⽂档内**，例如js 脚本，img 图⽚和frame 等元素
  - `<script src ="js.js"></script>` 当浏览器解析到该元素时，**会暂停其他资源的下载和处理**，直到将该资源加载、编译、执⾏完毕，图⽚和框架等元素也如此，类似于将所指向资源嵌⼊当前标签内。这也是为什么将js脚本放在底部⽽不是头部
- href 是Hypertext Reference 的缩写，**指向⽹络资源所在位置，建⽴和当前元素（锚点）或当前⽂档（链接）之间的链接**，如果我们在⽂档中添加`<link href="common.css" rel="stylesheet"/>`那么浏览器会识别该⽂档为css ⽂件，就会并⾏下载资源并且不会停⽌对当前⽂档的处理。 **页面解析不会暂停**（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。 这也是为什么**建议使⽤link ⽅式来加载css ，⽽不是使⽤@import ⽅式**

### 26 知道的⽹⻚制作会⽤到的图⽚格式有哪些？

- png-8 、png-24 、jpeg 、gif 、svg
- Webp： WebP 格式，⾕歌（google）开发的⼀种旨在加快图⽚加载速度的图⽚格式。图⽚压缩体积⼤约只有JPEG 的2/3 ，并能节省⼤量的服务器带宽资源和数据空间。Facebook Ebay 等知名⽹站已经开始测试并使⽤WebP 格式。
  在质量相同的情况下，WebP格式图像的体积要⽐JPEG格式图像⼩40% 。
- Apng：全称是“Animated Portable Network Graphics” , 是PNG的位图动画扩展，可以实现png格式的动态图⽚效果。04年诞⽣，但⼀直得不到各⼤浏览器⼚商的⽀持，直到⽇前得到 iOS safari 8 的⽀持，有望代替GIF 成为下⼀代动态图标准

### 27 从⽤户刷新⽹⻚开始，⼀次js请求⼀般情况下有哪些地⽅会有缓存处理？

dns 缓存， cdn 缓存，浏览器缓存，服务器缓存

### 28 优化图⽚的加载

- **图⽚懒加载**，在⻚⾯上的未可视区域可以添加⼀个滚动事件，判断图⽚位置与浏览器顶端的距离与⻚⾯的距离，如果前者⼩于后者，优先加载。
- 如果为幻灯⽚、相册等，可以使⽤**图⽚预加载**技术，将当前展示图⽚的前⼀张和后⼀张优先下载。
- 如果图⽚为css图⽚，可以使⽤CSSsprite ， SVGsprite ， Iconfont 、Base64 等技术。
- 如果图⽚过⼤，可以**使⽤特殊编码的图⽚**，加载时会先加载⼀张压缩的特别厉害的缩略图，以提⾼⽤户体验。
- 如果图⽚展示区域⼩于图⽚的真实⼤⼩，则因在服务器端根据业务需要先⾏进⾏**图⽚压缩**，图⽚压缩后⼤⼩与展示⼀致。

### 29 web开发中会话跟踪的⽅法

cookie
session
url 重写
隐藏input
ip 地址

### 30 HTTP request报⽂结构

1. ⾸⾏是Request-Line包括：**请求⽅法，请求URI，协议版本，CRLF**( 回车换行 )
2. ⾸⾏之后是若⼲⾏请求头，包括general-header，request-header或者entity-header，每个⼀⾏以CRLF结束
3. 请求头和消息实体之间有⼀个CRLF分隔
4. 根据实际请求需要可能包含⼀个消息实体

⼀个请求报⽂例⼦如下：

```js
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML,
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
name=qiu&age=25
```

### 31 HTTP response报⽂结构

- ⾸⾏是状态⾏包括：HTTP版本，状态码，状态描述，后⾯跟⼀个CRLF
- ⾸⾏之后是若⼲⾏响应头，包括：通⽤头部，响应头部，实体头部
- 响应头部和响应实体之间⽤⼀个CRLF空⾏分隔
- 最后是⼀个可能的消息实体

响应报⽂例⼦如下：

```
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1
{"name": "qiu", "age": 25}
```

### 32 同步和异步的区别

- 同步：浏览器访问服务器请求，**⽤户看得到⻚⾯刷新**，重新发请求,等请求完，⻚⾯刷新，新内容出现，⽤户看到新内容,进⾏下⼀步操作
- 异步：浏览器访问服务器请求，**⽤户正常操作，浏览器后端进⾏请求**。等请求完，⻚⾯不刷新，新内容也会出现，⽤户看到新内容

### 34 attribute和property的区别是什么

- **attribute 是dom 元素在⽂档中作为html 标签拥有的属性；**
- **property 就是dom 元素在js 中作为对象拥有的属性。**
- 对于html 的标准属性来说， attribute 和property 是同步的，是会⾃动更新的；但是对于⾃定义的属性来说，他们是不同步的

### 35 浏览器缓存：**强缓存**，协商缓存

浏览器缓存分为**强缓存**和**协商缓存**。当客户端请求某个资源时，获取缓存的流程如下

- 先根据这个资源的⼀些 http header 判断它是否命中**强缓存，如果命中，则直接从本地获取缓存资源**，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另⼀些request header验证这个资源是否命中**协商缓存，称为http 再验证，如果命中，服务器将请求返回，但不返回资源，⽽是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源**；
- 强缓存和协商缓存共同之处在于，**如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会**。
- 当**协商缓存也没命中时，服务器就会将资源发送回客户端**。
- 当 ctrl+f5 强制刷新⽹⻚时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 f5 刷新⽹⻚时，跳过强缓存，但是会检查协商缓存；

**强缓存**

- 实现强缓存可以通过两种响应头实现： Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求， **state code 为 200**
- Expires （该字段是 http1.0 时的规范，值为⼀个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
- Cache-Control:max-age （该字段是 http1.1 的规范，强缓存利⽤其 max-age 值来判断缓存资源的最⼤⽣命周期，它的值单位为秒）

**协商缓存**

- 如果缓存过期了，我们就可以使⽤协商缓存来解决问题。协商缓存需要请求，如果**缓存有效会返回 304**
- If-Modified-Since （通过⽐较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
- ETag （表示资源内容的唯⼀标识，随服务器response 返回）
- If-None-Match （服务器通过⽐较请求头部的If-None-Match 与当前资源的ETag 是否⼀致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

**Last-Modified 和 If-Modified-Since**

- Last-Modified 表示本地⽂件最后修改⽇期， If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该⽇期后资源是否有更新，有更新的话就会将新的资源发送回来。
- 但是如果在本地打开缓存⽂件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1出现了 ETag

**ETag 和 If-None-Match**

ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且ETag 优先级⽐ Last-Modified ⾼

**选择合适的缓存策略**

对于**⼤部分的场景都可以使⽤强缓存配合协商缓存**解决，但是在⼀些特殊的地⽅可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使⽤ Cache-control: no-store ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使⽤ Cache-Control: no-cache 并配合 ETag 使⽤，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000 并配合策略缓存使⽤，然后对⽂件进⾏指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件

### 36 WebSocket

由于 http 存在⼀个明显的弊端（消息只能有客户端推送到服务器端，⽽服务器端不能主动推送到客户端），导致如果**服务器如果有连续的变化，这时只能使⽤轮询，⽽轮询效率过低**，并不适合。于是 WebSocket 被发明出来

相⽐与 http 具有以下有点：

- ⽀持**双向通信**，实时性更强；
- 可以发送⽂本，也可以⼆进制⽂件；
- **协议标识符是 ws ，加密后是 wss** ；
- 较少的控制开销。连接创建后， ws 客户端、服务端进⾏数据交换时，协议控制的数据包头部较⼩。在不包含头部的情况下，服务端到客户端的包头只有2~10 字节（取决于数据包⻓度），客户端到服务端的的话，需要加上额外的4字节的掩码。⽽HTTP 协议每次通信都需要携带完整的头部；
- ⽀持扩展。ws协议定义了扩展，⽤户可以扩展协议，或者实现⾃定义的⼦协议。（⽐如⽀持⾃定义压缩算法等）
- ⽆跨域问题。

### 37 对 Electron 的理解

electron 实际上是⼀个**套了 Chrome 的 nodeJS 程序**

**1）可以用 Web 前端技术开发跨平台的桌面客户端：**

这是 Electron 最迷人的地方，究其根本是因为它是建立在 Chromium 和 NodeJS 之上的，一个负责界面，一个负责背后的逻辑，典型的"你负责貌美如花，我负责赚钱养家"，为什么 Electron 能够开发跨平台的桌面应用也就可以理解了。

而对于前端开发来说，前端开发可以用自己熟悉的方式去写应用界面，逻辑部分也还是 JS，如果你精通 Node 后端，那后端也可以插一脚。

但是，不同系统间还是会有很大的不同，“同一套代码，编译出跨平台的多个客户端”，话是这么说，但你得因为系统的不同做一些额外的处理，以使得打包出的不同系统下的应用都可以正常工作，这可能是一些“if - else”的成本，但相比于那80%都能完全复用的代码，这些成本已经很小了。

综上所述：**一个 Web 前端开发者可以花很少的成本去上手 Electron**，而相比于以前开发多平台客户端的成本，利用 Electron 开发多平台客户端的成本是极低的。

**2）可以从 NodeJS 的生态获得极大的助力：**

因为 Electron 是基于 NodeJS 的，意味着，NodeJS 这个大生态下的模块，Electron 也都可以用，这减少了很多造轮子的时间。

Electron 从 NodeJS 获益有2个方面，一个方面是如现代的 web 项目一般，开发构建流程可以**引入很多成熟的包**去打造出适合自己项目的开发工作流，另一个方面就是**其应用本身也可以依赖需要的包去完成自己的功能**。

**总结一下，使用Electron开发的理由：**

> a. 使用具有强大生态的Web技术进行开发，开发成本低，可扩展性强，更炫酷的UI；
> b. 跨平台，一套代码可打包为Windows、Linux、Mac三套软件，且编译快速；
> c. 可直接在现有Web应用上进行扩展，提供浏览器不具备的能力；

### 38 判断⻚⾯是否加载完成

Load 事件触发代表⻚⾯中的 DOM ， CSS ， JS ，图⽚已经全部加载完毕。
DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待CSS ， JS ，图⽚加载

### 39 负载均衡

多台服务器共同协作，不让其中某⼀台或⼏台超额⼯作，发挥服务器的最⼤作⽤

- http 重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第⼀次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip 服务器中的⼀个（可监控性较弱）
- 反向代理负载均衡：访问统⼀的服务器，由服务器进⾏调度访问实际的某个服务器，对统⼀的服务器要求⼤，性能受到 服务器群的数量

### 40 Service worker

本质上**充当Web应⽤程序与浏览器之间的代理服务器**，也可以**在⽹络可⽤时作为浏览器和⽹络间的代理**。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截⽹络请求并基于⽹络是否可⽤以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API

### 41 浏览器性能问题：重绘（Repaint）和回流（Reflow）

- 重绘和回流是渲染步骤中的⼀⼩节，但是这两个步骤对于性能影响很⼤。
- **重绘是当节点需要更改外观⽽不会影响布局的**，⽐如改变 color 就叫称为重绘
- **回流是布局或者⼏何属性需要改变**就称为回流。
- **回流必定会发⽣重绘，重绘不⼀定会引发回流**。回流所需的成本⽐重绘⾼的多，改变深层次的节点很可能导致⽗节点的⼀系列回流。

在以下情况会发生reflow：
 1.改变窗囗大小
 2.改变文字大小
 3.添加/删除样式表
 4.内容的改变，如用户在输入框中敲字(这样也会-_-||)
 5.激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活)
 6.操作class属性
 7.脚本操作DOM
 8.计算offsetWidth和offsetHeight
 9.设置style属性

所以以下⼏个动作可能会导致性能问题：

- 改变 window ⼤⼩
- 改变字体
- 添加或删除样式
- ⽂字改变
- 定位或者浮动
- 盒模型

重绘和回流其实和 Event loop 有关。

- 当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。

- 因为浏览器是 60Hz 的刷新率，每 16ms 才会更新⼀次。
- 然后判断是否有resize 或者 scroll ，有的话会去触发事件，所以 resize 和scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。
- 判断是否触发了 media query
- 更新动画并且发送事件
- 判断是否有全屏操作事件
- 执⾏ requestAnimationFrame 回调
- 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好
- 更新界⾯
- 以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏requestIdleCallback 回调。

减少重绘和回流：

- 使⽤ translate 替代 top

- 使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）

- 把 DOM 离线后修改，⽐如：先把 DOM 给 display:none (有⼀次 Reflow )，然后你修改100 次，然后再把它显示出来
- 不要把 DOM 结点的属性值放在⼀个循环⾥当成循环⾥的变量
- 不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤requestAnimationFrame
- CSS 选择符从右往左匹配查找，避免 DOM 深度过深
- 将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video标签，浏览器会⾃动将该节点变为图层。

### 42 使⽤ HTTP / 2.0

- 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建⽴和断开，消耗了好⼏个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积⼤的⽂件会需要更多的时间
- 在 HTTP / 2.0 中引⼊了**多路复⽤**，能够让多个请求使⽤同⼀个 TCP 链接，极⼤的加快了⽹⻚的加载速度。并且还**⽀持 Header 压缩**，进⼀步的减少了请求的数据⼤⼩

### 43 预加载，预渲染

在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候就可以使⽤**预加载**
预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使⽤以下代码开启预加载

```html
<link rel="preload" href="http://example.com">
```

预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后加载，唯⼀缺点就是兼容性不好

可以通过**预渲染**将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染

```html
<link rel="prerender" href="http://poetries.com">
```

预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染

### 44 懒执⾏，懒加载

**懒执⾏**就是**将某些逻辑延迟到使⽤时再计算**。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。**懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤来唤醒**

**懒加载**就是**将不关键的资源延后加载**

懒加载的原理就是**只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内需要加载的东⻄**。对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实的图⽚资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样图⽚就会去下载资源，实现了图⽚懒加载

懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等

### 45 如果一个HTML文档内含有阿拉伯文，应该使用哪种编码

UTF8 是(UNICODE八位交换格式）的简称，UNICODE是国际标准，也是ISO标准10646的等价标准。

UNICODE编码的文件中可以同时对几乎所有地球上已知的文字字符进行书写和表示，而且已经是UNIX/LINUX世界的默认编码标准。在中国简体中文版非常常用的GB2312/GB18030/GBK系列标准是我国的国家标准，但只能对中文和多数西方文字进行编码。

为了网站的通用性起见，用UTF8编码是更好的选择。

**UTF-8是世界通用的语言编码**

浏览UTF-8编码的任何网页，无论是中文、还是日文、韩文、阿拉伯文，都可以正常显示。

### 46 锚伪类

在支持 CSS 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。

```css
a:link{color: #FF0000}/* 未访问的链接 */
a:visited{color: #00FF00}/* 已访问的链接 */
a:hover{color: #FF00FF}/* 鼠标移动到链接上 */
a:active{color: #0000FF}/* 选定的链接 */
```

在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。

在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。

伪类名称对大小写不敏感。

### 47 CDN

内容分发⽹络，基本思路是尽可能避开互联⽹上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie

### 48 重构

- ⽹站重构：在不改变外部⾏为的前提下，简化结构、添加可读性，⽽在⽹站前端保持⼀致的⾏为。也就是说是在不改变UI的情况下，对⽹站进⾏优化， 在扩展的同时保持⼀致的UI
- 对于传统的⽹站来说重构通常是：
  - 表格( table )布局改为DIV+CSS
  - 使⽹站前端兼容于现代浏览器(针对于不合规范的CSS 、如对IE6有效的)
  - 对于移动平台的优化
  - 针对于SEO 进⾏优化

## 二、CSS

### 1 css sprite

概念：将多个⼩图⽚拼接到⼀个图⽚中。通过background-position 和元素尺⼨调节需要显示的背景图案。

优点：

- 减少HTTP 请求数，极⼤地提⾼⻚⾯加载速度
- 增加图⽚信息重复度，提⾼压缩⽐，减少图⽚⼤⼩
- 更换⻛格⽅便，只需在⼀张或⼏张图⽚上修改颜⾊或样式即可实现

缺点：

- 图⽚合并麻烦
- 维护麻烦，修改⼀个图⽚可能需要从新布局整个图⽚，样式

### 2 opacity:0; display: none; 与visibility: hidden; 的区别，rgba()和opacity的透明效果有什么不同？

联系：它们都能让元素不可⻅

1、**display:none**
 （1）、浏览器不会生成属性为display: none;的元素。
 （2）、display: none;不占据空间，把元素隐藏起来，所以动态改变此属性时会引起重排（改变页面布局），可以理解成在页面中把该元素删除掉一样。
 （3）、display: none;不会被子孙继承，但是其子孙是不会显示的，毕竟都一起被隐藏了。
 （4）、transition无效。
 2、**visibility:hidden**
 （1）、元素会被隐藏，但是不会消失，依然占据空间，隐藏后不会改变html原有样式。
 （2）、visibility: hidden会被子孙继承，子孙也可以通过显示的设置visibility: visible;来反隐藏。
 （3）、visibility: hidden;不会触发该元素已经绑定的事件。
 （4）、visibility: hidden;动态修改此属性会引起重绘。
 （5）、transition无效。
 3、**opacity:0;filter：alpha(opacity=0-100;**（考虑浏览器兼容性的问题，最好两个都写上）
 （1）、opacity:0;filter：alpha(opacity=0-100;只是透明度为100%,元素隐藏，依然占据空间,隐藏后不会改变html原有样式。
 （2）、opacity:0;filter：alpha(opacity=0-100;会被子元素继承,且子元素并不能通过opacity=1，进行反隐藏。
 （3）、opacity:0;filter：alpha(opacity=0-100;的元素依然能触发已经绑定的事件。
 （4）、transition有效。
 4、**各种隐藏**
 { display: none; /* 不占据空间，无法点击 */ }
 { visibility: hidden; /* 占据空间，无法点击 */ }
 { opacity: 0; filter:Alpha(opacity=0); /* 占据空间，可以点击 */ }
 { position: absolute; top: -999em; /* 不占据空间，无法点击 */ }
 { position: relative; top: -999em; /* 占据空间，无法点击 */ }
 { position: absolute; visibility: hidden; /* 不占据空间，无法点击 */ }
 { height: 0; overflow: hidden; /* 不占据空间，无法点击 */ }
 { position: absolute; opacity: 0; filter:Alpha(opacity=0); /* 不占据空间，可以点击 */ }

**rgba()和opacity的透明效果**

- rgba() 和opacity 都能实现透明效果，但最⼤的不同是**opacity 作⽤于元素**，以及元素内的所有内容的透明度，
- ⽽**rgba() 只作⽤于元素的颜⾊或其背景⾊**。（**设置rgba 透明的元素的⼦元素不会继承透明效果！**）

### 3 link 与@import 的区别

1. link 是HTML ⽅式， @import 是CSS⽅式
2. link 最⼤限度⽀持并⾏下载， @import 过多嵌套导致串⾏下载，出现FOUC (⽂档样式短暂失效)
3. link 可以通过rel="alternate stylesheet" 指定候选样式
4. 浏览器对link ⽀持早于@import ，可以使⽤@import 对⽼浏览器隐藏样式
5. @import 必须在样式规则之前，可以在css⽂件中引⽤其他⽂件
6. 总体来说： link 优于@import

### 4 什么是FOUC?如何避免

Flash Of Unstyled Content ：⽤户定义样式表加载之前浏览器使⽤默认样式显示⽂档，⽤户样式加载渲染之后再从新显示⽂档，造成⻚⾯闪烁。
解决⽅法：把样式表放到⽂档的`<head>`

### 5 

### 6 display、float、position的关系

- 如果display 取值为none ，那么position 和float 都不起作⽤，这种情况下元素不产⽣框
- 否则，如果position 取值为absolute 或者fixed ，框就是绝对定位的， float 的计算值为none ， display 根据下⾯的表格进⾏调整。
- 否则，如果float 不是none ，框是浮动的， display 根据下表进⾏调整
- 否则，如果元素是根元素， display 根据下表进⾏调整
- 其他情况下display 的值为指定值
- 总结起来：绝对定位、浮动、根元素都需要调整display

### 7 浮动和清除浮动，清除浮动的⼏种⽅式，各⾃的优缺点

浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另⼀个浮动框的边框为⽌。由于浮动框不在⽂档的普通流中，所以⽂档的普通流的块框表现得就像浮动框不存在⼀样。浮动的块框会漂浮在⽂档普通流的块框上

- ⽗级div 定义height
- 结尾处加空div 标签clear:both
- **⽗级div 定义伪类:after 和zoom**
- ⽗级div 定义overflow:hidden
- ⽗级div 也浮动，需要定义宽度
- 结尾处加br 标签clear:both
- ⽐较好的是第3种⽅式

### 8 为什么要初始化CSS样式?

- 因为**浏览器的兼容问题**，不同浏览器对有些标签的默认值是不同的，如果没对CSS 初始化往往会出现浏览器之间的⻚⾯显示差异。
- 当然，初始化样式会对SEO 有⼀定的影响，但⻥和熊掌不可兼得，但⼒求影响最⼩的情况下初始化

### 9 css3有哪些新特性

新增各种css 选择器
圆⻆ border-radius
多列布局
阴影和反射
⽂字特效text-shadow
线性渐变
旋转transform

**CSS3新增伪类有哪些？**

p:first-of-type 选择属于其⽗元素的⾸个`<p>` 元素的每个`<p>` 元素。
p:last-of-type 选择属于其⽗元素的最后 `<p>` 元素的每个`<p>` 元素。
p:only-of-type 选择属于其⽗元素唯⼀的 `<p>` 元素的每个` <p>` 元素。
p:only-child 选择属于其⽗元素的唯⼀⼦元素的每个 `<p>` 元素。
p:nth-child(2) 选择属于其⽗元素的第⼆个⼦元素的每个 `<p>` 元素。
:after 在元素之前添加内容,也可以⽤来做清除浮动。
:before 在元素之后添加内容。
:enabled 已启⽤的表单元素。
:disabled 已禁⽤的表单元素。
:checked 单选框或复选框被选中。

### 10 display有哪些值？说明他们的作⽤

block 转换成块状元素。
inline 转换成⾏内元素。
none 设置元素不可⻅。
inline-block 象⾏内元素⼀样显示，但其内容象块类型元素⼀样显示。
list-item 象块类型元素⼀样显示，并添加样式列表标记。
table 此元素会作为块级表格来显示
inherit 规定应该从⽗元素继承 display 属性的值

### 11 盒模型

 当你对一个文档进行布局(laying out)时候, 浏览器引擎会根据CSS-Box模型将所有元素描述为一个盒子, CSS会决定这些盒子的大小, 位置, 属性(颜色, 边框...)。 

 盒模型分为两类: IE盒模型和标准盒模型。 两者的区别在于: 

- IE盒模型的width/height = content + border + padding 

- 标准盒模型的width/height = content 

IE盒模型：

   ![IE盒模型](/../../../../Typora图库/Web前端/IE盒模型.png) 

标准盒模型：

 ![标准盒模型](/../../../../Typora图库/Web前端/标准盒模型.png)

### 12 

### 13 BFC规范

它决定了元素如何对其内容进⾏定位,以及与其他元素的关系和相互作⽤

BFC相对于一个盒子，内部的元素与外界的元素互不干扰，它不会影响外部的布局，外部的布局也不会影响到它。

**形成条件**

- float的值不是none
- position的值不是static或者relative
- display的值是inline-block,table-cell,flex,table-caption或者inline-flex.
- overflow的值不是visible

**特性**

- 内部的盒子会在垂直方向上一个接一个地放置
- 对于同一个BFC的两个相邻的盒子的margin会发生重叠
- 每个元素的左外边距与包含块的左边界相接触
- BFC的区域不会与float的元素区域重叠
- 计算BFC的高度时，浮动子元素也参与计算
- BFC就是页面上的一个隔离的独立容器，不会影响外面的元素

**应用场景**

- 解决浮动子元素导致父元素高度坍塌的问题
- 解决文字环绕在float四周的情况
- 解决边距重叠的问题

### 14 

### 15 display:inline-block 什么时候不会显示间隙？

移除空格
使⽤margin 负值
使⽤font-size:0
letter-spacing
word-spacing

### 16 PNG\GIF\JPG的区别及如何选

GIF

- 8 位像素， 256 ⾊
- ⽆损压缩
- ⽀持简单动画
- ⽀持boolean 透明
- 适合简单动画

JPEG

- 颜⾊限于256
- 有损压缩
- 可控制压缩质量
- 不⽀持透明
- 适合照⽚

PNG

- 有PNG8 和truecolor PNG
- PNG8 类似GIF 颜⾊上限为256 ，⽂件⼩，⽀持alpha 透明度，⽆动画
- 适合图标、背景、按钮

### 17 ⾏内元素float:left后是否变为块级元素？

**⾏内元素设置成浮动之后变得更加像是inline-block** （⾏内块级元素，设置成这个属性的元素会同时拥有⾏内和块级的特性，最明显的不同是它的默认宽度不是100% ），这时候给⾏内元素设置padding-top 和padding-bottom或者width 、height 都是有效果的

### 18 在⽹⻚中的应该使⽤奇数还是偶数的字体？

偶数字号相对更容易和 web 设计的其他部分构成⽐例关系

### 19 ::before 和 :after中双冒号和单冒号有什么区别？伪类和伪元素的区别

单冒号( : )⽤于CSS3 伪类，双冒号( :: )⽤于CSS3 伪元素

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号

### 20 如果需要⼿动写动画，你认为最⼩时间间隔是多久，为什么？

多数显示器默认频率是60Hz ，即1 秒刷新60 次，所以理论上最⼩间隔为1/60*1000ms ＝ 16.7ms

### 21 CSS合并⽅法

避免使⽤@import 引⼊多个css ⽂件，可以使⽤CSS ⼯具将CSS 合并为⼀个CSS ⽂件，例如使⽤Sass\Compass 等

### 22 CSS优先级算法，CSS不同选择器的权重(CSS层叠的规则)，CSS的特殊性 

**CSS优先级算法**

**优先级就近原则**，同权重情况下样式定义最近者为准
载⼊样式以最后载⼊的定位为准
优先级为: !important > id > class > tag ; !important ⽐ 内联优先级⾼

**CSS不同选择器的权重**

！important 规则最重要，⼤于其它规则
⾏内样式规则，加1000
对于选择器中给定的各个ID 属性值，加100
对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10
对于选择其中给定的各个元素标签选择器，加1
如果权值⼀样，则按照样式规则的先后顺序来应⽤，顺序靠后的覆盖靠前的规则

**CSS的特殊性**

 在CSS中，会根据选择器的特殊性来决定所定义的样式规则的次序，具有更特殊选择器的规则优先于具有一般选择器的规则，如果两个规则的特殊性相同，那么后定义的规则优先。计算规则可以看下面一张图： 

 ![img](/../../../../Typora图库/Web前端/css特殊性.png) 

我们把特殊性分为4个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。
 第一等：代表内联样式，如: style=””，权值为1000。
 第二等：代表ID选择器，如：#content，权值为100。
 第三等：代表类，伪类和属性选择器，如.content，权值为10。
 第四等：代表类型选择器和伪元素选择器，如div p，权值为1。
 注意：通用选择器（*），子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为0。

### 23 列出你所知道可以改变⻚⾯布局的属性

position 、display 、float 、width 、height 、margin 、padding 、top 、left 、right

### 24 CSS在性能优化⽅⾯的实践

css 压缩与合并、Gzip 压缩
css ⽂件放在head ⾥、不要⽤@import
尽量⽤缩写、避免⽤滤镜、合理使⽤选择器

### 25 CSS3动画（简单动画的实现，如旋转等）

- 依靠CSS3 中提出的三个属性： transition 、transform 、animation
- transition ：定义了元素在变化过程中是怎么样的，包含transition-property 、transition-duration 、transition-timing-function 、transition-delay 。
- transform ：定义元素的变化结果，包含rotate 、scale 、skew 、translate 。
- animation ：动画定义了动作的每⼀帧（ @keyframes ）有什么效果，包括animation-name， animation-duration 、animation-timing-function 、animation-delay、animation-iteration-count 、animation-direction

**说⼀说css3的animation**

- css3的animation 是css3新增的动画属性，这个css3动画的每⼀帧是通过@keyframes来声明的， keyframes 声明了动画的名称，通过from 、to 或者是百分⽐来定义
- 每⼀帧动画元素的状态，通过animation-name 来引⽤这个动画，同时css3动画也可以定义动画运⾏的时⻓、动画开始时间、动画播放⽅向、动画循环次数、动画播放的⽅式，
- 这些相关的动画⼦属性有： animation-name 定义动画名、animation-duration 定义动画播放的时⻓、animation-delay 定义动画延迟播放的时间、animationdirection定义 动画的播放⽅向、animation-iteration-count 定义播放次数、animation-fill-mode 定义动画播放之后的状态、animation-play-state 定义播放状态，如暂停运⾏等、animation-timing-function
- 定义播放的⽅式，如恒速播放、艰涩播放等。

### 26 base64

优点可以加密，减少了HTTTP 请求
缺点是需要消耗CPU 进⾏编解码

**base64 的使⽤**

⽤于减少 HTTP 请求
适⽤于⼩图⽚
base64 的体积约为原图的4/3

### 27 stylus/sass/less区别

- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜⾊混合”五⼤基本特性
- Scss 和LESS 语法较为严谨， LESS 要求⼀定要使⽤⼤括号“{}”， Scss 和Stylus 可以通过缩进表示层次与嵌套关系
- Scss ⽆全局变量的概念， LESS 和Stylus 有类似于其它语⾔的作⽤域概念
- Sass 是基于Ruby 语⾔的，⽽LESS 和Stylus 可以基于NodeJS NPM 下载相应库后进⾏编译；

**Sass、LESS是什么？**

- 他们是**CSS 预处理器**。他是CSS 上的⼀种抽象层。他们是⼀种特殊的语法/语⾔编译成CSS 。
- 例如Less是⼀种动态样式语⾔. 将CSS赋予了动态语⾔的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运⾏ (⽀持IE 6+ , Webkit , Firefox )，也可⼀在服务端运⾏ (借助 Node.js )

**为什么要使⽤它们？**

- 结构清晰，便于扩展。
- 可以⽅便地屏蔽浏览器私有语法差异。这个不⽤多说，封装对- 浏览器语法差异的重复处理，减少⽆意义的机械劳动。
- 可以轻松实现多重继承。
- 完全兼容 CSS 代码，可以⽅便地应⽤到⽼项⽬中。LESS 只- 是在 CSS 语法上做了扩展，所以⽼的 CSS 代码也可以与 LESS 代码⼀同编译

### 28 postcss的作⽤

- 可以直观的理解为：它就是⼀个平台。为什么说它是⼀个平台呢？因为我们直接⽤它，感觉不能⼲什么事情，
- 但是如果让⼀些插件在它上⾯跑，那么将会很强⼤
- PostCSS 提供了⼀个解析器，它能够将 CSS 解析成抽象语法树
- 通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的CSS ，⽐如热⻔的： autoprefixer
- postcss 可以对sass处理过后的css 再处理 最常⻅的就是autoprefixer

### 29 如何美化CheckBox

`<label>` 属性 for 和 id
隐藏原⽣的 `<input>`
`:checked` + `<label>`

### 30 ⾃适应布局

思路：

- 左侧浮动或者绝对定位，然后右侧margin 撑开
- 使⽤`<div>` 包含，然后靠负margin 形成bfc
- 使⽤flex

### 31 外边距重叠

外边距重叠就是margin-collapse

在CSS当中，**相邻的两个盒⼦**（可能是兄弟关系也可能是祖先关系）**的外边距可以结合成⼀个单独的外边距**。这种合并外边距的⽅式被称为折叠，并且因⽽所结合成的外边距称为折叠外边距。

折叠结果遵循下列计算规则：

- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较⼤的值。
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较⼤值。
- 两个外边距⼀正⼀负时，折叠结果是两者的相加的和。

### 32 

### 33 css中可以让⽂字在垂直和⽔平⽅向上重叠的两个属性是什么？

垂直⽅向： line-height
⽔平⽅向： letter-spacing

### 34 如何垂直居中⼀个浮动元素？

```css
/**⽅法⼀：已知元素的⾼宽**/
#div1{
	background-color:#6699FF;
	width:200px;
	height:200px;
	position: absolute; //⽗元素需要相对定位
	top: 50%;
	left: 50%;
	margin-top:-100px ; //⼆分之⼀的height，width
	margin-left: -100px;
}

/**⽅法⼆:**/
#div1{
	width: 200px;
	height: 200px;
	background-color: #6699FF;
	margin:auto;
	position: absolute; //⽗元素需要相对定位
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
}
```

如何垂直居中⼀个`<img>` ?（⽤更简便的⽅法。）

```css
#container /**<img>的容器设置如下**/
{
	display:table-cell;
	text-align:center;
	vertical-align:middle;
}
```

### 35 px和em的区别

- px 和em 都是⻓度单位，区别是， **px 的值是固定的**，指定是多少就是多少，计算⽐较容易。em 的值不是固定的，并且**em 会继承⽗级元素的字体⼤⼩**。
- 浏览器的默认字体⾼都是16px 。所以**未经调整的浏览器都符合: 1em=16px** 。那么12px=0.75em , 10px=0.625em 。

### 36 css的content属性

css的content 属性**专⻔应⽤在 before/after 伪元素**上，**⽤于来插⼊⽣成内容**。最常⻅的应⽤是**利⽤伪类清除浮动**。

### 37 ⽔平居中的⽅法

- 元素为⾏内元素，设置⽗元素text-align:center
- 如果元素宽度固定，可以设置左右margin 为auto ;
- 如果元素为绝对定位，设置⽗元素position 为relative ，元素设left:0;right:0;margin:auto;
- 使⽤flex-box 布局，指定justify-content 属性为center
- display 设置为tabel-ceil

### 38 垂直居中的⽅法

- 将显示⽅式设置为表格， display:table-cell ,同时设置vertial-align：middle
- 使⽤flex 布局，设置为align-item：center
- 绝对定位中设置bottom:0,top:0 ,并设置margin:auto
- 绝对定位中固定⾼度时设置top:50%，margin-top 值为⾼度⼀半的负值
- ⽂本垂直居中设置line-height 为height 值

### 39 如何使⽤CSS实现硬件加速？

硬件加速是指通过创建独⽴的复合图层，让GPU来渲染这个图层，从⽽提⾼性能。

⼀般触发硬件加速的CSS 属性有transform 、opacity 、filter ，为了避免2D动画在开始和结束的时候的repaint 操作，⼀般使⽤tranform:translateZ(0)

### 40 两种以上⽅式实现已知或者未知宽度的垂直⽔平居中

- **flex**

   Flex布局即为弹性布局，只需将父元素设置三个属性即可**(display,justify-content,align-items)** 

- **绝对定位+margin负值（已知宽高）**

  利用负边距实现子元素居中(相对于父元素(position:relative))，需已知子元素的width与height；且把子元素的position设为absolute，绝对定位；以及设置left和top为50%；再加上负边距，margin-left值为width的一半，同样的，margin-top值为height的一半。

  我们来理解一下，绝对定位的子元素，通过自身的边界来相对于父元素进行定位，这个边界就是margin，当我们设置了left和top各为50%时，子元素左边界距父元素左边界50%,上边界距父元素上边界50%，其实此时，我们可以知道，子元素的左上角这个点，是水平垂直居中的，当我们设了负边距时，我们可以理解为这个子元素向右向上各移了自身长度的一半，这就达到了水平垂直居中。当然我们也可以这么理解，其实真正相对于父元素来定位的点就是子元素左上角的点，当我们设了负边距，子元素的中心点就取代了它左上角的点，若希望子元素能水平垂直居中，这时只需再设left和top各为50%时便可。

- **绝对定位+transfrom负值（未知宽高）**

- **绝对定位top left right bottom 0 + margin auto**

  使用绝对定位方式, 以及left:0;right:0;top:0;bottom:0;margin:auto

  当我们为子元素设置left:0;right:0;top:0;bottom:0;时，浏览器将给子元素重新分配一个边界框，此时子元素将填充其父元素的所有可用空间，当我们给子元素设置一个width或height，防止子元素占据所有的可用空间，浏览器将根据新的边界框重新计算，再加上margin:auto,由于被绝对定位，脱离了正常的文档流，浏览器会给margin-left,margin-right相同的值，margin-top,margin-bottom相同的值，使元素块在父元素中水平垂直居中。

- **display:table**

总结：

1.利用负边距方法优点是具有良好的跨浏览器特性，兼容IE6/IE7，但是缺点是不能自适应，需设置子元素的宽高，不支持百分比，且负边距值与padding和是否定义box-sizing: border-box有关，计算需要根据不同情况。

2.利用margin:auto方法支持跨浏览器，支持百分比，但是必须声明子元素的width或height(至少一项，不然会占据父元素所有空间)。

*这两种绝对定位方法，可在子元素中，设置overflow:auto来防止内容越界溢出*。

3.利用flex或transform方法的好处是代码量少，且你不用设置子元素的width与height,内容可由子元素里的子元素任意撑开，优雅地溢出。但flex IE8/IE9不支持，transform IE8不支持，且属性需要写浏览器厂商前缀。

```css
/** 2 **/
.wraper {
	position: relative;
	.box {
		position: absolute;
		top: 50%;
		left: 50%;
		width: 100px;
		height: 100px;
		margin: -50px 0 0 -50px;
        overflow: auto;
	}
}

/** 3 **/
.wraper {
	position: relative;
	.box {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
	}
}

/** 1 **/
.wraper {
	.box {
		display: flex;
		justify-content:center;
		align-items: center;
		height: 100px;
	}
}

/** 4 **/
.wraper {
	position: relative;
	.box {
		position: absolute;
		top: 0;
        bottom: 0;
		left: 0;
        right: 0;
		width: 100px;
		height: 100px;
		margin: auto;
        overflow: auto;
	}
}

/** 5 **/
.wraper {
	display: table;
	.box {
		display: table-cell;
		vertical-align: middle;
	}
}
```

### 41 margin/padding百分比值的计算

在默认的水平文档流方向下，CSS margin和padding属性的垂直方向的百分比值都是相对于**父元素宽度**计算的。

 为何这么设计呢？其实相对高度计算也没什么问题，但是如果padding相对于height计算，大多数情况下计算值都是0，跟摆设没什么区别，还不如相对宽度计算，因为CSS默认的是水平流，计算值一直会有效 。

### 42 CSS控制前端图片HTTP请求的各种情况示例

1.  **隐藏图片** 

   ```html
   <img src="haorooms.jpg" style="display: none" /> 
   ```

    结论：只有Opera不产生请求。 注意：用visibility: hidden隐藏图片时，在Opera下也会产生请求。 

2.  **重复图片** 

   ```html
   <img src="haorooms.jpg" />  
   <img src="haorooms.jpg" />  
   ```

    结论：所有浏览器都只产生一次请求 。 

3.  **重复背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg) }   
       .test2 { background: url(haorooms.jpg) }   
   </style>   
   
   <div class="test1">test1</div>   
   <div class="test2">test2</div> 
   ```

    结论：所有浏览器都只产生一次请求。 

4.  **不存在的元素的背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg) }   
       .test2 { background: url(http2.jpg) } /* 页面中没有class为test2的元素 */  
   </style>   
   
   <div class="test1">test1</div>  
   ```

    结论：背景仅在应用的元素在页面中存在时，才会产生请求。这对CSS框架来说，很有意义。 

5.  **隐藏元素的背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg); display: none; }   
       .test2 { background: url(http2.jpg); visibility: hidden; }   
   </style>   
     
   <div class="test1">test1</div> 
   ```

    结论：Opera和Firefox对于用display: none隐藏的元素背景，不会产生HTTP请求。仅当这些元素非display: none时，才会请求背景图片。 

6.  **多重背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg); }   
       .test1 { background: url(http2.jpg); }   
   </style>   
   
   <div class="test1">test1</div>  
   ```

   上面这段代码的http请求，只会请求http2.jpg这一张图片，原因是test1的class把上面的给覆盖掉了，所有只请求后面的一张图片！

   假如用css3多张背景图片的写法：

   ```html
   <style type="text/css">   
       .test1 { background-image:url("haorooms.jpg"),url("http2.jpg"); }   
   </style>   
   
   <div class="test1">test1</div>  
   ```

    webkit引擎浏览器对背景图都请求，是因为支持CSS3中的多背景图。 

7.  **hover的背景加载** 

   ```html
   <style type="text/css">   
       a.test1 { background: url(haorooms.jpg); }   
       a.test1:hover { background: url(http2.jpg); }   
   </style>   
   
   <a href="#" class="test1">test1</a>  
   ```

    结论：触发hover时，才会请求hover状态下的背景。不触发的话，只请求默认的背景图片。 

### 43 position: absolute与position:relative

**position: absolute**

- 绝对定位是以**父元素的左上角原点**为定位基准点，absolute 会将对象拖离出正常的文档流绝对定位而不考虑它周围内容的布局。
- 假如其他具有不同 z-index 属性的对象已经占据了给定的位置，他们之间不会相互影响，而会在同一位置层叠。
- 如果父级（无限）没有设定position属性，那么当前的absolute则结合TRBL属性**以浏览器左上角**为原始点进行定位；
- 如果父级（无限）设定position属性，那么当前的absolute则结合TRBL属性以**父级（最近）的左上角**为原始点进行定位。

**Tips:**

- **要激活对象的绝对(absolute)定位，必须指定 left ， right ， top ， bottom 属性中的至少一个**，并且设置此属性值为 absolute 。否则上述属性会使用他们的默认值 auto ，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递。
- **TRBL属性（TOP、RIGHT、BOTTOM、LEFT）只有当设定了position属性才有效**，position：relative也可以生效。

**position:relative**

- 相对定位是相对其初始位置进行偏移定位的，当设定position: relative 则**参照父级（最近）的内容区的左上角为原始点结合TRBL属性进行定位**（或者说相对于被定位元素在父级内容区中的上一个元素进行偏移），无父级则以BODY的左上角为原始点。
- 相对定位是不能层叠的。在使用相对定位时，**无论元素是否进行移动，元素依然占据原来的空间**（如果不好理解，下面案例说明了这一点）。因此，移动元素会导致它覆盖其他框。

**总结**

图层覆盖顺序由上到下为：**相对>绝对>默认**，初始状态（没有加top偏移时候的初始状态）的相对div在左上角覆盖绝对div的上半部分，经过top偏移后移动到下方，但是默认的那个div仍然没有自动顶上去，because相对定位的初始位置依然是被占据的。

父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。

**position的几种值**

absolute ：⽣成绝对定位的元素，相对于 static 定位以外的第⼀个⽗元素进⾏定位
fixed ：⽣成绝对定位的元素，相对于浏览器窗⼝进⾏定位
relative ：⽣成相对定位的元素，相对于其正常位置进⾏定位
static 默认值。没有定位，元素出现在正常的流中
inherit 规定从⽗元素继承 position 属性的值

## 三、JavaScript

### 1 闭包 / setTimeout

- 闭包就是**能够读取其他函数内部变量的函数**

- 闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域

  ```js
  function A() {
  	let a = 1
  	function B() {
  		console.log(a)
  	}
  	return B
  }
  //为什么函数 A 已经弹出调⽤栈了，为什么函数 B 还能引⽤到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。
  ```

- 闭包的特性：
  - 函数内再嵌套函数
  - 内部函数可以引⽤外层的参数和变量
  - 参数和变量不会被垃圾回收机制回收

对闭包的理解：

- 使⽤闭包主要是**为了设计私有的⽅法和变量**。闭包的优点是可以**避免全局变量的污染**，缺点是**闭包会常驻内存，会增⼤内存使⽤量**，使⽤不当很容易造成内存泄露。**在js中，函数即闭包，只有函数才会产⽣作⽤域的概念**
- 闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中
- 闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法
- 好处：能够实现封装和缓存等；
- 坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题

使⽤闭包的注意点：

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露
- 解决⽅法是，**在退出函数之前，将不使⽤的局部变量全部删除**

经典⾯试题，循环中使⽤闭包解决 var 定义函数的问题

```js
for ( var i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
```

⾸先因为 setTimeout 是个异步函数，所有会先把循环全部执⾏完毕，这时候 i 就是6 了，所以会输出⼀堆 6 。

```js
//解决办法两种，第⼀种使⽤闭包
for (var i = 1; i <= 5; i++) {
	(function(j) {
		setTimeout(function timer() {
		console.log(j);
		}, j * 1000);
	})(i);
}

//第⼆种就是使⽤ setTimeout 的第三个参数
for ( var i=1; i<=5; i++) {
	setTimeout( function timer(j) {
		console.log( j );
	}, i*1000, i);
}

//第三种就是使⽤ let 定义 i 了,因为对于 let 来说，他会创建⼀个块级作⽤域
for ( let i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
```

### 2 JavaScript作用域和作⽤域链

- 作⽤域链的作⽤是**保证执⾏环境⾥有权访问的变量和函数是有序的**，作⽤域链的**变量只能向上访问**，变量访问到window 对象即被终⽌，作⽤域链向下访问变量是不被允许的
- 简单的说，作⽤域就是变量与函数的可访问范围，即**作⽤域控制着变量与函数的可⻅性和⽣命周期**



1. 在JavaScript中，通过 `let` 和 `const` 定义的变量具有块级作用域的特性。
2. 通过 `var` 定义的变量会在它自身的作用域中进行提升，而 `let` 和 `const` 定义的变量不会。
3. 每个JavaScript程序都具有一个全局作用域，每创建一个函数都会创建一个作用域。
4. 在创建函数时，将这些函数进行嵌套，它们的作用域也会嵌套，形成作用域链，子作用域可以访问父作用域，但是父作用域不能访问子作用域。
5. 在执行一个函数时，如果我们需要查找某个变量值，那么会去这个函数被 **定义** 时所在的作用域链中查找，一旦找到需要的变量，就会停止向上查找。
6. “变量的**值**由函数定义时的位置决定”这句话有歧义，准确说是**查找**变量时，是去定义这个函数时所在的作用域链查找。

 其实记住2条规则，大部分作用域的面试题都可以解，**1、function 提升 优先 var 2、同名的，后面覆盖前面。** 

 ![img](/../../../../Typora图库/Web前端/作用域链.png)

### 3 JavaScript原型，原型链

- 每个对象都会在其内部初始化⼀个属性，就是prototype (原型)，当我们访问⼀个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype ⾥找这个属性，这个prototype ⼜会有⾃⼰的prototype ，于是就这样⼀直找下去，也就是我们平时所说的原型链的概念
- 关系：` instance.constructor.prototype = instance.__proto__`
- 特点：JavaScript 对象是**通过引⽤来传递的**，我们创建的每个新对象实体中并没有⼀份属于⾃⼰的原型副本。当我们修改原型时，与之相关的对象也会继承这⼀改变（复制需要深拷贝）
- 当我们需要⼀个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的Prototype 对象是否有这个属性，如此递推下去，⼀直检索到 Object 内建对象

<img src="/../../../../Typora图库/Web前端/原型.png" alt="1598172397035" style="zoom:50%;" />

- 每个函数都有 prototype 属性，除了 Function.prototype.bind() ，该属性指向原型。
- 每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]] ，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使⽤ _proto_ 来访问。
- 对象可以通过__proto__ 来寻找不属于该对象的属性， __proto__ 将对象连接起来组成了原型链

### 4 执⾏上下⽂

当执⾏ JS 代码时，会产⽣三种执⾏上下⽂

- 全局执⾏上下⽂
- 函数执⾏上下⽂
- eval 执⾏上下⽂

每个执⾏上下⽂中都有三个重要的属性

- 变量对象（ VO ），包含变量、函数声明和函数的形参，该属性只能在全局上下⽂中访问
- 作⽤域链（ JS 采⽤词法作⽤域，也就是说变量的作⽤域是在定义时就决定了）
- this

```js
var a = 10
function foo(i) {
	var b = 20
}
foo()
```

对于上述代码，执⾏栈中有两个上下⽂：全局上下⽂和函数 foo 上下⽂。

```js
stack = [
	globalContext,
	fooContext
]
```

对于全局上下⽂来说， VO ⼤概是这样的

```js
globalContext.VO === globe
globalContext.VO = {
	a: undefined,
	foo: <Function>,
}
```

对于函数 foo 来说， VO 不能访问，只能访问到活动对象（ AO ）

```js
fooContext.VO === foo.AO
fooContext.AO {
	i: undefined,
	b: undefined,
	arguments: <>
}
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是⼀个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调⽤者
```

对于作⽤域链，可以把它理解成包含⾃身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量

```js
fooContext.[[Scope]] = [
	globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
	fooContext.VO,
	globalContext.VO
]
```

接下来让我们看⼀个⽼⽣常谈的例⼦， var

```js
b() // call b
console.log(a) // undefined
var a = 'Hello world'
function b() {
	console.log('call b')
}
```

想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释应该是：在⽣成执⾏上下⽂时，会有两个阶段。第⼀个阶段是创建的阶段（具体步骤是创建 VO ）， JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以直接提前使⽤。

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```js
b() // call b second
function b() {
	console.log('call b fist')
}
function b() {
	console.log('call b second')
}
var b = 'Hello world'
```

var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。let 不能在声明前使⽤，但是这并不是常说的 let 不会提升， let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使⽤。

对于⾮匿名的⽴即执⾏函数需要注意以下⼀点

```js
var foo = 1
(function foo() {
	foo = 10
	console.log(foo)
}()) // -> ƒ foo() { foo = 10 ; console.log(foo) }
```

因为当 JS 解释器在遇到⾮匿名的⽴即执⾏函数时，会创建⼀个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到foo ，但是这个值⼜是只读的，所以对它的赋值并不⽣效，所以打印的结果还是这个函数，并且外部的值也没有发⽣更改。

```js
specialObject = {};
Scope = specialObject + Scope;
foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}
delete Scope[0]; // remove specialObject from the front of scope chain
```

### 5 Javascript如何实现继承

1. 构造继承
2. 原型继承
3. 实例继承
4. 拷⻉继承

原型prototype 机制或apply 和call ⽅法去实现较简单，建议使⽤**构造函数与原型混合⽅式**

```javascript
function Parent(){
	this.name = 'wang';
}
function Child(){
	this.age = 28;
}
Child.prototype = new Parent();//继承了Parent，通过原型
var demo = new Child();
alert(demo.age);
alert(demo.name);//得到被继承的属性
```

在 ES5 中，我们可以使⽤如下⽅式解决继承的问题

```js
function Super() {}
Super.prototype.getNumber = function() {
	return 1
}
function Sub() {}
let s = new Sub()
Sub.prototype = Object.create(Super.prototype, {
	constructor: {
		value: Sub,
		enumerable: false,
		writable: true,
		configurable: true
	}
})
```

以上继承实现思路就是将⼦类的原型设置为⽗类的原型

在 ES6 中，我们可以通过 class 语法轻松解决这个问题

```js
class MyDate extends Date {
	test() {
		return this.getTime()
	}
}
let myDate = new MyDate()
myDate.test()
```

但是 ES6 不是所有浏览器都兼容，所以我们需要使⽤ Babel 来编译这段代码。

如果你使⽤编译过得代码调⽤ myDate.test() 你会惊奇地发现出现了报错，因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调⽤ Date ⾥的函数的。所以这也侧⾯的说明了： ES6 中的 class 继承与ES5 中的⼀般继承写法是不同的。

既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承

```js
function MyData() {
}
MyData.prototype.test = function () {
	return this.getTime()
}
let d = new Date()
Object.setPrototypeOf(d, MyData.prototype)
Object.setPrototypeOf(MyData.prototype, Date.prototype)
```

以上继承实现思路：先创建⽗类实例 => 改变实例原先的 _proto__ 转⽽连接到⼦类的prototype => ⼦类的 prototype 的 __proto__ 改为⽗类的 prototype 。

通过以上⽅法实现的继承就可以完美解决 JS 底层的这个限制

### 6 This对象的理解

- this 总是指向函数的直接调⽤者（⽽⾮间接调⽤者）
- 如果有new 关键字， this 指向new 出来的那个对象
- 在事件中， this 指向触发这个事件的对象，特殊的是， IE 中的attachEvent 中的this 总是指向全局对象Window

#### this 指向有哪几种

- 1.默认绑定：全局环境中，this默认绑定到window。
- 2.隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象。
- 3.隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window。显式绑定：通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。
- 4.new绑定：如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。
  - 构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。
  - 如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。
  - 如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。

#### 改变函数内部 this 指针的指向函数（bind，apply，call的区别）

**call 和 apply 都是为了解决改变 this 的指向**。作⽤都是相同的，只是传参的⽅式不同。除了第⼀个参数外， **call 可以接收⼀个参数列表， apply 只接受⼀个参数数组**

```javascript
let a = {
	value: 1
}
function getValue(name, age) {
	console.log(name)
	console.log(age)
	console.log(this.value)
}
getValue.call(a, 'yck', '24')
getValue.apply(a, ['yck', '24'])
```

bind 的作⽤与call 和apply 相同，区别是**call 和apply 是⽴即调⽤函数，⽽bind 是返回了⼀个函数，需要调⽤的时候再执⾏。** 

⼀个简单的call 函数实现如下

```javascript
Function.prototype.myCall = function (context) {
	var context = context || window
	// 给 context 添加⼀个属性
	// getValue.call(a, 'yck', '24') => a.fn = getValue
	context.fn = this
	// 将 context 后⾯的参数取出来
	var args = [...arguments].slice(1)
	// getValue.call(a, 'yck', '24') => a.fn('yck', '24')
	var result = context.fn(...args)
	// 删除 fn
	delete context.fn
	return result
}
```

⼀个简单的apply 函数实现如下

```javascript
Function.prototype.myApply = function (context) {
	var context = context || window
	context.fn = this
	var result
	// 需要判断是否存储第⼆个参数
	// 如果存在，就将第⼆个参数展开
	if (arguments[1]) {
		result = context.fn(...arguments[1])
	} else {
		result = context.fn()
	}
	delete context.fn
	return result
}
```

⼀个简单的bind 函数实现如下

```javascript
Function.prototype.bind = function(ctx) {
	var fn = this;
	return function() {
		fn.apply(ctx, arguments);
	};
};
```

#### 箭头函数

- 1.箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着**如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this**
- 2.箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象
- 3.不可以当作构造函数，也就是说，不可以使⽤new 命令，同样也没有new.target值和原型
- 4. 不可以使⽤yield 命令，因此箭头函数不能⽤作Generator 函数

### 7  事件绑定、事件监听、事件委托（事件代理） 

**事件绑定：**

要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。

在JavaScript中，有三种常用的绑定事件的方法：

- 在DOM元素中直接绑定： 我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。 
- 在JavaScript代码中绑定： 在JavaScript代码中（即`script`标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 
- 绑定事件监听函数： 用 addEventListener() 或 attachEvent() 来绑定事件监听函数。 

**事件监听：**

-  element.addEventListener(event, function, useCapture) 
    -  event : （必需）事件名，支持所有[DOM事件](http://www.runoob.com/jsref/dom-obj-event.html)。
      function：（必需）指定要事件触发时执行的函数。
      useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 
  
-  element.attachEvent(event, function) 
  -  event：（必需）事件类型。需加“on“，例如：onclick。
  - function：（必需）指定要事件触发时执行的函数。 
  
-  优点：

    -   可以绑定多个事件。  常规的事件绑定只执行最后绑定的事件。 

    -   可以解除相应的绑定 （ removeEventListener ）

    -  封装事件监听

        ```js
        
        //绑定监听事件
        function addEventHandler(target,type,fn){
        	if(target.addEventListener){
        		target.addEventListener(type,fn);
        	}else{
        		target.attachEvent("on"+type,fn);
        	}
        }
        //移除监听事件
        function removeEventHandler(target,type,fn){
        	if(target.removeEventListener){
        		target.removeEventListener(type,fn);
        	}else{
        		target.detachEvent("on"+type,fn);
        	}
        }
        //测试
        var btn5 = document.getElementById("btn5");
        addEventHandler(btn5,"click",hello1);//添加事件hello1
        addEventHandler(btn5,"click",hello2);//添加事件hello2
        removeEventHandler(btn5,"click",hello1);//移除事件hello1
        ```

**事件委托：**

- 事件代理（ Event Delegation ），⼜称之为事件委托。是 JavaScript 中常⽤绑定事件的常⽤技巧。 事件委托就是**利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果**。 

- 事件代理的**原理是DOM元素的事件冒泡**。

  ```js
  <input type="button" value="click me" id="btn6">
  var btn6 = document.getElementById("btn6");
  document.onclick = function(event){
  	event = event || window.event;
  	var target = event.target || event.srcElement;
  	if(target == btn6){
  		alert(btn5.value);
  	}
  }
  ```

- 使⽤事件代理的好处是可以提⾼性能，可以⼤量节省内存占⽤，减少事件注册，⽐如在table 上代理所有td 的click 事件就⾮常棒

  ````js
  var item1 = document.getElementById("item1");
  var item2 = document.getElementById("item2");
  var item3 = document.getElementById("item3");
  document.addEventListener("click",function(event){
  	var target = event.target;
  	if(target == item1){
  		alert("hello item1");
  	}else if(target == item2){
  		alert("hello item2");
  	}else if(target == item3){
  		alert("hello item3");
  	}
  })
  ````

-  动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。 

  ```js
  //传统写法，点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。
  <ul id="list">
    <li id="item1" >item1</li>
    <li id="item2" >item2</li>
    <li id="item3" >item3</li>
  </ul>
  <script>
  var list = document.getElementById("list");
  var item = list.getElementsByTagName("li");
  for(var i=0;i<item.length;i++){
  	(function(i){
  		item[i].onclick = function(){
  			alert(item[i].innerHTML);
  		}
  	})(i)
  }
  var node=document.createElement("li");
  var textnode=document.createTextNode("item4");
  node.appendChild(textnode);
  list.appendChild(node);
  </script>
  
  //当点击item4时，item4有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件。
  <ul id="list">
    <li id="item1" >item1</li>
    <li id="item2" >item2</li>
    <li id="item3" >item3</li>
  </ul>
  <script>
  var list = document.getElementById("list");
  document.addEventListener("click",function(event){
  	var target = event.target;
  	if(target.nodeName == "LI"){
  		alert(target.innerHTML);
  	}
  })
  var node=document.createElement("li");
  var textnode=document.createTextNode("item4");
  node.appendChild(textnode);
  list.appendChild(node);
  </script>
  ```

### 8 new操作符具体⼲了什么呢?

- 创建⼀个空对象，并且 this 变量引⽤该对象，同时还继承了该函数的原型
- 属性和⽅法被加⼊到 this 引⽤的对象中
- 新创建的对象由 this 所引⽤，并且最后隐式的返回 this

```js
function create() {
	// 创建⼀个空的对象
	let obj = new Object()
	// 获得构造函数
	let Con = [].shift.call(arguments)
	// 链接到原型
	obj.__proto__ = Con.prototype
	// 绑定 this，执⾏构造函数
	let result = Con.apply(obj, arguments)
	// 确保 new 出来的是个对象
	return typeof result === 'object' ? result : obj
}
```

### 9 Ajax原理

- Ajax 的原理简单来说是**在⽤户和服务器之间加了—个中间层( AJAX 引擎)**，通过XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后⽤javascript来操作DOM ⽽更新⻚⾯。使⽤户操作与服务器响应异步化。这其中最关键的⼀步就是**从服务器获得请求数据**
- Ajax 的过程只涉及JavaScript 、XMLHttpRequest 和DOM 。**XMLHttpRequest 是Ajax的核⼼机制**

```javascript
/** 1. 创建连接 **/
var xhr = null;
xhr = new XMLHttpRequest()
/** 2. 连接服务器 **/
xhr.open('get', url, true)
/** 3. 发送请求 **/
xhr.send(null);
/** 4. 接受请求 **/
xhr.onreadystatechange = function(){
	if(xhr.readyState == 4){
		if(xhr.status == 200){
			success(xhr.responseText);
		} else {
		/** false **/
		fail && fail(xhr.status);
		}
	}
}
```

ajax 有那些优缺点?

- 优点：
  - 通过异步模式，提升了⽤户体验.
  - 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占⽤.
  - Ajax 在客户端运⾏，承担了⼀部分本来由服务器承担的⼯作，减少了⼤⽤户量下的服务器负载。
  - Ajax 可以实现动态不刷新（局部刷新）
- 缺点：
  - 安全问题 AJAX 暴露了与服务器交互的细节。
  - 对搜索引擎的⽀持⽐较弱。
  - 不容易调试。

**Ajax状态**

1. 未初始化。尚未调用 open()方法。
2. 启动。已经调用 open()方法，但尚未调用 send()方法。
3. 发送。已经调用 send()方法，但尚未接收到响应。
4. 接收。已经接收到部分响应数据。
5. 完成。已经接收到全部响应数据，而且已经可以在客户端使用了。

### 10 同源限制，解决跨域问题

⾸先了解下浏览器的同源策略。 **同源策略/SOP（Same origin policy）** 是⼀种约定，由Netscape公司1995年引⼊浏览器，**它是浏览器最核⼼也最基本的安全功能**，如果缺少了同源策略，浏览器很容易受到XSS 、CSFR 等攻击。所谓**同源是指"协议+域名+端⼝"三者相同**，即便两个不同的域名指向同⼀个ip地址，也⾮同源

同源策略是⼀种安全协议。举例说明：⽐如⼀个⿊客程序，他利⽤Iframe 把真正的银⾏登录⻚⾯嵌到他的⻚⾯上，当你使⽤真实的⽤户名，密码登录时，他的⻚⾯就可以通过Javascript 读取到你的表单中input 中的内容，这样⽤户名，密码就轻松到⼿了。

**那么怎样解决跨域问题的呢？**

- 通过**jsonp**跨域： 通过动态创建script标签，其src指向非同源的url，并传递一个callback参数给服务端，服务器返回一个以callback参数作为函数名的函数的调用和一系列参数，页面接收到响应后执行回调并对数据进行处理。 

  ```javascript
  var script = document.createElement('script');
  script.type = 'text/javascript';
  // 传参并指定回调执⾏函数为onBack
  script.src = 'http://www.....:8080/login?user=admin&callback=onBack';
  document.head.appendChild(script);
  // 回调执⾏函数
  function onBack(res) {
  	alert(JSON.stringify(res));
  }
  ```

- document.domain + iframe跨域：此⽅案仅限**主域相同，⼦域不同**的跨域应⽤场景

  ```javascript
  //⽗窗⼝：(http://www.domain.com/a.html)
  <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
  <script>
  	document.domain = 'domain.com';
  	var user = 'admin';
  </script>
  
  //⼦窗⼝：(http://child.domain.com/b.html)
  document.domain = 'domain.com';
  // 获取⽗窗⼝中变量
  alert('get js data from parent ---> ' + window.parent.user);
  ```

- nginx代理跨域

- nodejs中间件代理跨域

- 后端在头部信息⾥⾯设置安全域名

#### JSONP的优点与缺点

优点

- JSONP可以跨越同源策略，实现跨域传输，不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制
- JSONP兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持
- 在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方

缺点

- 它只支持GET请求而不支持POST等其它类型的HTTP请求，因为script标签的scr只能进行GET请求
- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
- jsonp在调用失败的时候不会返回各种HTTP状态码。
- 缺乏安全性。假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的,那么所有调用这个jsonp的网站都会存在漏洞,这样的话危险就不止在一个域名下。

### 11 模块化开发怎么做？

- ⽴即执⾏函数,不暴露私有成员

  ```javascript
  var module1 = (function(){
  	var _count = 0;
  	var m1 = function(){
  		//...
  	};
  	var m2 = function(){
  		//...
  	};
  	return {
  		m1 : m1,
  		m2 : m2
  	};
  })();
  ```

### 12 异步加载JS的⽅式

- **方案一、$(document).ready()**

  > 需要引入jquery
  >  兼容所有浏览器

  ```jsx
  $(document).ready(function() {
  alert("加载完成！");
   });
  ```

  **方案二、标签的async="async"属性**

  > 1.async属性是HTML5新增属性，需要Chrome、FireFox、IE9+浏览器支持
  >  2.async属性规定一旦脚本可用，则会异步执行
  >  3.async属性仅适用于外部脚本
  >  4.此方法不能保证脚本按顺序执行

  ```xml
  <script type="text/javascript" src="xxx.js" async="async"></script>
  ```

  **方案三、标签的defer="defer"属性**

  > 1.defer属性规定是否对脚本执行进行延迟，直到页面加载为止
  >  2.如果脚本不会改变文档的内容，可将defer属性加入到<script>标签中，以便加快处理文档的速度
  >  3.**兼容所有浏览器**
  >  4.此方法可以确保所有**设置了defer属性的脚本按顺序执行**

  **方案四、动态创建标签**

  > **兼容所有浏览器**

  ```jsx
  (function(){
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = "http://code.jquery.com/jquery-1.7.2.min.js";
      var tmp = document.getElementsByTagName('script')[0];
      tmp.parentNode.insertBefore(script, tmp);
  })();
  ```

### 13 哪些操作会造成内存泄漏？

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在

- setTimeout 的第⼀个参数使⽤字符串⽽⾮函数的话，会引发内存泄漏
- 闭包使⽤不当
- 控制台⽇志
- 循环（在两个对象彼此引⽤且彼此保留时，就会产⽣⼀个循环）

### 14 JSON 的了解，XML和JSON的区别？

JSON(JavaScript Object Notation) 是⼀种轻量级的数据交换格式。它是基于JavaScript 的⼀个⼦集。数据格式简单, 易于读写, 占⽤带宽⼩

在 JavaScript 中，预先提供了 `JSON.parse` 函数，它接受一个 JSON 字符串作为参数，并返回这个 JSON 字符串解释得到的结果。

由于 JSON 的解释速度比 JavaScript 代码快很多，并且 `JSON.parse` 作为内置函数，JSON 字符串会交由 JavaScript 解释器内部的 C/C++ 代码进行解释，并直接跳过 JavaScript 语法解释器部分，直接在解释器内部生成并返回 JavaScript 对象的引用。

在这个过程中，**JavaScript 解释器只需要解释到 `JSON.parse('`，即可得知后面是一个字符串，并一路向后寻找字符串的结尾，这之间不会有复杂的语法（反引号 字符串中包含的 `${}` 除外），最多就只有转义字符 `\` 的转义。随后就会将解释所得到的字符串交给 `JSON.parse` 函数进行处理了**。

因此，这个过程会比直接去解释一个 JavaScript 对象快得多

- JSON 字符串转换为JSON对象:
    ```javascript
    var obj = eval('('+ str +')');
    var obj = str.parseJSON();
    var obj = JSON.parse(str);
    ```

- JSON 对象转换为JSON字符串：

  ```javascript
  var last = obj.toJSONString();
  var last = JSON.stringify(obj);
  ```

XML和JSON的区别:
- 数据体积⽅⾯：JSON 相对于XML 来讲，数据的体积⼩，传递的速度更快些。

- 数据交互⽅⾯：JSON 与JavaScript 的交互更加⽅便，更容易解析处理，更好的数据交互

- 数据描述⽅⾯：JSON 对数据的描述性⽐XML 较差

- 传输速度⽅⾯：JSON 的速度要远远快于XML

### 15 async、await 优缺点

async 和 await 相⽐直接使⽤ Promise 来说，优势在于处理 then 的调⽤链，能够更清晰准确的写出代码。缺点在于滥⽤ await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性

```javascript
var a = 0
var b = async () => {
	a = a + await 10
	console.log('2', a) // -> '2' 10
	a = (await 10) + a
	console.log('3', a) // -> '3' 20
}
b()
a++
console.log('1', a) // -> '1' 1
```

- ⾸先函数b 先执⾏，在执⾏到 await 10 之前变量 a 还是 0 ，因为在 await 内部实现了 generators ， generators 会保留堆栈中东⻄，所以这时候 a = 0 被保存了下来
- 因为 await 是异步操作，**遇到await 就会⽴即返回⼀个pending 状态的Promise 对象，暂时返回执⾏代码的控制权，使得函数外的代码得以继续执⾏**，所以会先执⾏console.log('1', a)
- 这时候**同步代码执⾏完毕，开始执⾏异步代码**，将保存下来的值拿出来使⽤，这时候 a =10
- 然后后⾯就是常规执⾏代码了

### 16 CommonJS、AMD、CMD规范及其优缺点

***nodejs遵循了CommonJS规范***
CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。
根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。
CommonJS的核心思想就是通过 **require** 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。
**优点：**
CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。
**缺点：**
由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的

***require.js遵循了AMD规范***
AMD规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。
**优点：**
适合在浏览器环境中异步加载模块。可以并行加载多个模块。
**缺点：**
提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。

***seajs遵循了CMD规范***
CMD规范与AMD规范很类似，实现库为seajs，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的
**优点：**
同样实现了浏览器端的模块化加载，可以按需加载，依赖就近。
**缺点：**
依赖SPM打包，模块的加载逻辑偏重。
AMD和CMD的区别：
前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。

#### 模块化(CommonJS 和 ES6 ,AMD)

在有 Babel 的情况下，我们可以直接使⽤ ES6 的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}
import {a, b} from './a.js'
import XXX from './b.js'
```

**CommonJS**

CommonJs 是 Node 独有的规范，浏览器中使⽤就需要⽤到 Browserify解析了。

```js
// a.js
module.exports = {
	a: 1
}
// or
exports.a = 1
// b.js
var module = require('./a.js')
module.a // -> log 1
```

在上述代码中， module.exports 和 exports 很容易混淆，让我们来看看⼤致内部实现

```js
var module = require('./a.js')
module.a
// 这⾥其实就是包装了⼀层⽴即执⾏函数，这样就不会污染全局变量了，
// 重要的是 module 这⾥，module 是 Node 独有的⼀个变量
module.exports = {
	a: 1
}
// 基本实现
var module = {
exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports ⽤法相似的原因
var exports = module.exports
var load = function (module) {
	// 导出的东⻄
	var a = 1
	module.exports = a
	return module.exports
};
```

module.exports 和exports ，⽤法其实是相似的，但是不能对exports 直接赋值，不会有任何效果。

对于 CommonJS 和 ES6 中的模块化的两者区别是：

- **前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持**，但是已有提案,前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤。
- ⽽**后者是异步导⼊**，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很⼤影响
- **前者在导出时都是值拷⻉**，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次。
- 但是**后者采⽤实时绑定的⽅式**，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化
- **后者会编译成 require/exports 来执⾏的**

AMD 是由 RequireJS 提出的

```js
// AMD
define(['./a', './b'], function(a, b) {
	a.do()
	b.do()
})
define(function(require, exports, module) {
	var a = require('./a')
	a.doSomething()
	var b = require('./b')
	b.doSomething()
})
```



### 17 常⻅web安全及防护原理

- sql 注⼊原理：通过把SQL 命令插⼊到Web 表单递交或输⼊域名或⻚⾯请求的查询字符串，最终达到欺骗服务器执⾏恶意的SQL命令
- 总的来说有以下⼏点
  - 永远不要信任⽤户的输⼊，**要对⽤户的输⼊进⾏校验**，可以通过正则表达式，或限制⻓度，对单引号和双"-" 进⾏转换等
  - 永远不要使⽤动态拼装SQL，可以使⽤参数化的SQL 或者直接使⽤存储过程进⾏数据查询存取
  - 永远不要使⽤管理员权限的数据库连接，为每个应⽤使⽤单独的权限有限的数据库连接
  - 不要把机密信息明⽂存放，请**加密或者hash 掉密码和敏感的信息**

### 18 XSS和CSRF

- XSS原理及防范

  Xss(cross-site scripting) 攻击指的是**攻击者往Web ⻚⾯⾥插⼊恶意html 标签或者javascript 代码**。⽐如：攻击者在论坛中放⼀个看似安全的链接，骗取⽤户点击后，窃取cookie 中的⽤户私密信息；或者攻击者在论坛中加⼀个恶意表单，当⽤户提交表单的时候，却把信息传送到攻击者的服务器中，⽽不是⽤户原本以为的信任站点

- XSS防范⽅法

  ⾸先代码⾥对⽤户输⼊的地⽅和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’” 等字符做过滤；其次任何内容写到⻚⾯之前都必须加以encode，避免不⼩⼼把html tag 弄出来。这⼀个层⾯做好，⾄少可以堵住超过⼀半的XSS 攻击

- CSRF

  跨站请求伪造（英语： Cross-site request forgery ），也被称为 oneclickattack 或者 session riding ，通常缩写为 CSRF 或者 XSRF ，是⼀种挟制⽤户在当前已登录的Web 应⽤程序上执⾏⾮本意的操作的攻击⽅。CSRF 就是利⽤⽤户的登录态发起恶意请求。假设⽹站中有⼀个通过 Get 请求提交⽤户评论的接⼝，那么攻击者就可以在钓⻥⽹站中加⼊⼀个图⽚，图⽚的地址就是评论接⼝

- CSRF的防御

  - Get 请求不对数据进⾏修改
  - 不让第三⽅⽹站访问到⽤户 Cookie
  - 阻⽌第三⽅⽹站请求接⼝
  - 服务端的CSRF ⽅式⽅法很多样，但总的思想都是⼀致的，就是**在客户端⻚⾯增加伪随机数**
  - 请求时附带验证信息，⽐如**验证码或者 token**

- XSS与CSRF有什么区别吗？

  **XSS 是获取信息**，不需要提前知道其他⽤户⻚⾯的代码和数据包。**CSRF 是代替⽤户完成指定的动作**，需要知道其他⽤户⻚⾯的代码和数据包。

  要完成⼀次CSRF 攻击，受害者必须依次完成两个步骤

  - 登录受信任⽹站A ，并在本地⽣成Cookie
  - 在不登出A 的情况下，访问危险⽹站B


### 19 ⽤过哪些设计模式？

- ⼯⼚模式：
  ⼯⼚模式解决了重复实例化的问题，但还有⼀个问题,那就是识别问题，因为根本⽆法主要好处就是可以消除对象间的耦合，通过使⽤⼯程⽅法⽽不是new 关键字
- 构造函数模式
  使⽤构造函数的⽅法，即解决了重复实例化的问题，⼜解决了对象识别的问题，该模式与⼯⼚模式的不同之处在于直接将属性和⽅法赋值给 this 对象;

### 20  offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别

- offsetWidth/offsetHeight 返回值包含content + padding + border，效果与e.getBoundingClientRect()相同，只读属性
- clientWidth/clientHeight 返回值只包含content + padding，如果有滚动条，也不包含滚动条，只读属性
- scrollWidth/scrollHeight 返回值包含content + padding + 溢出内容的尺⼨，可读写属性

### 21 javascript有哪些⽅法创建对象

javascript 创建对象简单的说,⽆⾮就是使⽤内置对象或各种⾃定义对象，当然还可以⽤JSON ；但写法有很多种，也能混合使⽤

- 对象字⾯量的⽅式

  ```javascript
  person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
  ```

- ⽤function 来模拟构造函数

  ```javascript
  //模拟⽆参的构造函数
  function Person(){}
  	var person=new Person();//定义⼀个function
  	person.name="Mark";
  	person.age="25";
  	person.work=function(){
  	alert(person.name+" hello...");
  }
  person.work();
  
  //模拟有参构造函数来实现（⽤this 关键字定义构造的上下⽂属性）
  function Pet(name,age,hobby){
  	this.name=name;//this作⽤域：当前对象
  	this.age=age;
  	this.hobby=hobby;
  	this.eat=function(){
  	alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
  	}
  }
  var maidou =new Pet("⻨兜",25,"coding");//实例化、创建对象
  maidou.eat();//调⽤eat⽅法
  ```

  - 寄生构造函数模式

    ```javascript
    function Person(name) {
      var o = new Object()
      o.name = name
      o.say = function() {
        alert(this.name)
      }
      return o
    }
    var peron1 = new Person('hanmeimei')
    ```

  - 稳妥构造模式

    ```javascript
    function Person(name) {
      var o = new Object()
      o.say = function() {
        alert(name)
      }
    }
    var person1 = new Person('hanmeimei');
    person1.name  // undefined
    person1.say() //hanmeimei
    ```

    

- ⽤⼯⼚⽅式来创建（内置对象）

  ```javascript
  function Person() {
    var o = new Object();
    o.name = 'hanmeimei';
    o.say = function() {
      alert(this.name);
    }
    return o;
  }
  var person1 = Person();
  ```
  
- ⽤原型⽅式来创建

  ```javascript
  function Dog(){}
  	Dog.prototype.name="旺财";
  	Dog.prototype.eat=function(){
  	alert(this.name+"是个吃货");
  }
  var wangcai =new Dog();
  wangcai.eat();
  ```

  - 动态原型模式

    ```javascript
    function Person(name) {
      this.name = name
      if(typeof this.say != 'function') {
        Person.prototype.say = function(
        alert(this.name)
      }
    }
    ```

    

- ⽤混合⽅式来创建

  ```javascript
  function Car(name,price){
  	this.name=name;
  	this.price=price;
  }
  Car.prototype.sell=function(){
  	alert("我是"+this.name+"，我现在卖"+this.price+"万元");
  }
  var camry =new Car("凯美瑞",27);
  camry.sell();
  ```

  
### 22 常⻅兼容性问题

- png24 位的图⽚在iE6浏览器上出现背景，解决⽅案是做成PNG8

- 浏览器默认的margin 和padding 不同。解决⽅案是加⼀个全局的`*{margin:0;padding:0;}` 来统⼀，但是全局效率很低，⼀般是如下这样解决：

  ```json
  body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{
  margin:0;
  padding:0;
  }
  ```

- IE 下, event 对象有x , y 属性,但是没有pageX , pageY 属性

- Firefox 下, event 对象有pageX , pageY 属性,但是没有x,y 属性.

### 23 generator 原理(yield)

Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来**异步编程**

```javascript
// 使⽤ * 表示这是⼀个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调⽤ next 恢复执⾏
function* test() {
	let a = 1 + 2;
	yield 2;
	yield 3;
}
let b = test();
console.log(b.next()); // > { value: 2, done: false }
console.log(b.next()); // > { value: 3, done: false }
console.log(b.next()); // > { value: undefined, done: true }
```

从以上代码可以发现，**加上 * 的函数执⾏后拥有了 next 函数**，也就是说函数执⾏后返回了⼀个对象。**每次调⽤ next 函数可以继续执⾏被暂停的代码**。

对于Generator函数，可以将它**理解为一个状态机，封装了多个内部状态；此外它还是一个遍历器生成函数**，这个函数可以遍历出状态机的所有状态。

函数特征：关键字function与函数名之间有*，函数体内部yeild关键字。

**生成器函数与普通函数的区别**：函数调用后不执行，而是返回一个指针对象（遍历器对象）。调用对象的next()方法，执行一段yield逻辑。故函数的分段执行的，**yield是暂停执行的标志，next()可以恢复执行**。

**yield与return的区别**：**yield有记忆功能**，return没有；一个函数可以多次执行yeild，但只会return一次

可以将生成器函数赋值给对象的Symbol.iterator属性，使得对象可遍历。生成器函数实现了可以在函数运行的不同阶段从外部注入不同的值，从而调整函数的行为。Generator函数是ES6对协程的实现（不完全实现）。可以将生成器函数作为异步任务的容器，所有需要异步操作的地方都用yeild来标明。此外，**生成器函数具有如下特性：函数内外的参数交换（next函数又可以输入参数又可以返回值）和错误处理机制（函数体可以捕获函数体外抛出的错误）**。Generator需要Thunk函数来执行、进行流程管理。

生成器函数的应用：1.异步操作的同步化表达；2.控制流管理；3.部署iterator结口；4.作为数据结构

### 24 你觉得jQuery源码有哪些写的好的地⽅

- jquery 源码**封装在⼀个匿名函数的⾃执⾏环境中，有助于防⽌变量的全局污染**，然后通过传⼊window 对象参数，可以**使window 对象作为局部变量使⽤**，好处是当jquery 中访问window 对象的时候，就不⽤将作⽤域链退回到顶层作⽤域了，从⽽可以更快的访问window对象。同样，传⼊undefined 参数，可以缩短查找undefined 时的作⽤域链
- jquery 将⼀些原型属性和⽅法封装在了jquery.prototype 中，为了缩短名称，⼜赋值给了jquery.fn ，这是很形象的写法
- 有⼀些数组或对象的⽅法经常能使⽤到， jQuery 将其保存为局部变量以提⾼访问速度jquery 实现的链式调⽤可以节约代码，所返回的都是同⼀个对象，可以提⾼代码效率

### 25 类型转换

**转Boolean**
在条件判断时，除了 undefined ， null ， false ， NaN ， '' ，0 ， -0 ，其他所有值都转为 true ，包括所有对象

**对象转基本类型**
对象在转换基本类型时，⾸先会调⽤ valueOf 然后调⽤ toString 。并且这两个⽅法你是可以重写的

**四则运算符**

只有当加法运算时，其中⼀⽅是字符串类型，就会把另⼀个也转为字符串类型。其他运算只要其中⼀⽅是数字，那么另⼀⽅就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串

```javascript
1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'
```

对于加号需要注意这个表达式 'a' + + 'b'

```js
'a' + + 'b' // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在⼀些代码中看到过 + '1' -> 1
```

**== 操作符**

这⾥来解析⼀道题⽬ [] == ![] // -> true ，下⾯是这个表达式为何为true 的步骤

```js
// [] 转成 true，然后取反变成 false
[] == false
// 根据第 8 条得出
[] == ToNumber(false)
[] == 0
// 根据第 10 条得出
ToPrimitive([]) == 0
// [].toString() -> ''
'' == 0
// 根据第 6 条得出
0 == 0 // -> true
```

**⽐较运算符**

如果是对象，就通过 toPrimitive 转换对象
如果是字符串，就通过 unicode 字符索引来⽐较

### 26 JavaScript数组

 数据就是原型链中有 `Array.prototype` 的对象 。 数组的索引可以不是连续的，访问 `index` 不存在的元素的时候返回 `undefined` 。

API：

 `splice` 方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。 

```js
//删除 splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素
var a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(4, 2) // ["e", "f"]
a // ["a", "b", "c", "d"]

a.splice(4, 2, 1, 2) // ["e", "f"]
a // ["a", "b", "c", "d", 1, 2]

//如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0
var a = [1, 1, 1];
a.splice(1, 0, 2) // []
a // [1, 2, 1, 1]
```

 `slice` 方法用于提取目标数组的一部分，返回一个**新数组**，原数组不变。  第一个参数代表开始位置,第二个参数代表结束位置的下一个位置,截取出来的字符串的长度为第二个参数与第一个参数之间的差;若参数值为负数,则将该值加上字符串长度后转为正值;若第一个参数等于大于第二个参数,则返回空字符串. 

```js
var a = [1,2,3,4,5];
a.slice(1,2);//2 从 a 下标为1开始，到下标为2结束(不包括2)，做为新数组，原数组不变
```

`substring` 第一个参数代表开始位置,第二个参数代表结束位置的下一个位置;若参数值为负数,则将该值转为0;两个参数中,取较小值作为开始位置,截取出来的字符串的长度为较大值与较小值之间的差. 

` substr() `第一个参数代表开始位置,第二个参数代表截取的长度

 `reverse` 方法用于将数组逆序，与之前不同的是它会修改原数组 

```js
var a = [1,2,3,4,5];
a.reverse();
console.log(a); //[5, 4, 3, 2, 1]
```

 `join` 方法是把数组元素（对象调用其 `toString()` 方法）使用参数作为连接符连接成一字符串，不会修改原数组内容。如果不提供参数，默认用逗号分隔。 

```js
var a = [1, 2, 3];

a.join(' ') // '1 2 3'
a.join(' . ') // "1 . 2 . 3"
a.join() // "1,2,3"
```

 `concat` 方法用于拼接数组，`a.concat(b)` 返回一个 a 和 b 共同组成的新数组，同样不会修改任何一个原始数组，也不会递归连接数组内部数组。 

```js
var a = [1,2,3,4,5]; 
var b = [6,7,8,9]; 
console.log(a.concat(b));    //[1, 2, 3, 4, 5, 6, 7, 8, 9] 
console.log(a);     //[1, 2, 3, 4, 5] 
console.log(b);     //[6, 7, 8, 9]
```

 `forEach` 方法对数组的所有成员依次执行参数函数，该函数接受三个参数：`value`、`key`、整个数组。 

```js
var a = ['a', 'b', 'c'];
a.forEach(function(q, w, e){
    console.log(q, w, e)
})

// a 0 (3) ["a", "b", "c"]
// b 1 (3) ["a", "b", "c"]
// c 2 (3) ["a", "b", "c"]
```

 `sort` 方法对数组成员进行排序，默认是按照转换为的字符串的诸个字符的 Unicode 位点进行排序。排序后，原数组将被改变。 

```js
[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

//想让sort方法按照自定义方式排序，可以传入一个函数作为参数。sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。
var items = [
    { name: 'Edward', value: 37},
    { name: 'Sharpe', value: 24},
    { name: 'And', value: 45 }
];
items.sort(function (a, b) {
    return (a.value - b.value)
});

// {name: "Sharpe", value: 24}
// {name: "Edward", value: 37}
// {name: "And", value: 45}
```

 `map` 方法对数组中每一元素进行处理，函数返回值组成一个新数组返回，新数组索引结构和原数组一致，原数组保持不变。 

```js
var arr = [1, 2, 3, 4, 5, 6]
arr.map(function(val){
     return val*val

// [1, 4, 9, 16, 25, 36]
```

 `filter` 方法用于过滤数组成员，接受一个函数，所有数组成员依次执行该函数，返回结果为 `true` 的成员组成一个新数组返回。 

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr.filter(function (val) {
  return (val > 5);
})
// [6, 7, 8, 9]
```

 `reduce` 方法依次处理数组的每个成员，两元素（或参数）执行操作，数组元素返回组合成一个值，遍历数组，继续和数组中 其他元素组合，最终得出结果。 

```js
var arr = [1, 2, 3, 4, 5]
arr.reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 15

//map 可以用 reduce 表示
var a = [1, 2, 3]
a.reduce(function(arr, n){
    arr.push(n * 2)
    return arr
}, [])

// [2, 4, 6]

//filter 可以用 reduce表示
var a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a.reduce(function(arr, n){    if(n % 2 === 0){
        arr.push(n)
    }
    return arr
}, [])

// [2, 4, 6, 8, 10]
```



### 27 js的基本数据类型，js有哪些内置对象，js有⼏种类型的值，如何判断对象类型

 ![img](/../../../../Typora图库/Web前端/js对象分类.png) 

- 基本数据类型：Undefined 、Null 、Boolean 、Number 、String
- 内置对象：
  - Object 是 JavaScript 中所有对象的⽗对象
  - 数据封装类对象： Object 、Array 、Boolean 、Number 和 String
  - 其他对象： Function 、Arguments 、Math 、Date 、RegExp 、Error
- 类型
  - 栈：原始数据类型（ Undefined ， Null ， Boolean ， Number 、String ）
  - 堆：引⽤数据类型（对象、数组和函数）
  - 两种类型的区别是：存储位置不同；
  - 原始数据类型直接存储在栈( stack )中的简单数据段，占据空间⼩、⼤⼩固定，属于被频繁使⽤数据，所以放⼊栈中存储；
  - 引⽤数据类型存储在堆( heap )中的对象,占据空间⼤、⼤⼩不固定,如果存储在栈中，将会影响程序运⾏的性能；引⽤数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引⽤值时，会⾸先检索其在栈中的地址，取得地址后从堆中获得实体
- 判断
  - 可以通过 Object.prototype.toString.call(xx) 。这样我们就可以获得类似 [objectType] 的字符串。
  - instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype

### 28 JavaScript的基本规范

- 不要在同⼀⾏声明多个变量
- 请使⽤===/!== 来⽐较true/false 或者数值
- 使⽤对象字⾯量替代new Array 这种形式
- 不要使⽤全局函数
- Switch 语句必须带有default 分⽀
- If 语句必须使⽤⼤括号
- for-in 循环中的变量 应该使⽤var 关键字明确限定作⽤域，从⽽避免作⽤域污

### 29 eval是做什么的

它的功能是把**对应的字符串解析成JS 代码并运⾏**
应该**避免使⽤eval ，不安全，⾮常耗性能**（ 2 次，⼀次解析成js 语句，⼀次执⾏）
由JSON 字符串转换为JSON对象的时候可以⽤eval，`var obj =eval('('+ str +')')`

### 30 null，undefined 的区别

- undefined 表示不存在这个值。
  undefined :是⼀个表示"⽆"的原始值或者说表示"缺少值"，就是此处应该有⼀个值，但是还没有定义。当尝试读取时会返回 undefined
  例如变量被声明了，但没有赋值时，就等于undefined
- null 表示⼀个对象被定义了，值为“空值”
  null : 是⼀个对象(空对象, 没有任何属性和⽅法)
  例如作为函数的参数，表示该函数的参数不是对象；
  在验证null 时，⼀定要使⽤ === ，因为 == ⽆法分别null 和 undefined

### 31 两个等号 == 和 三个等号 === 的区别

(1)  "=="叫做相等运算符，"==="叫做严格运算符。

(2) ==，equality -> 等同 的意思， 两边值类型不同的时候，要先进行类型转换为同一类型后，再比较值是否相等。 

===，identity -> 恒等 的意思，不做类型转换，类型不同的结果一定不等。 

(3) "=="表示只要值相等即可为真，而"==="则要求不仅值相等，而且也要求类型相同。

### 32 "use strict"：严格模式

use strict 是⼀种ECMAscript 5 添加的（严格）运⾏模式,这种模式使得 Javascript在更严格的条件下运⾏,使JS 编码更加规范化的模式,消除Javascript 语法的⼀些不合理、不严谨之处，减少⼀些怪异⾏为

严格模式的限制：

- 变量必须声明后再使⽤
- 函数的参数不能有同名属性，否则报错
- 不能使⽤with 语句
- 禁⽌this 指向全局对象

### 33 JS单线程和异步

 **常说的单线程其实指的是主线程**。JavaScript引擎负责解析，执行JavaScript代码，但它并不能单独运行，它需要一个宿主环境，熟知的宿主环境有**“浏览器”和“Node.js”**, 单线程是宿主环境没有给 JavaScript 执行过程中创建新线程的能力导致的，也称之为“主线程”。也就意味着我们（开发者）写的所有代码，都在 这一条主线程中执行。从这一点可以得出结论 JavaScript 是阻塞的：只要有一个地方发生阻塞，就会导致整个应用瘫痪。 

JavaScript 采用异步编程原因有两点，

- 一是 JavaScript 是单线程；
- 二是为了提高 CPU 的利用率。

 主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。 

 工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现喃？答案就是就是消息队列与事件循环。  工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。 

- 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。
- 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。

### 34 事件模型，事件流

**事件模型**

W3C 中定义事件的发⽣经历三个阶段：**捕获阶段（ capturing ）、⽬标阶段（ targetin ）、冒泡阶段（ bubbling ）**

- 冒泡型事件：当你使⽤**事件冒泡时，⼦级元素先触发，⽗级元素后触发**
- 捕获型事件：当你使⽤**事件捕获时，⽗级元素先触发，⼦级元素后触发**
- DOM 事件流：**同时⽀持两种事件模型：捕获型事件和冒泡型事件**
- 阻⽌冒泡：在W3c 中，使⽤stopPropagation() ⽅法；在IE下设置cancelBubble =true
- 阻⽌捕获：阻⽌事件的默认⾏为，例如`click - <a>` 后的跳转。在W3c 中，使⽤preventDefault() ⽅法，在IE 下设置window.event.returnValue = false

由此， addEventListener 的第三个参数设置为true 和false 的区别已经⾮常清晰了

- true 表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件
- false 表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件

**事件流**

事件流分为两种，**捕获事件流**和**冒泡事件流**

- 捕获事件流从根节点开始执⾏，⼀直往⼦节点查找执⾏，直到查找执⾏到⽬标节点
- 冒泡事件流从⽬标节点开始执⾏，⼀直往⽗节点冒泡查找执⾏，直到查到到根节点

事件流分为三个阶段，⼀个是**捕获节点**，⼀个是**处于⽬标节点阶段**，⼀个是**冒泡阶段**

### 35 语句和表达式

 JavaScript区分表达式和语句。

- 表达式是输出值的，并且可以写在任何需要一个值的地方。  笼统来说，一个语句表示执行了一个动作。  一个程序基本上就是一系列的语句的集合（这里我们忽略声明（declarations））。 
-  在JavaScript中需要语句的地方，也可以写入一个表达式。这样的语句可以称为表达式语句*（expression statement）*。 
-  但是反过来则行不通了，你不能够在需要表达式的地方写入一个语句。例如，一个if语句不能作为函数的实参。 

下面是一个if语句的例子:

```js
var x;if (y >= 0) {x = y;} else {x = -y;}
```

类似if语句功能的表达式叫做条件运算符.上面的语句等价于下面的.

```js
var x = (y >= 0 ? y : -y);
```

在等于号=和分号;之间的代码就是条件表达式.



 表达式是由运算符构成，并运算产生结果的语法结构。

程序是由语句构成，语句则是由“；（分号）”分隔的句子或命令。

如果在表达式后面加上一个“；”分隔符，这就被称为“表达式语句”。它表明“只有表达式，而没有其他语法元素的语句” 

 ![img](/../../../../Typora图库/Web前端/表达式和语句.png) 

### 36 

### 37 

### 38 map与forEach的区别

- forEach ⽅法，是最基本的⽅法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item 、数组索引index 、和当前遍历数组Array
- map ⽅法，基本⽤法与forEach ⼀致，但是不同的，**它会返回⼀个新的数组**，所以在callback需要有return 值，如果没有，会返回undefined

### 39 

### 40 

### 41 异步编程的实现⽅式

- 回调函数
  优点：简单、容易理解
  缺点：不利于维护，代码耦合⾼
- 事件监听(采⽤时间驱动模式，取决于某个事件是否发⽣)：
  优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
  缺点：事件驱动型，流程不够清晰
- 发布/订阅(观察者模式)
  类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者

- Promise对象
  优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；
  缺点：编写和理解，相对⽐较难
- Generator函数
  优点：函数体内外的数据交换、错误处理机制
  缺点：流程管理不⽅便
- async函数
  优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。
  缺点：错误处理机制

### 42 对原⽣Javascript了解程度

数据类型、运算、对象、Function、继承、闭包、作⽤域、原型链、事件、RegExp 、JSON 、Ajax 、DOM 、BOM 、内存泄漏、跨域、异步装载、模板引擎、前端MVC 、路由、模块化、Canvas 、ECMAScript

### 43 JS 数组和对象的遍历⽅式，以及⼏种⽅式的⽐较

for in 循环
for 循环
forEach

- 在⽅式⼀中， **for-in 需要分析出array 的每个属性，这个操作性能开销很⼤**。⽤在key 已知的数组上是⾮常不划算的。所以尽量不要⽤for-in ，除⾮你不清楚要处理哪些属性，例如 JSON 对象这样的情况
- 在⽅式2中，**循环每进⾏⼀次，就要检查⼀下数组⻓度**。读取属性（数组⻓度）要⽐读局部变量慢，尤其是当 array ⾥存放的都是 DOM 元素，因为每次读取都会扫描⼀遍⻚⾯上的选择器相关元素，速度会⼤⼤降低
- forEach 回调中两个参数分别为 value ， index；forEach ⽆法遍历对象；IE不⽀持该⽅法； Firefox 和 chrome ⽀持；forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环

### 44 gulp是什么

- gulp 是前端开发过程中⼀种基于流的代码构建⼯具，是⾃动化项⽬的构建利器；它不仅能对⽹站资源进⾏优化，⽽且在开发过程中很多重复的任务能够使⽤正确的⼯具⾃动完成
- Gulp的核⼼概念：流。流，简单来说就是建⽴在⾯向对象基础上的⼀种抽象的处理数据的⼯具。在流中，定义了⼀些处理数据的基本操作，如读取数据，写⼊数据等，程序员是对流进⾏所有操作的，⽽不⽤关⼼流的另⼀头数据的真正流向
- gulp正是通过流和代码优于配置的策略来尽量简化任务编写的⼯作
- Gulp的特点：
  - 易于使⽤：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理
  - 构建快速 利⽤ Node.js 流的威⼒，你可以快速构建项⽬并减少频繁的 IO 操作
  - 易于学习 通过最少的 API ，掌握 gulp 毫不费⼒，构建⼯作尽在掌握：如同⼀系列流管道

### 45 function let var const

let

- 允许你声明⼀个作⽤域被限制在块级中的变量、语句或者表达式
- let绑定不受变量提升的约束，这意味着let声明不会被提升到当前
- 该变量处于从块开始到初始化处理的“暂存死区”

var

- 声明变量的作⽤域限制在其声明位置的上下⽂中，⽽⾮声明变量总是全局的
- 由于变量声明（以及其他声明）总是在任意代码执⾏之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明

const

- 声明创建⼀个值的只读引⽤ (即指针)
- 基本数据当值发⽣改变时，那么其对应的指针也将发⽣改变，故造成 const 申明基本数据类型时
- 再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5 时 将会报错
- 但是如果是复合类型时，如果只改变复合类型的其中某个Value 项时， 将还是正常使⽤

**function let var const**

- function,var声明的变量依附在最近函数作用域或全局作用域，let,const声明的变量依附在最近块级作用域、函数作用域或全局作用域
- function,var声明的变量在编译阶段产生变量提升，且函数优先提升。let，const不会产生变量提升
- fucntion，var在同一作用域重复声明变量，后者会覆盖前者（前者与后者的关系要看编译环节过后的代码）；而let,const 会直接抛出语法错误
- const 声明变量的同时需要赋值，否则抛出语法错误，且变量的指向不能变（但是变量指向的内容可以变）

| 关键字 | 变量提升 | 块级作用域 | 初始值 | 更改值 | 通过window调用 |
| ------ | -------- | ---------- | ------ | ------ | -------------- |
| var    | √        | x          | -      | Yes    | Yes            |
| let    | x        | √          | -      | Yes    | No             |
| const  | x        | √          | Yes    | No     | No             |

### 46 希望获取到⻚⾯中所有的checkbox怎么做？

不使⽤第三⽅框架

```javascript
var domList = document.getElementsByTagName(‘input’)
var checkBoxList = [];
var len = domList.length; //缓存到局部变量
while (len--) { //使⽤while的效率会⽐for循环更⾼
	if (domList[len].type == ‘checkbox’) {
		checkBoxList.push(domList[len]);
	}
}
```

### 47 添加、移除、移动、复制、创建和查找节点

创建新节点

```javascript
createDocumentFragment() //创建⼀个DOM⽚段
createElement() //创建⼀个具体的元素
createTextNode() //创建⼀个⽂本节点
```

添加、移除、替换、插⼊

```javascript
appendChild() //添加
removeChild() //移除
replaceChild() //替换
insertBefore() //插⼊
```

查找

```javascript
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name属性的值
getElementById() //通过元素Id，唯⼀性
```

### 48 正则表达式

正则表达式构造函数`var reg=new RegExp(“xxx”) `与正则表达字⾯量`var reg=//` 有什么不同？

当使⽤RegExp() 构造函数的时候，不仅需要转义引号（即\ ”表示”），并且还需要双反斜杠（即\\ 表示⼀个\ ）。**使⽤正则表达字⾯量的效率更⾼**

**字符类**

将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符，因此表达式 `/[abc]/` 就和字母a,b,c中的任意一个都匹配

```js
  var reg = /[a-z0-9]/;
```

上面的正则表达式可以匹配任意一个字母或数字，其中 `a-z` 表示a到z的所有字母，`0-9` 表示0到9之间的数字

反字符类`[^...]`

就是匹配字符类中不含有的字符，用 `^` 符号开头

```js
var reg = /[^a-z0-9]/;
```

上面的正则表达式的意思就是匹配任意一个不含有字母和数字的字符

#### 正则表达式的字符类

|        |                                             |
| ------ | ------------------------------------------- |
| [...]  | 字符类                                      |
| [^...] | 反字符类                                    |
| .      | 除换行符和其他unicode行终止符之外的任意字符 |
| \w     | 数字，字母和下划线， 等价于[a-z0-9_]        |
| \W     | 非数字，字母和下划线， 等价于`[^a-z0-9_]`    |
| \s     | 任何unicode 空白符                          |
| \S     | 非任何unicode 空白符                        |
| \d     | 数字                                        |
| \D     | 非数字                                      |
| \b     | 单词边界                                    |
| \B     | 非单词边界                                  |

#### 正则表达式的重复语法

|        |                          |
| ------ | ------------------------ |
| {n, m} | 最少匹配n次，最多匹配m次 |
| {n, }  | 至少匹配n次或更多        |
| {n}    | 匹配n次                  |
| ?      | 匹配0次或一次            |
| +      | 最少匹配一次             |
| *      | 匹配0次或多次            |

#### 非贪婪模式

上面我们列举出了匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配。因此我们称之为'贪婪'匹配模式。我们同样可以使用的正则表达式进行非贪婪匹配。只需要在待匹配的字符后跟随一个问号即可: `'??', '+?', '*?' 或者'{1, 5}?'`

```js
  var a = /[a-z0-9]+?/
  a.exec('sdfff900') // ["s", index: 0, input: "sdfff900", groups: undefined]
  
  // 使用非贪婪模式匹配得到的结果可能和期望并不一样，可以来看看看下面的这个例子：
  var b = /a+?b/;
  b.exec('aaab') // ["aaab", index: 0, input: "aaab", groups: undefined]

  // 下面这样的匹配结果你想到了吗？？
  var c = /shen(ab)+?/;
  b.exec('shenababab'); // ["shenab", "ab", index: 0, input: "shenababab", groups: undefined]
```

这是因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置，由于这个匹配是从字符串的第一个字符开始的，因此在这里不考虑他的子串中更短的匹配

#### 选择，分组和引用

正则表达式语法还包括指定选择项，子表达分组和引用前一子表达式的特殊字符，我们分别来看一下

**选择项：`|` 用于分隔供选择的字符。**

`/ab|cd|ef/`，可以匹配字符串ab，也可以匹配cd或者是ef。

注意选择项的尝试匹配的次序是从左到右，直到发现了匹配的项。如果左边的选择项匹配，就忽略右边的选择项，即使产生更好的匹配。 所以，当正则表达式 `/a|ab/` 匹配字符串 `ab` 时，他只能匹配第一个字符串 `a`

**子表达式：**

正则表达式中的圆括号有多种作用。

把单独的项组合成子表达式，以便可以像处理单独的单元那样用 `| * + ？` 等来对单元内的项进行处理。

```js
  var a = /java(script)?/; // 可以匹配字符串 'java'，其后可以有'script'也可以没有。
  var b = /(ab|cd)+|ef/; // 可以匹配字符串ef， 也可以匹配ab或者cd的一次或多次重复
```

在完整的模式中定义子模式，当一个正则表达式和目标字符串成功匹配时，可以从目标字符串中拿到和圆括号中的字符模式相匹配的部分。

```js
  var a = /[a-z]+(\d+)/; // 那么这个时候我们可以从检索到的匹配中拿到和圆括号中子模式相匹配的数字
```

`()` 表示捕获分组，`()` 会把每个分组里的匹配的值保存起来，使用 `$n` (n是一个数字，表示第n个捕获组的内容)

```js
  var reg = /\b(shen(sxx))/;
  reg.test('shensxx');
  console.log(RegExp.$1, RegExp.$2) // shensxx sxx
  
  reg.exec('shensxx');
  // ["shensxx", "shensxx", "sxx", index: 0, input: "shensxx", groups: undefined]
```

`(?:)` 表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来

```js
  var reg = /\b(shen(?:sxx))/;
  reg.test('shensxx');
  console.log(RegExp.$1, RegExp.$2) // shensxx
  
  reg.exec('shensxx');
  // ["shensxx", "shensxx", index: 0, input: "shensxx", groups: undefined]
```

**引用：在同一正则表达式的后部引用前面的子表达式**

这是通过在字符 `\` 后面加一位数字或多位数字来实现的，这个数字指定了圆括号的子表达式在正则表达式中的位置。`\1, \3` 分别表示正则表达式中的第一个圆括号的子表达式和第三个子表达式（注意这里指的是自表达式中匹配的文本的引用，并不是指子表达式）

注意： 因为子表达式可以嵌套另一个子表达式，所以他们的位置是参与计数的左括号的位置

```js
  var a = /([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/; // \2 则是代表的([Ss]sript)

	var b = /(['"])[^'"]*\1/; // 只能匹配单引号或者双引号是成对出现的，不允许出现一个单引号一个双引号
```

#### 指定匹配位置

有一些正则表达式匹配的是字符串之间的位置，而不是实际的字符。例如 `\b` 匹配一个单词边界，即位于 `\w`  和 `\W` 之间的边界，或者是一个字符串开始或结束的位置。像 `\b`  这样的元素不匹配某个可见的字符，他们指定匹配发生的合法位置。还有一些锚元素 `^ $`, 分表表示匹配字符串开始和结束的位置

**`\b` 匹配一个单词边界，即位于 `\w`  和 `\W` 之间的边界，或者是一个字符串开始或结束的位置。**

```js
  var reg = /xx\b/; 
  reg.test('sxx shen') // true
  reg.test('xxs shen') // false
      
  var reg = /\bsx/;
  reg.test('sxx shen') // true
  reg.test('xsx shen') // false

  var reg = /\b\d+/;
  reg.test('.123') // true 
  reg.test('sxx124') // false

```

`**\B` 匹配非单词边界。`er\B` 能匹配 `verb` 中的 `er`，但不能匹配 `never` 中的 `er`。**

**`x(?=y)` ：正向先行断言，匹配 `x` 仅仅当 `x` 后面不跟着 `y`**

**`x(?!y)` ：负向先行断言, 匹配 `x` 仅仅当 `x` 后面不跟着 `y**`

我们看下面的正则表达式，意思就是非单词边界后面跟这三个数字字符串，而且三个数字字符串后面不再跟数字

```js
  var reg = /\B(?=(\d{3})+(?!\d))/g;
  '123456789.123456'.replace(reg, ',') // "123,456,789.123,456"
```

**`(?<=y)x` ：正向后行断言，匹配 `x` 仅仅当 `x` 前面跟着 `y`**

```js
  var reg = /(?<=95|98|NT|2000)Windows/;
  
  '3.1Windows'.replace(reg, 'aaaa'); // '3.1Windows'没有匹配到
  
  '2000Windows'.replace(reg, 'aaaa'); // '2000aaaa'
```

**`(?<!y)x` ：负向后行断言，匹配 x 仅仅当 x 前面跟的不是 y**

```js
  var reg = /(?<!95|98|NT|2000)Windows/;
  
  '3.1Windows'.replace(reg, 'aaaa'); // '3.1aaaa'
  
  '2000Windows'.replace(reg, 'aaaa'); // '2000Windows' 没有匹配到
```

看个demo，不在小数点后加千分符

```js
  var reg = /(?<!\.\d*)\B(?=(\d{3})+(?!\d))/g
  
  '123456789.98764525437'.replace(reg, ',')
  
  // "123,456,789.98764525437"

```

#### 修饰符

i: 执行时不区分大小写 g: 执行一个全局匹配，简而言之，就是找到所有的匹配，而不是在找到第一个之后就停止 m: 多行匹配模式，`^` 匹配一行的开头和字符串的开头，`$` 匹配行的结束和字符串的结束

使用字面量形式时： `/\bjavascript\b/ig` 构造函数形式：    `new RegExp('\bjavascript\b', 'ig')`

#### string支持4种使用正则表达式的方式

**search()** 

不支持全局匹配，会忽略修饰符g

```js
//@params: 一个正则表达式，如果参数不是一个正则表达式，那么会通过 `RegExp` 构造函数转成正则表达式
//@return: 第一个与之匹配的字符串的起始位置，若是没有发生匹配就返回数字 `-1`
  var a = 'javascript'
  'fsfsdjavsssjavasdfsfsjfjhhshh3r98u'.search(a) // 11
  
  var a = /[Jj]ava([Ss]crit)*/g;
  '012345javascript 67890'.search(a) // 6
```

replace()

```js
@params: RegExp | string (正则表达式，可以设置修饰符)
@params: function | string
@return: 返回一个新的字符串，不改变源对象
```

如果第一个参数是一个string，那么 `replace()` 将直接搜索这个字符串然后进行替换（注意这里指替换第一个搜索到的结果），并不会先转成 `RegExp` 进行匹配。 如果第一个参数是一个 `RegExp`，那么 `replace()` 将会进行正则匹配，将第一次匹配到结果进行替换，这里正则表达式可以设置修饰符。`g` 会进行全局多次匹配，将所有匹配到的结果进行替换

如果第二个参数是一个 `string`，那么 `replace()` 将匹配的结果直接用这个字符串替换 如果第二个参数是一个 `function`，我们看看可以有哪些参数： @params: 完整模式匹配到的结果 @params: 完整模式下的子模式匹配到的结果，看正则表达式中有多少个圆括号，那么这里就可以有多少个这样的参数，每个参数表示对应的子模式匹配的结果 @return: 使用 `return` 的返回值替换匹配到的值

```js
    var a = /([Jj]ava([Ss]cript))\sis\s(fun\w*)/g;
    var b = 'ffhfhjavascript is functionsdfffsff';
    
    b.replace(a, function(match) {
        // 打印的结果就是 javascript is functionsdfffsff 123
    	console.log(match, 123);
    	return '@@@@'
    });
    // ffhfh@@@@

    b.replace(a, function(match, v1, v2, v3) {
        // 打印的结果就是 javascript is functionsdfffsff 123
        console.log(match, 123);
        // javascript
        console.log(v1);
        // script
        console.log(v2);
        // functionsdfffsff
        console.log(v3);
    
    	return '@@@@'
    });
    // ffhfh@@@@
```

**match()**

```js
@params: 正则表达式 | string（通过 `RegExp` 的构造函数转化成正则表达式）
@return: 数组，
```

如果这个正则表达式没有设置修饰符 `g`，`match()` 就不会进行全局检索，只检索第一个匹配。在这种情况下：数组的第一个元素就是就是完整模式匹配的结果，其余的元素则是正则表达式中圆括号的子表达式匹配的结果（如果没有圆括号就不会有这些元素）。`index` 表示匹配的位置，`input` 表示目标字符串

```js
  var a = /([Jj]ava([Ss]cript))\sis\s(fun\w*)/;
  var b = 'ffhfhjavascript is functionsdfffsff';
  
  b.match(a)
  // ["javascript is functionsdfffsff", "javascript", "script", "functionsdfffsff", index: 5, input: "ffhfhjavascript is functionsdfffsff", groups: undefined]

```

如果添加了修饰符`g`，那么返回的数组中就是多次全局模式匹配的结果

```js
  var a = /123(sxx)456(hello)/g;
  var b ='123sxx456helloffffjfljfj123sxx456hellojjweww123456hello123sxx456hello';
  
  b.match(a)
  // ["123sxx456hello", "123sxx456hello", "123sxx456hello"]
```

#### RegExp的两种方法：exec() 和 test()

**exec()**

```js
@params: string
@return: 数组 | null
```

如果匹配到结果就返回一个数组，结果和字符串的 `match()` 方法的非全局匹配返回的结果一样。但是有一点和 `match()` 不一样，就是不管式全局还是非全局都是一样的结构。如果没有匹配到结果就返回 `null`

```js
  var a = /123(sxx)456(hello)/g;
  var b ='123sxx456helloffffjfljfj123sxx456hellojjweww123456hello123sxx456hello';
  a.exec(b);
  // [“123sxx456hello", "sxx", "hello", index: 0, input: "123sxx456helloffffjfljfj123sxx456hellojjweww123456hello123sxx456hello", groups: undefined]
```

**test()**

```js
@params: string
@return: boolean
```

这个方法很简，匹配成功就返回`true`，否则就返回`false`

#### 常用正则

 目前收集整理了21个常用的javaScript正则表达式，其中包括用户名、密码强度、整数、数字、电子邮件地址（Email）、手机号码、身份证号、URL地址、 IP地址、 十六进制颜色、 日期、 微信号、车牌号、中文正则等。 

**密码强度正则**

密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符

```js
var pattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).*$/;
```

**数字相关正则**

```js
var posPattern = /^\d+$/; // 正整数正则
var negPattern = /^-\d*\.\d+$/; // 负浮点数正则
var posPattern = /^\d*\.?\d+$/; // 正数正则
var numPattern = /^-?\d*\.?\d+$/; // 数字正则
```

**通用日期正则**

```js
var dP2 = /^\d{4}-\d{1,2}-\d{1,2}$/;
```

**Email正则**

- 基本Email正则

```js
var pattern = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;
```

- 特定域名Email正则 在手机验证码出现之前，差不多邮箱验证是保证用户唯一性的唯一条件。而临时邮箱（也称10分钟邮箱或一次性邮箱）的出现，则使得邮箱验证及帐户激活这种机制失去了意义。而临时邮箱的地址是不可枚举的，我们只能才采取白名单的方式，只允许有限的邮箱域名通过验证。

```js
var pattern = /^([A-Za-z0-9_\-\.])+\@(163.com|qq.com)$/;
```

此方法虽然能保证验证安全性，但是如果白名单太长会造成模式字符串太长。这时可以将邮箱域名白名单写成数组，利用正则表达式做初步验证，用白名单做域名的二次验证。

常用域名白名单数组：

```js
var domains= ["qq.com","163.com","vip.163.com","263.net","yeah.net","sohu.com","sina.cn","sina.com","eyou.com","gmail.com","hotmail.com"];
```

上述白名单只列举了常用的11种邮箱域名，可以根据需要适当补充或删减。

**手机号码正则**

```js
var mPattern = /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d{8}$/;
```

**身份证号（18位）正则**

```js
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
```

**URL正则**

```js
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
```

**IP地址**

// IPv4地址正则

```js
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
```

// IPv6地址正则

```js
var pattern = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;
```

**十六进制颜色正则 / RGB Hex颜色正则**

```js
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
```

**QQ号正则，5至11位**

```js
var qqPattern = /^[1-9][0-9]{4,10}$/;
```

**微信号正则，6至20位，以字母开头，字母，数字，减号，下划线**

```js
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
```

**车牌号正则**

```js
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
```

**包含中文正则**

```js
var cnPattern = /[\u4E00-\u9FA5]/;
```

**中国邮编(中国邮政编码为6位数字)**

```js
var pattern = /^[1-9]\d{5}(?!\d)$/
```

**空白行的正则表达式**

```js
var pattern = /\n\s*\r/ (可以用来删除空白行)
```

### 49 Javascript中callee和caller的作⽤？

- caller 是**返回⼀个对函数的引⽤，该函数调⽤了当前函数**；
- callee 是**返回正在被执⾏的function 函数，也就是所指定的function 对象的正⽂**

如果⼀对兔⼦每⽉⽣⼀对兔⼦；⼀对新⽣兔，从第⼆个⽉起就开始⽣兔⼦；假定每对兔⼦都是⼀雌⼀雄，试问⼀对兔⼦，第n个⽉能繁殖成多少对兔⼦？（使⽤callee 完成）

```javascript
var result=[];
function fn(n){ //典型的斐波那契数列
	if(n==1){
		return 1;
	}else if(n==2){
		return 1;
	}else{
		if(result[n]){
			return result[n];
		}else{
			//argument.callee()表示fn()
			result[n]=arguments.callee(n-1)+arguments.callee(n-2);
			return result[n];
		}
	}
}
```

### 50 window.onload和$(document).ready

- window.onload() ⽅法是必须等到⻚⾯内包括图⽚的所有元素加载完毕后才能执⾏。
- $(document).ready() 是DOM 结构绘制完毕后就执⾏，不必等到加载完毕

### 51 addEventListener()和attachEvent()

- addEventListener() 是符合W3C规范的标准⽅法; attachEvent() 是IE低版本的⾮标准⽅法
- addEventListener() ⽀持事件冒泡和事件捕获; - ⽽attachEvent() 只⽀持事件冒泡
- addEventListener() 的第⼀个参数中,事件类型不需要添加on ; attachEvent() 需要添加'on'
- 如果为同⼀个元素绑定多个事件, addEventListener() 会按照事件绑定的顺序**依次执⾏**,attachEvent() 会按照事件绑定的顺序**倒序执⾏**

### 52 获取⻚⾯所有的checkbox

```javascript
var resultArr= [];
var input = document.querySelectorAll('input');
for( var i = 0; i < input.length; i++ ) {
	if( input[i].type == 'checkbox' ) {
		resultArr.push( input[i] );
	}
}
//resultArr即中获取到了⻚⾯中的所有checkbox
```

### 53 Javascript全局函数和全局变量

全局变量

- Infinity 代表正的⽆穷⼤的数值。
- NaN 指示某个值是不是数字值。
- undefined 指示未定义的值。

全局函数

- decodeURI() 解码某个编码的 URI 。
- decodeURIComponent() 解码⼀个编码的 URI 组件。
- encodeURI() 把字符串编码为 URI。
- encodeURIComponent() 把字符串编码为 URI 组件。
- escape() 对字符串进⾏编码。
- eval() 计算 JavaScript 字符串，并把它作为脚本代码来执⾏。
- isFinite() 检查某个值是否为有穷⼤的数。
- isNaN() 检查某个值是否是数字。
- Number() 把对象的值转换为数字。
- parseFloat() 解析⼀个字符串并返回⼀个浮点数。
- parseInt() 解析⼀个字符串并返回⼀个整数。
- String() 把对象的值转换为字符串。
- unescape() 对由escape() 编码的字符串进⾏解码

### 54 封装⼀个函数，参数是定时器的时间，.then执⾏回调函数

```javascript
function sleep (time) {
	return new Promise((resolve) => setTimeout(resolve, time));
}
```

### 55 怎么判断两个对象相等？（stringify）

```javascript
obj={
	a:1,
	b:2
}
obj2={
	a:1,
	b:2
}
obj3={
	a:1,
	b:'2'
}

JSON.stringify(obj)==JSON.stringify(obj2);//true
JSON.stringify(obj)==JSON.stringify(obj3);//false
```

### 56 项⽬做过哪些性能优化？

减少 HTTP 请求数
减少 DNS 查询
使⽤ CDN
避免重定向
图⽚懒加载
减少 DOM 元素数量
减少DOM 操作
使⽤外部 JavaScript 和 CSS
压缩 JavaScript 、 CSS 、字体、图⽚等
优化 CSS Sprite
使⽤ iconfont
字体裁剪
多域名分发划分内容到不同域名
尽量减少 iframe 使⽤
避免图⽚ src 为空
把样式表放在link 中
把JavaScript 放在⻚⾯底部

### 57 

### 58 防抖/节流

**防抖： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。** 

```javascript
/**
* underscore 防抖函数，返回函数连续调⽤时，空闲时间必须⼤于或等于 wait，func 才会执⾏
*
* @param {function} func 回调函数
* @param {number} wait 表示时间窗⼝的间隔
* @param {boolean} immediate 设置为ture时，是否⽴即调⽤函数
* @return {function} 返回客户调⽤函数
*/
_.debounce = function(func, wait, immediate) {
	var timeout, args, context, timestamp, result;
	var later = function() {
		// 现在和上⼀次时间戳⽐较
		var last = _.now() - timestamp;
		// 如果当前间隔时间少于设定时间且⼤于0就重新设置定时器
		if (last < wait && last >= 0) {
			timeout = setTimeout(later, wait - last);
		} else {
			// 否则的话就是时间到了执⾏回调函数
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				if (!timeout) context = args = null;
			}
		}
	};
	return function() {
		context = this;
		args = arguments;
		// 获得时间戳
		timestamp = _.now();
		// 如果定时器不存在且⽴即执⾏函数
		var callNow = immediate && !timeout;
		// 如果定时器不存在就创建⼀个
		if (!timeout) timeout = setTimeout(later, wait);
			if (callNow) {
				// 如果需要⽴即执⾏函数的话 通过 apply 执⾏
				result = func.apply(context, args);
				context = args = null;
			}
		return result;
	};
};
```

对于按钮防点击来说的实现

- 开始⼀个定时器，只要我定时器还在，不管你怎么点击都不会执⾏回调函数。⼀旦定时器结束并设置为 null，就可以再次点击了
- 对于延时执⾏函数来说的实现：每次调⽤防抖动函数都会判断本次调⽤和之前的时间间隔，如果⼩于需要的时间间隔，就会重新创建⼀个定时器，并且定时器的延时为设定时间减去之前的时间间隔。⼀旦时间到了，就会执⾏相应的回调函数

**节流： 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。** 

```javascript
/**
* underscore 节流函数，返回函数连续调⽤时，func 执⾏频率限定为 次 / wait
*
* @param {function} func 回调函数
* @param {number} wait 表示时间窗⼝的间隔
* @param {object} options 如果想忽略开始函数的的调⽤，传⼊{leading: false
* 如果想忽略结尾函数的调⽤，传⼊{trailing: false
* 两者不能共存，否则函数不能执⾏
* @return {function} 返回客户调⽤函数
*/
_.throttle = function(func, wait, options) {
	var context, args, result;
	var timeout = null;
	// 之前的时间戳
	var previous = 0;
	// 如果 options 没传则设为空对象
	if (!options) options = {};
	// 定时器回调函数
	var later = function() {
	// 如果设置了 leading，就将 previous 设为 0
	// ⽤于下⾯函数的第⼀个 if 判断
	previous = options.leading === false ? 0 : _.now();
	// 置空⼀是为了防⽌内存泄漏，⼆是为了下⾯的定时器判断
	timeout = null;
	result = func.apply(context, args);
	if (!timeout) context = args = null;
};
return function() {
	// 获得当前时间戳
	var now = _.now();
	// ⾸次进⼊前者肯定为 true
	// 如果需要第⼀次不执⾏函数
	// 就将上次时间戳设为当前的
	// 这样在接下来计算 remaining 的值时会⼤于0
	if (!previous && options.leading === false) previous = now;
	// 计算剩余时间
	var remaining = wait - (now - previous);
	context = this;
	args = arguments;
	// 如果当前调⽤已经⼤于上次调⽤时间 + wait
	// 或者⽤户⼿动调了时间
	// 如果设置了 trailing，只会进⼊这个条件
	// 如果没有设置 leading，那么第⼀次会进⼊这个条件
	// 还有⼀点，你可能会觉得开启了定时器那么应该不会进⼊这个 if 条件了
	// 其实还是会进⼊的，因为定时器的延时
	// 并不是准确的时间，很可能你设置了2秒
	// 但是他需要2.2秒才触发，这时候就会进⼊这个条件
	if (remaining <= 0 || remaining > wait) {
		// 如果存在定时器就清理掉否则会调⽤⼆次回调
		if (timeout) {
			clearTimeout(timeout);
			timeout = null;
		}
		previous = now;
		result = func.apply(context, args);
		if (!timeout) context = args = null;
		} else if (!timeout && options.trailing !== false) {
			// 判断是否设置了定时器和 trailing
			// 没有的话就开启⼀个定时器
			// 并且不能不能同时设置 leading 和 trailing
			timeout = setTimeout(later, remaining);
		}
		return result;
	};
};
```

总结

- 函数防抖和函数节流**都是防止某一时间频繁触发**，但是这两兄弟之间的原理却不一样。
- **函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。**

结合应用场景

- debounce 
  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- throttle 
  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

### 59 变量提升

**当执⾏ JS 代码时，会⽣成执⾏环境，只要代码不是写在函数中的，就是在全局执⾏环境中，函数中的代码会产⽣函数执⾏环境，只此两种执⾏环境.**

通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释应该是：在⽣成执⾏环境时，会有两个阶段。**第⼀个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以直接提前使⽤**

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```javascript
b() // call b second
function b() {
	console.log('call b fist')
}
function b() {
	console.log('call b second')
}
var b = 'Hello world'
```

复制代码var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。let 不能在声明前使⽤，但是这并不是常说的 let 不会提升， let 提升了，在第⼀阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使⽤

### 60 单线程和异步的关系

单线程 - 只有⼀个线程，只能做⼀件事

原因 - 避免 DOM 渲染的冲突

- 浏览器需要渲染 DOM
- JS 可以修改 DOM 结构
- JS 执⾏的时候，浏览器 DOM 渲染会暂停
- 两段 JS 也不能同时执⾏（都修改 DOM 就冲突了）
- webworker ⽀持多线程，但是不能访问 DOM

解决⽅案 - 异步

### 61 事件循环 Eventloop（宏任务，微任务）

**Eventloop**

⾸先， js 是单线程的，主要的任务是处理⽤户的交互，⽽⽤户的交互⽆⾮就是响应DOM 的增删改，使⽤事件队列的形式，⼀次事件循环只处理⼀个事件响应，使得脚本执⾏相对连续，所以有了**事件队列，⽤来储存待执⾏的事件**，那么事件队列的事件从哪⾥被push 进来的呢。那就是另外⼀个线程叫**事件触发线程**做的事情了，他的作⽤主要是**在定时触发器线程、异步HTTP 请求线程满⾜特定条件下的回调函数push 到事件队列中，等待js 引擎空闲的时候去执⾏**，当然js引擎执⾏过程中有优先级之分，⾸先js引擎在⼀次事件循环中，会先执⾏js线程的主任务，然后会去查找是否有微任务microtask，如果有那就优先执⾏微任务，如果没有，在去查找宏任务macrotask进⾏执⾏

**微任务包括 process.nextTick ， promise ， Object.observe ，MutationObserver**
**宏任务包括 script ， setTimeout ， setInterval ， setImmediate ， I/O ，UI renderin**

很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务

所以正确的⼀次 Event loop 顺序是这样的

- 执⾏同步代码，这属于宏任务
- 执⾏栈为空，查询是否有微任务需要执⾏
- 执⾏所有微任务
- 必要的话渲染 UI
- 然后开始下⼀轮 Event loop ，执⾏宏任务中的异步代码

通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的 界⾯响应，我们可以把操作 DOM 放⼊微任务中

**Node的应⽤场景**

- 特点：
  1、它是⼀个Javascript 运⾏环境
  2、依赖于Chrome V8 引擎进⾏代码解释
  3、事件驱动
  4、⾮阻塞I/O
  5、单进程，单线程
- 优点：
  ⾼并发（最重要的优点）
- 缺点：
  1、只⽀持单核CPU ，不能充分利⽤CPU
  2、可靠性低，⼀旦代码某个环节崩溃，整个系统都崩溃

### 62 消息队列

 消息就是注册异步任务时添加的回调函数。 

 ![img](/../../../../Typora图库/Web前端/消息队列.png) 

### 63 ⼿写实现⼀个promise

**Promise 出现的原因 & 业界实现**

 在 Promise 出现以前，在我们处理多个异步请求嵌套时， 为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的**回调地狱**～产生**回调地狱**的原因归结起来有两点：

1. **嵌套调用**，第一个函数的输出往往是第二个函数的输入；
2. **处理多个异步请求并发**，开发时往往需要同步请求最终的结果。

原因分析出来后，那么问题的解决思路就很清晰了：

1. **消灭嵌套调用**：通过 Promise 的链式调用可以解决；
2. **合并多个任务的请求结果**：使用 Promise.all 获取合并多个任务的错误处理。

Promise 正是用一种更加友好的代码组织方式，解决了异步嵌套的问题。

**Promise为我们解决了什么问题？** 在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱”，而 Promise 将嵌套调用改为链式调用，增加了可阅读性和可维护性。也就是说，Promise 解决的是异步编码风格的问题。 **那 Promise 的业界实现都有哪些呢？** 业界比较著名的实现 Promise 的类库有 bluebird、Q、ES6-Promise。

可以把 Promise 看成⼀个状态机。初始是 pending 状态，可以通过函数 resolve 和reject ，将状态转变为 resolved 或者 rejected 状态，状态⼀旦改变就不能再次变化。then 函数会返回⼀个 Promise 实例，并且该返回值是⼀个新的实例⽽不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是⼀个相同实例的话，多个 then 调⽤就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap

```javascript
let fs = require('fs')

fs.readFile('./name.txt','utf8',function(err,data){
  fs.readFile(data, 'utf8',function(err,data){
    fs.readFile(data,'utf8',function(err,data){
      console.log(data);
    })
  })
})

//promise解决
let fs = require('fs')

function read(filename) {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) reject(err);
      resolve(data);
    })
  })
}

read('./name.txt').then((data)=>{
  return read(data) 
}).then((data)=>{
  return read(data)  
}).then((data)=>{
    console.log(data);
},err=>{
    console.log(err);
})

```

**基础版 Promise**

```javascript
const p1 = new Promise((resolve, reject) => {
  console.log('create a promise');
  resolve('成功了');
})

console.log("after new promise");

const p2 = p1.then(data => {
  console.log(data)
  throw new Error('失败了')
})

const p3 = p2.then(data => {
  console.log('success', data)
}, err => {
  console.log('faild', err)
})

```

 控制台输出： 

```
"create a promise"
"after new promise"
"成功了"
"faild Error: 失败了"
```

- 首先我们在调用 Promise 时，会返回一个 Promise 对象。

- 构建 Promise 对象时，需要传入一个 **executor 函数**，Promise 的主要业务流程都在 executor 函数中执行。

- 如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。

- Promise 的状态不可逆，同时调用 resolve 函数和 reject 函数，默认会采取第一次调用的结果。

 以上简单介绍了 Promise 的一些主要的使用方法，结合 [Promise/A+](https://promisesaplus.com/) 规范，我们可以分析出 Promise 的基本特征： 

> **promise 有三个状态：`pending`，`fulfilled`，or `rejected`；**「规范 Promise/A+ 2.1」
>
> `new promise`时， 需要传递一个`executor()`执行器，执行器立即执行；
>
> `executor`接受两个参数，分别是`resolve`和`reject`；
>
> promise  的默认状态是 `pending`；
>
> promise 有一个`value`保存成功状态的值，可以是`undefined/thenable/promise`；「规范 Promise/A+ 1.3」
>
> promise 有一个`reason`保存失败状态的值；「规范 Promise/A+ 1.5」
>
> promise 只能从`pending`到`rejected`, 或者从`pending`到`fulfilled`，状态一旦确认，就不会再改变；
>
> promise 必须有一个`then`方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」
>
> 如果调用 then 时，promise 已经成功，则执行`onFulfilled`，参数是`promise`的`value`；
>
> 如果调用 then 时，promise 已经失败，那么执行`onRejected`, 参数是`promise`的`reason`；
>
> 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调`onRejected`；

 熟悉设计模式的同学，应该意识到了这其实是一个**发布订阅模式**，这种**收集依赖 -> 触发通知 -> 取出依赖执行**的方式，被广泛运用于发布订阅模式的实现。 

**then 的链式调用&值穿透特性**

我们都知道，promise 的优势在于可以链式调用。在我们使用 Promise 的时候，当 then 函数中 return 了一个值，不管是什么值，我们都能在下一个 then 中获取到，这就是所谓的**then 的链式调用**。而且，当我们不在 then 中放入参数，例：`promise.then().then()`，那么其后面的 then 依旧可以得到之前 then 返回的值，这就是所谓的**值的穿透**。那具体如何实现呢？简单思考一下，如果每次调用 then 的时候，我们都重新创建一个 promise 对象，并把上一个 then 的返回结果传给这个新的 promise 的 then 方法，不就可以一直 then 下去了么？那我们来试着实现一下。这也是手写 Promise 源码的重中之重。

> then 的参数 `onFulfilled` 和 `onRejected` 可以缺省，如果 `onFulfilled` 或者 `onRejected`不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；「规范 Promise/A+ 2.2.1、2.2.1.1、2.2.1.2」
>
> promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个“新的promise"；「规范 Promise/A+ 2.2.7」
>
> 如果 then 的返回值 x 是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；
>
> 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.2.7.2」
>
> 如果 then 的返回值 x 是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛出异常，就走下一个 then 的失败；「规范 Promise/A+ 2.2.7.3、2.2.7.4」
>
> 如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.3.1」
>
> 如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略；「规范 Promise/A+ 2.3.3.3.3」

**Proimise对象方法：all()、race()、reject()和resolve()**：

- all()用于将**多个Promise实例包装成一个新的Promise实例**，只有当所有的Promise实例的状态都为fulfilled，新实例才会变为fulfilled，否则就取第一个rejected的状态作为新的实例的状态；
- race()包装的新Promise实例会根据第一个率先改变状态的实例来决定其状态。
- resolve()和reject()用于将现有的非Promise对象转换为Promise对象。



### 64 完成⼀个Dialog组件，说说你设计的思路？

- 该组件需要提供hook 指定渲染位置，默认渲染在body下⾯。
- 然后改组件可以指定外层样式，如宽度等
- 组件外层还需要⼀层mask 来遮住底层内容，点击mask 可以执⾏传进来的onCancel 函数关闭Dialog 。
- 另外组件是可控的，需要外层传⼊visible 表示是否可⻅。
- 然后Dialog 可能需要⾃定义头head和底部footer ，默认有头部和底部，底部有⼀个确认按钮和取消按钮，确认按钮会执⾏外部传进来的onOk 事件，然后取消按钮会执⾏外部传进来的onCancel 事件。
- 当组件的visible 为true 时候，设置body 的overflow 为hidden ，隐藏body 的滚动条，反之显示滚动条。
- 组件⾼度可能⼤于⻚⾯⾼度，组件内部需要滚动条。
- 只有组件的visible 有变化且为ture 时候，才重渲染组件内的所有内容

### 65 ajax、axios、fetch区别

**jQuery ajax**

```js
$.ajax({
	type: 'POST',
	url: url,
	data: data,
	dataType: dataType,
	success: function () {},
	error: function () {}
});
```

优缺点：

- 本身是针对MVC 的编程,不符合现在前端MVVM 的浪潮
- 基于原⽣的XHR 开发， XHR 本身的架构不清晰，已经有了fetch 的替代⽅案
- JQuery 整个项⽬太⼤，单纯使⽤ajax 却要引⼊整个JQuery ⾮常的不合理（采取个性化打包的⽅案⼜不能享受CDN服务）

**axios**

```javascript
axios({
	method: 'post',
	url: '/user/12345',
	data: {
		firstName: 'Fred',
		lastName: 'Flintstone'
	}
})
.then(function (response) {
	console.log(response);
})
.catch(function (error) {
	console.log(error);
});
```

优缺点：

- 从浏览器中创建 XMLHttpRequest
- 从 node.js 发出 http 请求
- ⽀持 Promise API
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- ⾃动转换JSON 数据
- 客户端⽀持防⽌CSRF/XSRF

**fetch**

```javascript
try {
	let response = await fetch(url);
	let data = response.json();
	console.log(data);
} catch(e) {
	console.log("Oops, error", e);
}
```

优缺点：

- fetcht 只对⽹络请求报错，对400 ， 500 都当做成功的请求，需要封装去处理
- fetch 默认不会带cookie ，需要添加配置项
- fetch 不⽀持abort ，不⽀持超时控制，使⽤setTimeout 及Promise.reject 的实现的超时控制并不能阻⽌请求过程继续在后台运⾏，造成了量的浪费
- fetch 没有办法原⽣监测请求的进度，⽽XHR可以

### 66 

### 67 js⾃定义事件

三要素： `document.createEvent()` `event.initEvent()` `element.dispatchEvent()`

```javascript
// (en:⾃定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加⾃定义事件，triggerEve
window.onload = function(){
	var demo = document.getElementById("demo");
	demo.addEvent("test",function(){console.log("handler1")});
	demo.addEvent("test",function(){console.log("handler2")});
	demo.onclick = function(){
		this.triggerEvent("test");
	}
}
Element.prototype.addEvent = function(en,fn){
	this.pools = this.pools || {};
	if(en in this.pools){
		this.pools[en].push(fn);
	}else{
		this.pools[en] = [];
		this.pools[en].push(fn);
	}
}
Element.prototype.triggerEvent = function(en){
	if(en in this.pools){
		var fns = this.pools[en];
		for(var i=0,il=fns.length;i<il;i++){
			fns[i]();
		}
	}else{
		return;
	}
}
```

### 68 setTimeout 倒计时误差

JS 是单线程的，所以 setTimeout 的误差其实是⽆法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致。这也是为什么⻚⾯开久了，定时器会不准的原因。

 定时器是属于 **宏任务(macrotask)** 。如果当前 **执行栈** 所花费的时间大于 **定时器** 时间，那么定时器的回调在 **宏任务(macrotask)** 里，来不及去调用，所有这个时间会有误差。 

```js
setTimeout(function () {
	console.log('biubiu');
}, 1000);

某个执行时间很长的函数();
```

如果定时器下面的函数执行要 5秒钟，那么定时器里的log 则需要 5秒之后再执行，函数占用了当前 **执行栈** ，要等执行栈执行完毕后再去读取 **微任务(microtask)**，等 **微任务(microtask)** 完成，这个时候才会去读取 **宏任务(macrotask)** 里面的 **setTimeout** 回调函数执行。**setInterval** 同理，例如每3秒放入宏任务，也要等到执行栈的完成。

setTimeout出现误差是因为：

1. 要先执行同步任务，才会执行异步任务；
2. 异步任务中，微任务执行顺序大于宏任务执行顺序。

 还有一种情况 , 如果timeout嵌套大于 5层，而时间间隔小于4ms，则时间间隔增加到4ms。 

### 69 typeof 与 instanceof 区别

**typeof 对于基本类型，除了 null 都可以显示正确的类型**。**对于 null 来说，虽然它是基本类型，但是会显示 object** ，这是⼀个存在很久了的 Bug

**typeof 对于对象，除了函数都会显示 object**，所以说 typeof 并不能准确判断变量到底是什么类型

**instanceof 可以正确的判断对象的类型**，因为**内部机制是通过判断对象的原型链中是不是能找到类型的 prototype**

如果我们想判断⼀个对象的正确类型，这时候可以考虑使⽤ instanceof ，因为内部机制是通过原型链来判断的

对于原始类型来说，你想直接通过 instanceof 来判断类型是不⾏的

### 70 深浅拷⻉

**浅拷⻉**

⾸先可以通过 Object.assign 来解决这个问题

```js
let a = {
	age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

当然我们也可以通过展开运算符（…） 来解决

```js
let a = {
	age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
```

通常浅拷⻉就能解决⼤部分问题了，但是当我们遇到如下情况就需要使⽤到深拷⻉了

```js
let a = {
	age: 1,
	jobs: {
		first: 'FE'
	}
}
let b = {...a}
a.jobs.first = 'native'
console.log(b.jobs.first) // native
```

浅拷⻉只解决了第⼀层的问题，如果接下去的值中还有对象的话，那么就⼜回到刚开始的话题了，两者享有相同的引⽤。要解决这个问题，我们需要引⼊深拷贝

**深拷⻉**

这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决

```js
let a = {
	age: 1,
	jobs: {
		first: 'FE'
	}
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

但是该⽅法也是有局限性的：

- 会忽略 undefined
- 不能序列化函数
- 不能解决循环引⽤的对象

```js
let obj = {
	a: 1,
	b: {
		c: 2,
		d: 3,
	},
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj)
```

如果你有这么⼀个循环引⽤对象，你会发现你不能通过该⽅法深拷⻉

在遇到函数或者 undefined 的时候，该对象也不能正常的序列化

```js
let a = {
	age: undefined,
	jobs: function() {},
	name: 'poetries'
}
let b = JSON.parse(JSON.stringify(a))
console.log(b) // {name: "poetries"}
```

你会发现在上述情况中，该⽅法会忽略掉函数和undefined。
但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决⼤部分问题，并且该函数是内置函数中处理深拷⻉性能最快的。当然如果你的数据中含有以上三种情况下，可以使⽤ lodash 的深拷⻉函数。

```js
import _ from lodash
const a = _.clonedeep(b)
```

### 71 Proxy

Proxy 是 ES6 中新增的功能，可以⽤来**⾃定义对象中的操作**。 对目标对象加一层“拦截”（“代理”），外界对对象的访问、修改都必须先通过这层拦截层。因而它提供了一个机制可以对外界的访问进行过滤和改写。 

简单来说:`Proxy`对象就是可以让你去对JavaScript中的一切合法对象的基本操作进行自定义.然后用你自定义的操作去覆盖其对象的基本操作.也就是当一个对象去执行一个基本操作时,其执行的过程和结果是你自定义的,而不是对象的. 

 用法：var proxy = new Proxy(p1,p2); p1是要被代理的目标对象，p2是配置对象。 

```js
let p = new Proxy(target, handler);
// `target` 代表需要添加代理的对象
// `handler` ⽤来⾃定义对象中的操作
//可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听
let onWatch = (obj, setBind, getLogger) => {
	let handler = {
		get(target, property, receiver) {
		getLogger(target, property)
		return Reflect.get(target, property, receiver);
	},
	set(target, property, value, receiver) {
		setBind(value);
		return Reflect.set(target, property, value);
	}
};
return new Proxy(obj, handler);
};
let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
	value = v
}, (target, property) => {
	console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

我们就可以看到 Proxy 与 setter 和 getters 之间的区别。它们不仅在语法上有所不同（Proxy 更为冗长），而且在与原始对象的交互方面也有所不同。Proxy会创建一个**新对象**供你与之交互，而不是与原始对象进行交互，原始对象在使用 setter/getter 时会直接修改。与 setter/getter 相比，Proxy 可以让你做更多的事情。它们更快（声明后）并且更加灵活，使其成为状态管理等用例的理想解决方案。

Proxy 带来了很多可定制性，使开发人员可以控制 JS 的某些**元功能（meta-functionalities）**。所以它们并不是向后兼容的，并且没有任何完全兼容的 polyfill 的选项存在。

对于代理模式`Proxy`的作用主要体现在三个方面:

1、 拦截和监视外部对对象的访问

2、 降低函数或类的复杂度

3、 在复杂操作前对操作进行校验或对所需资源进行管理

Proxy实例可以作为其它对象的原型对象。支持13个拦截方法，列表如下：

```js
get set has ownKeys getOwnPropertyDescriptor defineProperty deleteProperty getPrototypeOf setPrototypeOf isExtensible preventExtensions apply construct
```

值得注意的是：**Proxy不是对目标对象透明的代理**——即使不做任何拦截的情况下无法保证代理对象与目标对象行为的完全一致。（主要原因在于代理时，目标对象内部的this会指向代理对象）

### 72 Reflect

与Proxy一样是ES6为**语言层面的用于操作对象提供的新API**，目前它所拥有的对象方法与Proxy对象一一对应

**引入目的**：

1.将Object对象上一些属于语言内部的方法放在Reflect上（目前都可以放）

2.修改Object对象上某些方法的返回值，使得更加合理化（健壮）

3.让Object对象的操作从命令式完全转化为函数式

### 73 Number.isNaN()

  **`Number.isNaN()`** 方法确定传递的值是否为 `NaN`，并且检查其类型是否为 `Number`。  在 JavaScript 中，`NaN` 最特殊的地方就是，我们不能使用相等运算符（`==`) 和 `===`）来判断一个值是否是 `NaN`，因为 `NaN == NaN` 和 `NaN === NaN` 都会返回 `false`。因此，必须要有一个判断值是否是 `NaN` 的方法。

**和全局函数 `isNaN()`相比，`Number.isNaN()` 不会自行将参数转换成数字**，只有在参数是值为 `NaN` 的数字时，才会返回 `true`。

```js
Number.isNaN(NaN);        // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0)       // true

// 下面这几个如果使用全局的 isNaN() 时，会返回 true。
Number.isNaN("NaN");      // false，字符串 "NaN" 不会被隐式转换成数字 NaN。
Number.isNaN(undefined);  // false
Number.isNaN({});         // false
Number.isNaN("blabla");   // false

// 下面的都返回 false
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(37);
Number.isNaN("37");
Number.isNaN("37.37");
Number.isNaN("");
Number.isNaN(" ");

Number.isNaN = Number.isNaN || function(value) {
    return typeof value === "number" && isNaN(value);
}
```

### 74 响应头设置Cookie

 ajax请求时是不会自动带上cookie的，要是想让它带上的会，必须要设置**withCredentials为true**。

 有两种方法可以确保 `Cookie` 被安全发送，并且不会被意外的参与者或脚本访问：**`Secure` 属性和`HttpOnly` 属性**。  

- 标记为 `Secure` 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防 {{Glossary（“ MitM”，“ man-in-the -middle“）}} 攻击者的攻击。但即便设置了 `Secure` 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，`Secure` 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。  从 Chrome 52 和 Firefox 52 开始，**不安全的站点（`http:`）无法使用Cookie的 `Secure` 标记**。 
-  JavaScript {{domxref（“ Document.cookie”）}} API 无法访问带有 `HttpOnly` 属性的cookie；此类 Cookie 仅作用于服务器。例如，例如，**持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 `HttpOnly` 属性**。此预防措施有助于缓解跨站点脚本（XSS）)攻击。 

## 四、webpack

WebPack 是⼀个**模块打包⼯具**，你可以使⽤WebPack 管理你的模块依赖，并编绎输出模块们所需的静态⽂件。它能够很好地管理、打包Web 开发中所⽤到的HTML 、Javascript 、CSS 以及各种静态⽂件（图⽚、字体等），让开发过程更加⾼效。对于不同类型的资源， webpack 有对应的模块加载器。webpack 模块打包器会分析模块间的依赖关系，最后 ⽣成了优化且合并后的静态资源

### 1 打包体积 优化思路

提取第三⽅库或通过引⽤外部⽂件的⽅式引⼊第三⽅库
代码压缩插件UglifyJsPlugin
服务器启⽤gzip压缩
按需加载资源⽂件 require.ensure
优化devtool 中的source-map
剥离css ⽂件，单独打包
去除不必要插件，通常就是开发环境与⽣产环境⽤同⼀套配置⽂件导致

### 2 打包效率

开发环境采⽤增量构建，启⽤热更新
开发环境不做⽆意义的⼯作如提取css 计算⽂件hash等
配置devtool
选择合适的loader
个别loader 开启cache 如babel-loader
第三⽅库采⽤引⼊⽅式
提取公共代码
优化构建时的搜索路径 指明需要构建⽬录及不需要构建⽬录
模块化引⼊需要的部分

### 3 Loader

loader 就是⼀个node 模块，它输出了⼀个函数。当某种资源需要⽤这个loader 转换时，这个函数会被调⽤。并且，这个函数可以通过提供给它的this 上下⽂访问Loader API 。 

reverse-txt-loader：

```javascript
// 定义
module.exports = function(src) {
	//src是原⽂件内容（abcde），下⾯对内容进⾏处理，这⾥是反转
	var result = src.split('').reverse().join('');
	//返回JavaScript源码，必须是String或者Buffer
	return `module.exports = '${result}'`;
}
//使⽤
{
	test: /\.txt$/,
	use: [
		{
			'./path/reverse-txt-loader'
		}
	]
},
```

### 4 说⼀下webpack的⼀些plugin，怎么使⽤webpack对项⽬进⾏优化

构建优化

- 减少编译体积 ContextReplacementPugin 、IgnorePlugin 、babel-pluginimport、babel-plugin-transform-runtime

- 并⾏编译 happypack 、thread-loader 、uglifyjsWebpackPlugin 开启并⾏
- 缓存 cache-loader 、hard-source-webpack-plugin 、uglifyjsWebpackPlugin 开启缓存、babel-loader 开启缓存
- 预编译 dllWebpackPlugin && DllReferencePlugin 、auto-dll-webapck-plugin

性能优化

- 减少编译体积 Tree-shaking 、Scope Hositing
- hash 缓存 webpack-md5-plugin
- 拆包 splitChunksPlugin 、import() 、require.ensure

**使⽤webpack对项⽬进⾏优化**

- 对于 Webpack4 ，打包项⽬使⽤ production 模式，这样会⾃动开启代码压缩
- 使⽤ ES6 模块来开启 tree shaking ，这个技术可以移除没有使⽤的代码
- 优化图⽚，对于⼩图可以使⽤ base64 的⽅式写⼊⽂件中
- 按照路由拆分代码，实现按需加载

### 5 如何实现⼀个插件

- 调⽤插件 apply 函数传⼊ compiler 对象
- 通过 compiler 对象监听事件

⽐如你想实现⼀个编译结束退出命令的插件

```javascript
apply (compiler) {
	const afterEmit = (compilation, cb) => {
		cb()
		setTimeout(function () {
			process.exit(0)
		}, 1000)
	}
	compiler.plugin('after-emit', afterEmit)
}
module.exports = BuildEndPlugin
```

## 其他

### 1 babel原理

ES6、7 代码输⼊ -> babylon 进⾏解析 -> 得到AST （抽象语法树）->plugin ⽤b abel-traverse 对AST 树进⾏遍历转译 ->得到新的AST 树->⽤babel-generator 通过AST 树⽣成ES5 代码

- 本质就是编译器，当代码转为字符串⽣成 AST ，对 AST 进⾏转变最后再⽣成新的代码
- 分为三步：词法分析⽣成 Token ，语法分析⽣成 AST ，遍历 AST ，根据插件变换相应的节点，最后把 AST 转换为代码

### 2 TS和JS

- 语言层面：JavaScript和TypeScript都是ECMAScript（ECMA-262）的具体实现。

- 执行环境层面：浏览器引擎和Node.js都能够直接运行JavaScript，但无法直接运行TypeScript。

- 时序层面：TypeScript被真正执行前，会通过编译转换生成JavaScript，之后才能被解释执行。

   ![img](/../../../../Typora图库/Web前端/ts和js.png) 

​	*TypeScript*是一种由微软开发的自由和开源的编程语言。它是*JavaScript*的一个超集，兼容JavaScript，可以载入JS代码然后运行。它与JavaScript相比进步的地方包括：**加入注释，让编译器理解所支持的对象和函数，编译器会移除注释，不会增加开销**。 而JavaScript只是一个脚本语言，并非设计用于开发大型 Web 应用，*JavaScript* 没有提供**类和模块**的概念，而TypeScript扩展实现了这些特性。

　　它扩展了 *JavaScript* 的语法，因此现有的JavaScript代码可与其代码一起工作无需任何修改，它**通过类型注解提供编译时的静态类型检查**。TypeScript可处理已有的JavaScript代码，并只对其中的TypeScript代码进行编译。

　　***TypeScript* 最大的特点就是类型化**，因此才叫做TypeScript。比起弱类型的JavaScript，类型化的TypeScript显得更加容易维护。

### 3 Java和js区别

相同之处包括：

- 它们的语法和 C 语言都很相似；
- 它们都是**面向对象**的（虽然实现的方式略有不同）；
- JavaScript 在设计时参照了 Java 的命名规则；

Java是一门**面向对象编程语言**，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。

JavaScript是一种**直译式脚本语言**，是一种**动态类型、弱类型、基于原型**的语言。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。

**Java和JavaScript的区别**

- Java是面向对象的语言，JavaScript是脚本语言，是基于对象和事件驱动的语言。
- Java的源代码在执行之前必须经过编译，而JavaScript的代码不需要，可以由浏览器直接解释执行。
- Java变量在使用之前必须声明，而JavaScript不需要。
- Java和JavaScript代码的格式不一样；Java的语法规则比JavaScript要严格的多，功能要强大的多。
- JavaScript是动态类型语言；而Java是静态类型语言。java在定义了一个数组的长度以后就不能再改变了，但是javascript却可以。
- java主要在服务端运行；javascript主要运行在客户端浏览器中。
- JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的。

### 4 ⾯向对象编程（OOP），⾯向过程编程，函数式编程（FP）

- ⾯向过程就是**分析出解决问题所需要的步骤**，然后⽤函数把这些步骤⼀步⼀步实现，使⽤的时候⼀个⼀个依次调⽤就可以了
  -  面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤 
  -  基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：**任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行**，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。 
  -  若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。 
  - 优点：将复杂的问题流程化，进而简单化
  - 缺点：程序的可扩展性极差，因为**一套流水线或者流程就是用来解决一个问题**，就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。
  - 应用场景：面向过程的程序设计一般**用于那些功能一旦实现之后就很少需要改变的场景**， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。
- ⾯向对象是**把构成问题事务分解成各个对象**，建⽴对象的⽬的不是为了完成⼀个步骤，⽽是为了**描叙某个事物在整个解决问题的步骤中的⾏为**
  - ⾯向对象是以**功能**来划分问题，⽽不是步骤
  -  将整个任务封装成一个大的类，在这个类里面详细分解执行每个步骤，只需要执行类就可以完成任务 
- 函数式： 将计算机的运算视为数学意义上的运算，比起面向过程，函数式**更加注重的是执行结果而非执行的过程** 。 将编程分成N件事情，分配每件事情为一个函数，然后要按步骤执行函数完成。
  -  Python提供了很多函数式编程好的特性，如lambda，map，reduce，filter 

总结

- 面向过程：需要你自己去一步一步的执行

- 面向函数：也是需要自己去一步一步执行，只是执行的过程已经提前设定好了

- 面向对象：让机器人去执行 ，因为已经设定好执行步骤，你只需等待结果就好了

因此，在我看来，面向过程和对象，是自己在干活，面向对象，是先创造机器人，然后让机器人去干活。

站在计算机程序角度来讲，面向过程（函数）和面向对象的本质理解为：

- 面向过程（函数）的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

- 面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

总的来说：面向对象是将事物高度抽象化，面向对象必须先建立抽象模型，之后直接使用模型就行了；面向过程是一种自顶向下的编程!

![img](/../../../../Typora图库/Web前端/面向编程.png) 

### 5 类型语言

 ![img](/../../../../Typora图库/Web前端/类型语言.png) 

- 动态类型语言：在运行期进行类型检查的语言，也就是在编写代码的时候可以不指定变量的数据类型，比如Python和Ruby

- 静态类型语言：它的数据类型是在编译期进行检查的，也就是说变量在使用前要声明变量的数据类型，这样的好处是把类型检查放在编译期，提前检查可能出现的类型错误，典型代表C/C++和Java

- 强类型语言，一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。举个例子：如果你定义了一个double类型变量a,不经过强制类型转换那么程序int b = a无法通过编译。典型代表是Java。

- 弱类型语言：它与强类型语言定义相反,允许编译器进行隐式的类型转换，典型代表C/C++。

### 6 ES6

#### ES和JS

 1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。 

 ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现 

**JavaScript由三部分组成：**

ES 作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象 

 DOM（文档对象模型）把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。 

 BOM （浏览器对象模型）支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 

#### ES2015

1. **strict模式**

严格模式，限制一些用法，'use strict';

2. **Array增加方法**

增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法

PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now

3. **Object方法**

Object.getPrototypeOf

Object.create

Object.getOwnPropertyNames

Object.defineProperty

Object.getOwnPropertyDescriptor

Object.defineProperties

Object.keys

Object.preventExtensions / Object.isExtensible

Object.seal / Object.isSealed

Object.freeze / Object.isFrozen

PS：只讲有什么，不讲是什么。

#### ES6 新特性

- 内置对象扩展

  - String扩展

    - 新增模板字符串（为JavaScript 提供了简单的字符串插值功能）

      - 基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
      - ES6反引号(``)直接搞定；

    - includes(str, [position]) 返回布尔值,是否找到参数字符串

      startsWidth(str, [position]) 返回布尔值,表示参数字符串是否在原字符串的头部或指定位置

      endsWith(str, [position]) 表示参数字符串是否在原字符串的尾部或指定位置

      repeat() 返回一个新字符串,表示将原字符串重复n次

  - Array扩展

    - 扩展运算符(...可以把数组中的每一项展开)
    -  Array.from() 
    -  数组实例find() findIndex() 
    -  数组实例includes() 
    -  fill() 
    -  Array.of() 
    -  Set() 

  - for-of 和for-in

    -  for...of 用于遍历一个迭代器，如数组： 

      ```js
      let letter = ['a', 'b', 'c'];
      letter.size = 3;
      for (let letter of letters) {
        console.log(letter);
      }
      // 结果: a, b, c
      ```

    -  for...in 用来遍历对象中的属性 

      ```js
      let stu = ['Sam', '22', '男'];
      stu.size = 3;
      for (let stu in stus) {
        console.log(stu);
      }
      // 结果: Sam, 22, 男
      ```

- 函数

  - 箭头函数

    - 箭头函数内部的`this`指向外部作用域中的`this`,箭头函数没有自己的`this`
    - 箭头函数中内部没有`arguments`
    - 箭头函数不能作为构造函数

  - 不定参数：Spread / Rest 操作符

    -  Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。 

    -  当被用于迭代器中时，它是一个 Spread 操作符： 

      ```js
      function foo(x,y,z) {
        console.log(x,y,z);
      }
       
      let arr = [1,2,3];
      foo(...arr); // 1 2 3
      ```

    -  当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符： 

      ```js
      function foo(...args) {
        console.log(args);
      }
      foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
      ```

  -  函数参数的默认值 

    ```js
    // ES5 中给参数设置默认值的变通做法
    function fn(x, y) {
        y = y || 'world';
        console.log(x, y);
    }
    fn(1)
    // ES6 中给函数设置默认值
    function fn(x, y = 'world') {
        console.log(x, y);
    }
    fn(2)
    fn(2,3)
    ```

- 异步编程Promise、Generator和Async

- 元编程相关Proxy和Reflect

- 增加了let 和const 命令，⽤来声明变量。

- 增加了块级作⽤域（let 命令实际上就增加了块级作⽤域）。

- 引⼊module 模块的概念

  - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
  -  CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 

- 二进制和八进制字面量

  -  通过在数字前面添加 0o 或者0O 即可将其转换为八进制值： 

    ```js
    let oValue = 0o10;
    console.log(oValue); // 8
     
    let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`
    console.log(bValue); // 2
    ```

- 对象和数组解构

  ```js
  // 对象
  const student = {
      name: 'Sam',
      age: 22,
      sex: '男'
  }
  // 数组
  // const student = ['Sam', 22, '男'];
  
  // ES5；
  const name = student.name;
  const age = student.age;
  const sex = student.sex;
  console.log(name + ' --- ' + age + ' --- ' + sex);
  
  // ES6
  const { name, age, sex } = student;
  console.log(name + ' --- ' + age + ' --- ' + sex);
  ```

- 类

  - 对象超类： 允许在对象中使用 super 方法

    ```js
    var parent = {
      foo() {
        console.log("Hello from the Parent");
      }
    }
     
    var child = {
      foo() {
        super.foo();
        console.log("Hello from the Child");
      }
    }
     
    Object.setPrototypeOf(child, parent);
    child.foo(); // Hello from the Parent
                 // Hello from the Child
    ```

  -  class之间可以通过extends关键字实现继承, 

  - ES6怎么写class：在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。class 的本质是 function。它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

    ```javascript
    //常规写法
    function Person(name,age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.sayInfo = function () {
        console.log(`${this.name}是${this.age}岁`)
    }
    const liLei = new Person('LiLei',20)
    liLei.sayInfo()
    //LiLei是20岁
    
    //类
    class Person{ //定义了一个名字为Person的类
        constructor(name,age){ //constructor是一个构造方法，用来接收参数
            this.name = name;  //this代表的是实例对象
            this.age = age;
        }
        sayInfo(){
            console.log(`${this.name}是${this.age}岁`)
        }
    }
    const liLei = new Person('LiLei',21)
    liLei.sayInfo()
    ```

# 高阶部分

## React专题

### 1 React 中 keys 的作⽤是什么？

Keys 是 React ⽤于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯⼀性。在 React Diff 算法中React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动⽽来的元素，从⽽减少不必要的元素重渲染。此外React 还需要借助 Key 值来判断元素与本地状态的关联关系

### 2 传⼊ setState 函数的第⼆个参数的作⽤是什么？

该函数会在setState 函数调⽤完成并且组件开始重渲染的时候被调⽤，我们可以**⽤该函数来监听渲染是否完成**

```javascript
this.setState(
	{ username: 'tylermcginnis33' },
	() => console.log('setState has finished and the component has re-rendere
)
this.setState((prevState, props) => {
	return {
		streak: prevState.streak + props.count
	}
})
```

### 3 React 中 refs 的作⽤是什么

- Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄
- 可以为元素添加ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第⼀个参数返回

### 4 在⽣命周期中的哪⼀步你应该发起 AJAX 请求

我们应当**将AJAX 请求放到 componentDidMount 函数中执⾏**，主要原因有下:

- React 下⼀代调和算法 Fiber 会通过开始或停⽌渲染的⽅式优化应⽤性能，其会影响到componentWillMount 的触发次数。对于 componentWillMount 这个⽣命周期函数的调⽤次数会变得不确定， React 可能会多次频繁调⽤ componentWillMount 。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显⽽易⻅其会被触发多次，⾃然也就不是好的选择。
- 如果我们将AJAX 请求放置在⽣命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调⽤了setState 函数将数据添加到组件状态中，对于未挂载的组件则会报错。⽽在componentDidMount 函数中进⾏ AJAX 请求则能有效避免这个问题

### 5 shouldComponentUpdate 的作⽤

shouldComponentUpdate 允许我们**⼿动地判断是否要进⾏组件更新**，根据组件的应⽤场景设置函数的合理返回值能够帮我们避免不必要的更新

### 6 如何告诉 React 它应该编译⽣产环境版

通常情况下我们会使⽤ Webpack 的 DefinePlugin ⽅法来将 NODE_ENV变量值设置为 production 。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的⼤⼩， React 使⽤了 Uglify插件来移除⽣产环境下不必要的注释等信息

### 7 概述下 React 中的事件处理逻辑

为了解决跨浏览器兼容性问题， React 会**将浏览器原⽣事件（ Browser Native Event ）封装为合成事件（ SyntheticEvent ）传⼊设置的事件处理器中**。这⾥的合成事件提供了与原⽣事件相同的接⼝，不过它们屏蔽了底层浏览器的细节差异，保证了⾏为的⼀致性。另外有意思的是， React 并没有直接将事件附着到⼦元素上，⽽是**以单⼀事件监听器的⽅式将所有的事件发送到顶层进⾏处理**。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的⽬的

### 8 createElement 与 cloneElement 的区别是什么

createElement 函数是 JSX 编译之后使⽤的创建 React Element 的函数，⽽ cloneElement 则是⽤于复制某个元素并传⼊新的 Props

### 9 redux中间件

中间件提供第三⽅插件的模式，**⾃定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流**，实现如异步action ， action 过滤，⽇志输出，异常报告等功能

- redux-logger ：提供⽇志输出
- redux-thunk ：处理异步操作
- redux-promise ：处理异步操作， actionCreator 的返回值是promise

#### redux有什么缺点

- ⼀个组件所需要的数据，必须由⽗组件传过来，⽽不能像flux 中直接从store 取。
- 当⼀个组件相关数据更新时，即使⽗组件不需要⽤到这个组件，⽗组件还是会重新render ，可能会有效率影响，或者需要写复杂的shouldComponentUpdate 进⾏判断。

### 10 React为什么需要Hook

对于React或者其它的基于Component的框架来说，页面是由一个个UI组件构成的。独立的组件可以在同一个项目中甚至不同项目中进行复用，这十分有利于前端开发效率的提高。可是除了UI层面上的复用，一些**状态相关**（stateful）或者**副作用相关**（side effect）的**非UI逻辑**在不同组件之间复用起来却十分困难。

使用高阶组件来封装组件的这些逻辑其实会有以下的问题：

- **高阶组件的开发对开发者不友好**：开发者（特别是初级开发者）需要花费一段时间才能搞懂其中的原理并且适应它的写法。如果你使用高阶组件已经很久了，你看到这个说法可能会有些不以为然。可是我相信你在最开始接触高阶组件的时候肯定也花了一段时间才能搞懂它的原理，而且从上面的例子来看高阶组件其实是十分笨重的。试想一下，某天你的项目来了一个React新手，估计他也得花费一段时间才能理解你写的那些高阶组件代码吧。
- **高阶组件之间组合性差**：使用过高阶组件的同学一定试过由于要为组件添加不同的功能，我们要为同一个组件嵌套多个高阶组件，例如这样的代码：`withAuth(withRouter(withUserStatus(UserDetail)))`。这种嵌套写法的高阶组件可能会导致很多问题，其中一个就是props丢失的问题，例如withAuth传递给UserDetail的某个prop可能在withUserStatus组件里面丢失或者被覆盖了。如果你使用的高阶组件都是自己写的话还好，因为调试和修改起来都比较简单，如果你使用的是第三方的库的话就很头痛了。
- **容易发生wrapper hell**：这个问题在上面嵌套多重高阶组件的时候就会出现，具体会造成我们在React Devtools查看和调试某个组件的时候十分困难。 ![img](/../../../../Typora图库/Web前端/wrapperhell.png) 

和高阶组件类似，renderProps也会存在同样的问题。基于这些原因，React需要一个**新的用来复用组件之间非UI逻辑的方法**，所以Hook就这么诞生了。总的来说，Hook相对于高阶组件和renderProps在复用代码逻辑方面有以下的优势：

- **写法简单**：每一个Hook都是一个函数，因此它的写法十分简单，而且开发者更容易理解。
- **组合简单**：Hook组合起来十分简单，组件只需要同时使用多个hook就可以使用到它们所有的功能。
- **容易扩展**：Hook具有很高的可扩展性，你可以通过自定义Hook来扩展某个Hook的功能。
- **没有wrapper hell**：Hook不会改变组件的层级结构，也就不会有wrapper hell问题的产生。

### 11 react组件的划分业务组件技术组件？

- 根据组件的职责通常把组件分为UI组件和容器组件。
- UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。
- 两者通过React-Redux 提供connect ⽅法联系起来

### 12 react⽣命周期函数

 ![img](/../../../../Typora图库/Web前端/react生命周期.png) 

**React生命周期可以分为两条执行流程：**

1、初始化：初始进入页面 → constructor → componentWillMount → render → componentDidMount → componentWillUnmount；

2、更新：setState → componentWillReceiveProps → shouldComponentUpdate → componentWillUpdate → render → componentDidUpdate → componentWillUnmount。

 ![img](/../../../../Typora图库/Web前端/react生命周期初始化.png) 

1、首先，进入页面，会初始化页面数据(state, props, context等…)，等待备用；

2、然后，设置**生命状态**为：MOUNTING；

3、接下来，在componentWillMount中，setState操作，只是把state合并到初始化状态中，而根本不会触发render **；**在这里更新state，就等同于直接写在this.state中，所以，在此生命周期中的setState根本***没有意义***；

4、执行到这里，***生命状态*** 会被重置为 null，之后是渲染页面(即执行render)；

5、最后，渲染完以后，执行componentDidMount，这里使用setState即会正常触发重新渲染了，更新state。(接下来，就是**更新流程**了！！)

 ![img](/../../../../Typora图库/Web前端/react生命周期更新.png) 

1、首先，react会比较前后元素、状态等是否不同，如果不同则正式发起更新；

2、然后，***生命状态*** 被设置为RECEIVE_PROPS(注意：此时生命周期中，setState不会触发更新，而是会做其他处理)；

3、接下来，componentWillReceiveProps中的setState就不会执行更新，而是合并挂载起来，等待render时统一更新；

4、到这里，**生命状态** 会重置为null；然后shouldComponentUpdate中会判断是否更新；之后是componentWillUpdate。**敲黑板了！！！！**  shouldComponentUpdate和componentWillUpdate执行的时候，**生命状态** 已经被重置为null，在它们里面的setState会触发更新，那么在其间使用呢？会造成什么？答案就是：在一个更新周期还没有render之前，再次发起updateComponent，直接导致递归更新，死循环！相信我！等待你的，就是浏览器崩溃！！所以在他们里面🚫禁止🚫使用setState。

5、最后，渲染页面；再执行componentDidUpdate；它里面执行setState，会触发更新，不同的是render完成之后再发起的reRender。虽然这儿区别于上面两个生命周期中使用的情况，但是会一遍一遍的更新，这肯定也是不合理的，所以需要有条件的使用setState。

**最后呢**，简单介绍一下，退出页面的流程。此流程中， 首先**生命状态**也会被赋予值为UNMOUNTING， 然后执行componentWillUnmount，最后**生命状态**重置为null，做卸载页面组件和状态等处理。顺便提一下，在componentWillUnmount中使用setState，因为等待的是页面卸载，所以改变state是没有意义的。

- #### **总结：**  

  **生命周期中setState的使用情况：**

  ​		  无意义使用：componentWillMount，componentWillUnmount；

  ​		  有条件使用：componentDidUpdate；

  ​		  禁止使用：componentWillUpdate，shouldComponentUpdate；

  ​		  正常使用：componentWIllReceiveProps，componentDidMount。

  **生命周期中setState是否触发更新：**

  ​		  componentWillMount和componentWillReceiveProps中，setState会被react内部处理，而不触发render；

  ​		  其他生命周期均正常出发更新渲染。

#### 生命周期方法要如何对应到 Hook？

- `constructor`：函数组件不需要构造函数。你可以通过调用 `useState`来初始化 state。如果计算的代价比较昂贵，你可以传一个函数给 `useState`。
- `getDerivedStateFromProps`：改为 在渲染时安排一次更新。
- `shouldComponentUpdate`：详见 `React.memo`.
- `render`：这是函数组件体本身。
- `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`：`useEffect` Hook可以表达所有这些的组合。
- `getSnapshotBeforeUpdate`，`componentDidCatch` 以及 `getDerivedStateFromError`：目前还没有这些方法的 Hook 等价写法，但很快会被添加。

### 13 react性能优化是哪个周期函数

shouldComponentUpdate 这个⽅法⽤来判断是否需要调⽤render⽅法重新描绘dom。因为dom的描绘⾮常消耗性能，如果我们能在shouldComponentUpdate⽅法中能够写出更优化的dom diff 算法，可以极⼤的提⾼性能

### 14 react 的虚拟dom是怎么实现的，为什么虚拟dom会提⾼性能

为了实现虚拟DOM ，我们需要把每⼀种节点类型抽象成对象，每⼀种节点类型有⾃⼰的属性，也就是prop，每次进⾏diff 的时候， react 会先⽐较该节点类型，假如节点类型不⼀样，那么react 会直接删除该节点，然后直接创建新的节点插⼊到其中，假如节点类型⼀样，那么会⽐较prop 是否有更新，假如有prop 不⼀样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其⼦节点进⾏⽐较，⼀层⼀层往下，直到没有⼦节点

虚拟dom 相当于**在js 和真实dom 中间加了⼀个缓存**，利⽤dom diff 算法避免了没有必要的dom 操作，从⽽提⾼性能

具体实现步骤如下

- ⽤ JavaScript 对象结构表示 DOM 树的结构；然后⽤这个树构建⼀个真正的 DOM 树，插到⽂档当中
- 当状态变更的时候，重新构造⼀棵新的对象树。然后⽤新的树和旧的树进⾏⽐较，记录两棵树差异
- 把2所记录的差异应⽤到步骤1所构建的真正的DOM 树上，视图就更新

### 15 diff算法

- 把树形结构按照层级分解，只⽐较同级元素。
- 给列表结构的每个单元添加唯⼀的key 属性，⽅便⽐较。
- React 只会匹配相同 class 的 component （这⾥⾯的class 指的是组件的名字）
- 合并操作，调⽤ component 的 setState ⽅法的时候, React 将其标记为 - dirty .到每⼀个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
- 选择性⼦树渲染。开发⼈员可以重写shouldComponentUpdate 提⾼diff 的性能

#### react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不⼀样的时候

通常我们输出节点的时候都是map⼀个数组然后返回⼀个ReactNode ，为了⽅便react 内部进⾏优化，我们必须给每⼀个reactNode 添加key ，这个key prop 在设计值处不是给开发者⽤的，⽽是给react⽤的，⼤概的作⽤就是给每⼀个reactNode 添加⼀个身份标识，⽅便react进⾏识别，在重渲染过程中，如果key⼀样，若组件属性有所变化，则react 只更新组件对应的属性；没有变化则不更新，如果key不⼀样，则react先销毁该组件，然后重新创建该组件

### 16 react性能优化⽅案

重写shouldComponentUpdate 来避免不必要的dom操作
使⽤ production 版本的react.js
使⽤key 来帮助React 识别列表中所有⼦组件的最⼩变化

### 17 简述flux 思想

Flux 的最⼤特点，就是数据的"单向流动"。

- ⽤户访问 View
- View 发出⽤户的 Action
- Dispatcher 收到Action ，要求 Store 进⾏相应的更新
- Store 更新后，发出⼀个"change" 事件
- View 收到"change" 事件后，更新⻚⾯

### 18 说说你⽤react有什么坑点？

1. JSX做表达式判断时候，需要强转为boolean类型；如果不使⽤ !!b 进⾏强转数据类型，会在⻚⾯⾥⾯输出 0 。

   ```javascript
   render() {
   	const b = 0;
   	return <div>
   		{
   			!!b && <div>这是⼀段⽂本</div>
   		}
   	</div>
   }
   ```

2. 尽量不要在 componentWillReviceProps ⾥使⽤ setState，如果⼀定要使⽤，那么需要判断结束条件，不然会出现⽆限重渲染，导致⻚⾯崩溃

3. 给组件添加ref时候，尽量不要使⽤匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执⾏⼀次ref这个props，然后在以该组件的实例执⾏⼀次ref，所以⽤匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null

4. 遍历⼦节点的时候，不要⽤ index 作为组件的 key 进⾏传⼊

### 19 我现在有⼀个button，要⽤react在上⾯绑定点击事件，要怎么做？

```javascript
class Demo {
	render() {
		return <button onClick={(e) => {
			alert('我点击了按钮')
		}}>
		按钮
		</button>
	}
}
```

你觉得你这样设置点击事件会有什么问题吗？

由于onClick 使⽤的是匿名函数，所有每次重渲染的时候，会把该onClick 当做⼀个新的prop 来处理，会将内部缓存的onClick 事件进⾏重新赋值，所以相对直接使⽤函数来说，可能有⼀点的性能下降

修改：

```javascript
class Demo {
	onClick = (e) => {
		alert('我点击了按钮')
	}
	render() {
		return <button onClick={this.onClick}>
		按钮
		</button>
	}
```

### 20 给我介绍⼀下react（mvvm，虚拟dom，redux）

1. 以前我们没有jquery的时候，我们⼤概的流程是**从后端通过ajax获取到数据然后使⽤jquery⽣成dom结果然后更新到⻚⾯当中**，但是随着业务发展，我们的项⽬可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们⼜需要重新组装⼀次dom结构，然后更新⻚⾯，这样我们**⼿动同步dom和数据的成本就越来越⾼**，⽽且频繁的操作dom，也使我们**⻚⾯的性能慢慢的降低**。
2. 这个时候mvvm出现了，**mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以⼤⼤降低我们⼿动去维护dom更新的成本**，mvvm为react的特性之⼀，虽然react属于单项数据流，需要我们⼿动实现双向数据绑定。
3. 有了mvvm还不够，因为**如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了⻚⾯性能)的问题**，为了解决这个问题，react内部实现了⼀套**虚拟dom结构**，也就是⽤js实现的⼀套dom结构，他的作⽤是讲真实dom在js中做⼀套缓存，每次有数据更改的时候，react内部先使⽤算法，也就是鼎鼎有名的diff算法对dom结构进⾏对⽐，**找到那些我们需要新增、更新、删除的dom节点，然后⼀次性对真实DOM进⾏更新，这样就⼤⼤降低了操作dom的次数**。 那么diff算法是怎么运作的呢，⾸先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且⽤新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对⽐这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。
4. react**设计之初是主要负责UI层的渲染**，虽然每个组件有⾃⼰的state，state表示组件的状态，当状态需要变化的时候，需要使⽤setState更新我们的组件，但是，我们想通过⼀个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到⽗组件当中，让⽗组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要⼀直往下传，⽆疑加⼤了我们代码的复杂度，我们需要⼀个**状态管理中⼼**，来帮我们管理我们状态state。
5. 这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某⼀个state有变化的时候，依赖到这个state的组件就会进⾏⼀次重渲染，这样就解决了我们的我们需要⼀直把state往下传的问题。redux有action、reducer的概念，**action为唯⼀修改state的来源，reducer为唯⼀确定state如何变化的⼊⼝**，这使得redux的数据流⾮常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。
6. 后来，社区就出现了另外⼀套解决⽅案，也就是mobx，它推崇代码简约易懂，只需要定义⼀个可观测的对象，然后哪个组价使⽤到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，⽽且mobx内部也做好了是否重渲染组件的⽣命周期shouldUpdateComponent，不建议开发者进⾏更改，这使得我们使⽤mobx开发项⽬的时候可以简单快速的完成很多功能，连redux的作者也推荐使⽤mobx进⾏项⽬开发。但是，随着项⽬的不断变⼤，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以**针对于⼩项⽬来说，社区推荐使⽤mobx，对⼤项⽬推荐使⽤redux**

## 计算机基础

### 1 请简述一下TCP的三次握手和四次挥手协议

![1599053200896](/../../../../Typora图库/Web前端/三次握手.png)

![1599053232230](/../../../../Typora图库/Web前端/四次挥手.png)

**三次握手：**

（1）  第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

（2）  第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

（3）  第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？**

建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。
 （1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。
 （2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
 （3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。

**四次挥手：**

（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
 （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
 （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

**为什么要四次挥手？**

　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

### 2  简单介绍一下HTTP的长连接和短连接  

HTTP的长连接和短连接本质上是TCP长连接和短连接。**HTTP属于应用层协议**.

**短连接:**

浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

**长连接:**

当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

**TCP短连接:**

client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在 client/server间传递一次读写操作

 **TCP长连接:**

client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

### 3 TCP/IP协议

​      TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。

　　IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。

 　**TCP是面向连接的通信协议**，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

**TCP**报文首部格式：

![1599136506395](/../../../../Typora图库/Web前端/TCP报文首部.png)

ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。
FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

TCP怎么实现可靠传输

确认和重传机制：建立连接、发送包时的确认，运输过程中校验失败、丢包或延时发送端重传

数据排序：把数据分成很多包，按顺序进行传输

流量控制：滑动窗口和计时器

拥塞控制：慢启动、拥塞避免、快速重传、快速恢复

 

**流量控制**

作用于接收方，控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。由滑动窗口实现

- 滑动窗口：TCP进行流量控制的方式，接收方通过告诉对方自己的窗口大小，从而控制发送方的发送速度，以防止由于发送方发送速度过快而导致自己被淹没的现象

- 计时器：发送端收到为0的窗口后开启一个计时器，时间到了之后发包询问现在的滑动窗口，防止死锁（接收端发回的不为0的窗口的包丢失，双方相互等待）



**拥塞控制**

作用于网络，防止过多的数据注入到网络中，避免出现网络负载过大的情况。

- 拥塞：对网络中某一资源的需求超过了该资源所能提供的可用部分，影响到网络性能

- 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

- 拥塞窗口：发送方使用的流量控制，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

 

**慢启动和拥塞避免**

- 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。拥塞窗口一开始设为1 ，每收到一次确认，就让拥塞窗口变为原来的两倍，当窗口值为16时（慢启动门限），改为加法增大，每次+1，直到网络拥塞。拥塞时让新的慢启动门限设为拥塞时的一半，并把拥塞窗口置为1，再让他重复，这时一瞬间会将网络数据量大量降低。

- 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。

 

**快重传和快恢复**

- 快重传：接收方每收到一个失序的报文段（收完2后就收到了4说明3丢了）就立即发出包2的重复确认，这样可以让发送方尽早知道丢包了。发送端连续收到三个重复确认就立即重传3

- 快恢复：发送方收到3个连续确认时，把慢开始门限减半，把拥塞窗口的值置为慢开始门限的一半，实行拥塞避免算法，每次确认收到后+1

### 4 TCP和UDP有什么区别？  

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。

UDP（用户数据报协议）是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。

UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。

每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：

　　（1）源端口号；

　　（2）目标端口号；

　　（3）数据报长度；

　　（4）校验值。

使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。

TCP与区别

- TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。
- TCP提供可靠的服务，通过连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。
- TCP面向字节流；UDP面向报文。
- TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
- TCP首部开销字节；UDP的首部开销小，只有个字节。
- TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。

### 5 列举几种常见的协议，并简述他们的作用

ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
 TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
 HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
 DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
 DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

### 6 HTTP和HTTPS

HTTP：超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

HTTPS：HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。

 

HTTP特点：

\1.     无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作

\2.     无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。

\3.     基于请求和响应：基本的特性，由客户端发起请求，服务端响应

\4.     简单快速、灵活

\5.     通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性

 

HTTP协议传输数据以明文形式显示

针对无状态的一些解决策略：

场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。

\1.     通过Cookie/Session技术

\2.     HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接

 

HTTPS特点：

基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护

数据不是明文传输，而且HTTPS有如下特点：

\1.     内容加密：采用混合加密技术，中间者无法直接查看明文内容

\2.     验证身份：通过证书认证客户端访问的是自己的服务器

\3.     保护数据完整性：防止传输的内容被中间人冒充或者篡改

 

HTTP劫持

在正常的数据流中插入特定的网络数据报文，让客户端解释错误的数据，并以弹出新窗口的形式向使用者展示小广告或网页内容

步骤：

- 在TCP连接中标识HTTP协议链接；

- 改HTTP响应体；

- 将篡改后的数据包抢先回发到用户，这样后面的数据包在到达后会被直接丢弃。而客户端显示改后的网页

 

防范：

- 事前加密：HTTPS，防止明文传输被挟持，（但防不了DNS挟持）

- 事中加密：拆分HTTP请求数据包，运营商的旁路设备没有完整的TCP/IP协议栈，不能标记，web服务器有完整的TCP/IP协议栈，能把接收到的数据包拼成完整的HTTP请求，不影响服务

- 事后屏蔽：前端显示HTTP时对内容进行检测，在DOM结构发生变化时触发回调

 

DNS劫持：通过劫持DNS服务器，获得某域名的解析记录控制权，修改此域名的解析结果。把原来对A域名的访问转入B域名，返回错误的查询结果。可能是一些产品的持续的推广

区别：DNS劫持倾向于持续性，访问一个界面时强行推送广告，HTTP劫持频率多变，劫持过程也非常快，一般多出现于网站小尾巴

HTTPS挟持：伪造证书来进行挟持….



HTTP请求响应中断原因

网断了，网络阻塞，请求超时，浏览器出问题，服务器出问题

如何检查

检查网络，检查本地…

### 6 HTTPS实现原理（SSL握手）

**加密过程（SSL握手）**

![1599138130415](/../../../../Typora图库/Web前端/SSL握手.png)

\1.     client向server发送请求https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。

\2.     server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。

\3.     随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

\4.     客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。

\5.     客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。

\6.     传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。

\7.     服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。

\8.     客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。

\9.     同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。

### 7 HTTP通信传输

![1599138204301](/../../../../Typora图库/Web前端/HTTP通信传输.png)

​         客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的运用层协议，所以通信的过程其实是对应数据的入栈和出栈。  

![1599138249369](/../../../../Typora图库/Web前端/HTTP通信传输2.png)

报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。

### 8 DNS 

DNS 的作⽤就是通过域名查询到具体的 IP。DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。

### 9 对称加密与非对称加密

 **对称加密**：加密和解密用的是同一个密码或者同一套逻辑的加密方式。  这个密码也叫对称秘钥，其实这个对称和不对称指的就是**加密和解密用的秘钥是不是同一个**。 

nodejs 的 crypto 模块是一个专门用于各种加密的模块，可以用来取摘要（hash），加盐摘要（hmac），对称加密，非对称加密等。使用 crypto 进行对称加密很简单，crypto 模块提供了 Cipher 类用于加密数据，Decipher 用于解密。

**常见的对称加密算法有[DES](https://zh.wikipedia.org/wiki/資料加密標準)、[3DES](https://zh.wikipedia.org/wiki/3DES)、[AES](https://zh.wikipedia.org/wiki/高级加密标准)、[Blowfish](https://zh.wikipedia.org/wiki/Blowfish_(密码学))、[IDEA](https://zh.wikipedia.org/wiki/國際資料加密演算法)、[RC5](https://zh.wikipedia.org/wiki/RC5)、[RC6](https://zh.wikipedia.org/wiki/RC6)**


 **非对称加密**用的是一对秘钥，分别叫做公钥（public key）和私钥（private key），也叫非对称秘钥。非对称秘钥既可以用于加密还可以用于认证。

我相信肯定会有人和我一样有过这样的想法。其实对称加密只要保证加密的密码长度足够长的话，被加密的数据在拿不到密码本身的情况下一般是安全的。但是有个问题就是在实际应用中比如加密网络数据，因为加密和解密使用的是同一个秘钥，所以，服务器和客户端必然是要交换秘钥的，而正是因为非对称秘钥由于有一个交换秘钥这一过程可能会被中间人窃取秘钥，一旦对称加密秘钥被窃取，而且被分析出加密算法的话，那么传输的数据对于中间人来说就是透明的。所以**对称加密的致命性缺点就是无法保证秘钥的安全性**。

那么非对称加密就能保证秘钥的安全性了吗？是的，秘钥可以大胆的公开，被公开的秘钥就叫公钥。非对称加密的秘钥由加密算法计算得出，是成对的，**可以被公开的那个秘钥称之为公钥**，**不能公开的那个私有的秘钥叫私钥**。

非对称加密为什么安全的关键就是：**使用秘钥对中的一个秘钥加密，加密后的数据只能通过另一个秘钥解密**。也就是说使用一对秘钥中的公钥加密数据，只能通过另一个私钥解密出数据。或者反过来，使用一对秘钥中的私钥进行加密的数据，只能通过另一个公钥解密出来。由此可见，从**加密的角度来看，公钥和私钥其实作用是等同的，都可以用于加密或解密，只不过当我们使用非对称秘钥用于加密数据时往往是用公钥进行加密**。

**在 https 的加密中，加密传输的数据本身使用的是对称加密，加密对称秘钥时使用的非对称加密**。整个过程是这样的：server 端先生成一对非对称秘钥，将可以公开的公钥发送给 client 端，client 端也决定此次数据传输使用的对称加密算法和对称秘钥，然后利用 server 端给的公钥，对对称秘钥进行加密传输。server 端接受到 client 端发送的对称加密算法和秘钥后，server 端和 client 端的数据传输都使用这个对称秘钥和算法进行对称加密。整个过程中即便 server 端的公钥被中间人知道了内容，但是没有保存在 server 端的私钥，你是无法破译使用公钥加密的对称秘钥的。公钥原本就是可以被随意公开的，拿到也没用，解密需要的是私钥。非对称加密或者说公钥加密之所以能保证加密安全就是因为**私钥是保密不公开的，攻击者没有私钥无法破译**。

可能会有人有疑问：为什么需要使用非对称加密对对称秘钥加密呢？那是因为交换对称秘钥时可能被第三方窃取，对称秘钥被窃取了那对称加密就没意义了。还有为什么不直接使用非对称加密来加密传输内容而只是加密对称秘钥？非对称加密不是对称加密更安全吗？这就和对称加密与非对称加密的特点有关系了。

**非对称加密和对称加密对比**

1. 对称加密是一个秘钥，非对称加密是一对，两个秘钥
2. 非对称加密比起对称加密更安全，因为不存在秘钥泄露问题，公钥即便被知道也没关系
3. 由于使用非对称加密在计算上特别复杂，所以一般来说对称加密的加密解密的速度相对于非对称加密快很多
4. 非对称秘钥还可以用于认证

由于以上第三条，所以在 https 中传输数据时不会使用非对称加密加密传输数据，传输数据时有可能数据本身很大，那样的话非对称加密更耗时了，所以传输数据时不会使用非对称加密的方式加密。

**常见的非对称加密有 RSA、ECC（椭圆曲线加密算法）、Diffie-Hellman、El Gamal、DSA（数字签名用）。**

**非对称密钥认证**

非对称加密有时也叫**公钥加密**，而非对称秘钥认证也被称为**私钥认证**。我们说使用非对称秘钥对数据进行认证其实就是说确认一个数据是否有没有被篡改过。非对称秘钥除了用于加密数据，用于认证也是非常广泛的，比如手机 apk 的签名， https 中的证书。

原理很简单：比如现在我要认证一个 apk 的代码是否被串改过，首先准备一对非对称秘钥，一般来自权威机构。官方在打包 apk 时不但包含应用代码，还带上一个签名，这个签名这里简单理解为使用私钥对应用代码的 hash 值加密后的数据。在安装 apk 时，android 系统会提取 apk 中的签名，使用公钥解密签名得到原始应用代码的 hash，然后和原始应用代码的 hash 进行比对，如果内容相同，那么 apk 没有被篡改过。如果 apk 的应用代码被第三方修改了，那么从签名中解密出来的 hash 和应用代码的 hash 肯定是不同的。所以可以起到确保应用代码没有篡改，也就是**认证**。

认证的关键其实是因为签名的存在，签名必须保证能拿到 apk 原始应用代码的 hash。

可能有人看了上面对 apk 认证的过程会有这么一个疑问：使用私钥对内容加密可以达到认证的目的，那能不能使用公钥加密来认证呢？答案肯定是不能的，如果你使用公钥对内容进行加密，那中间人要篡改你的内容，伪造签名超简单，直接使用公钥对伪造后的内容的 hash 加密就可以了。所以使用非对称秘钥可以用于认证的另一个关键就是私钥是不公开的，中间人没法获取私钥，也就没法伪造签名。

**hash 算是加密吗？**

我觉得不算，hash 是不可逆的，加密应该是可以根据加密后的数据还原的。

**base 64 算是加密吗？**

是对称加密，对称秘钥就是 base 64 字符码表。

**非对称加密绝对安全吗？**

没有什么加密是绝对安全的，非对称加密存在交换公钥时公钥被篡改的问题。

### 10 基于 Token 的身份验证

 比起传统的身份验证方法，Token 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。 

#### 传统身份验证的方法

**HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用**。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。

解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。

上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。

#### 基于 Token 的身份验证方法

使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

#### JWT

实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分：

- header
- payload
- signature

中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
```

header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。

```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

上面的内容要用 Base64 的形式编码一下，所以就变成这样：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段：

- iss：Issuer，发行者
- sub：Subject，主题
- aud：Audience，观众
- exp：Expiration time，过期时间
- nbf：Not before
- iat：Issued at，发行时间
- jti：JWT ID

比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。

```json
{
 "iss": "ninghao.net",
 "exp": "1438955445",
 "name": "wanghao",
 "admin": true
}
```

使用 Base64 编码以后就变成了这个样子：

```
eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ
```

JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。

- header
- payload
- secret

```js
var encodedString = base64UrlEncode(header) + "." + base64UrlEncode(payload); 
HMACSHA256(encodedString, 'secret');
```

处理完成以后看起来像这样：

```
SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
```

最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
```

客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。

### 11 列举几种常见的协议，并简述他们的作用

**ICMP协议**：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
 **TFTP协议**：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
 **HTTP协议**：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
 **DHCP协议**：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
 **NAT协议**：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
 **DHCP协议**：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

**ARP**：是地址解析协议，作用是完成IP地址到硬件地址的映射。
**RARP**：是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。

 **TLS**：安全传输层协议用于在两个通信应用程序之间提供保密性和数据完整性。 

**TCP对应的协议：**
 （1） FTP：定义了文件传输协议，使用21端口。
 （2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
 （3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
 （4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
 （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。

 **UDP对应的协议：**
 （1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
 （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
 （3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。