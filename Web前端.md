---
typora-root-url: D:\Typora文件库\Typora图库\Web前端
---

# 基础

## ⼀、HTML、HTTP、web综合问题

### 1 前端需要注意哪些SEO

- 合理的**title 、description 、keywords ：搜索对着三项的权重逐个减⼩**， title值强调重点即可，重要关键词出现不要超过2次，⽽且要靠前，不同⻚⾯title 要有所不同； description 把⻚⾯内容⾼度概括，⻓度合适，不可过分堆砌关键词，不同⻚⾯description 有所不同； keywords 列举出重要关键词即可
- 语义化的HTML 代码，符合**W3C规范**：语义化代码让搜索引擎容易理解⽹⻚
- 重要内容HTML 代码放在最前：搜索引擎抓取HTML 顺序是从上到下，有的搜索引擎对抓取⻓度有限制，保证重要内容⼀定会被抓取
- 重要内容不要⽤js 输出：爬⾍不会执⾏js获取内容
- 少⽤iframe ：搜索引擎不会抓取iframe 中的内容
- ⾮装饰性图⽚必须加alt
- 提⾼⽹站速度：⽹站速度是搜索引擎排序的⼀个重要指标

### 2 `<img>` 的title 和alt 有什么区别？物理元素和逻辑元素；b和strong,i与em的区别

title 和alt：

- 通常当⿏标滑动到元素上的时候显示
- alt 是`<img>` 的特有属性，是图⽚内容的等价描述，**⽤于图⽚⽆法加载时显示**、读屏器阅读图⽚。可提图⽚⾼可访问性，**除了纯装饰图⽚外都必须设置有意义的值**，搜索引擎会重点分析。

**物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。** 

**物理元素所强调的是一种物理行为**，比如说我把一段文字用b标记加粗了，我的意思是告诉浏览器应该给我加粗了显示这段文字 ， b是Bold(加粗)的简写，所以这个B标记所传达的意思只是加粗，没有任何其它的作用。  而Strong我们从字面理解就可以知道他是强调的意思，所以我们**用这个标记向浏览器传达了一个强调某段文字的消息**，而这个Strong就是我们所说的逻辑元素，他是**强调文档逻辑的，并非是通知浏览器应该如何显示**。 

用在网页上，默认情况下它们起的均是加粗字体的作用，二者所不同的是，`<b>`标签是一个实体标签，它所包围的字符将被设为bold（粗体），而`<strong>`标签是一个逻辑标签，它的作用是加强字符的语气，一般来说，加强字符的语气是通过将字符变为bold（粗体）来实现的。

 *当盲人使用屏幕阅读器上时能够明显能体现出B与Strong的不同。遇到B时与处理一般词语一样进行阅读，遇到Strong时回加重与停顿*. 

并不是说有了strong，就淘汰了b，b就因为自己表示的是字体加粗，恰巧跟strong默认情况下强调的效果一致，其实这个strong完全可以定义成别的样式的强调效果。但是**为了符合现在W3C的标准，还是推荐使用strong标签**。

- strong : 视觉效果加粗。HTML语义为强调，表示语气上的强调、加重。
-  b标签：视觉效果加粗。本身不具备HTML语义。

- em :斜体强调标签，更强烈强调，表示内容的强调点
- i标签：视觉效果斜体，本身不具备HTML语义。

### 3 HTTP的⼏种请求⽅法⽤途

**GET ⽅法：发送⼀个请求来取得服务器上的某⼀资源**
**POST ⽅法：向URL 指定的资源提交数据或附加新的数据**（例如提交表单或者上传文件）。POST请求可能会导致新的资源的建立和/或已有资源的修改。 
**PUT ⽅法**： 从客户端向服务器传送的数据取代指定的文档的内容。 跟POST ⽅法很像，也是向服务器提交数据。但是，它们之间有不同。**PUT 指定了资源在服务器上的位置，⽽POST 没有**。
HEAD ⽅法：只请求⻚⾯的⾸部
DELETE ⽅法：删除服务器上的某资源
OPTIONS ⽅法：它⽤于获取当前URL 所⽀持的⽅法。如果请求成功，会有⼀个Allow 的头包含类似“GET,POST” 这样的信息
TRACE ⽅法：TRACE ⽅法被⽤于激发⼀个**远程的，应⽤层**的请求消息回路
**CONNECT ⽅法：把请求连接转换到透明的TCP/IP 通道**

**fetch发送2次请求的原因**：**fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？**

原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。



**Post和Get有什么区别？**  

1、 GET主要用于从服务器查询数据，POST用于向服务器提交数据
2、 GET通过URL传递数据，POST通过http请求体传递数据
3、 GET传输数据量有限制，不能大于2kb，POST传递的数据量较大，一般大量的数据提交都是通过POST方式
4、 GET安全性较低，容易在URL中暴漏数据，POST安全性较高 
5、GET请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以**可以使用缓存**；POST不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。

### 4 从浏览器地址栏输⼊url到显示⻚⾯的步骤

#### 基础版本

- 浏览器根据请求的URL 交给DNS 域名解析，把url解析为IP ，和IP地址建⽴TCP链接，向服务器发送HTTP请求；
- 服务器接收请求，查库，读⽂件等，拼接好返回的HTTP响应，返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等），开始渲染；
- 浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，解析html为dom （加载额外的css和js），解析css 为css-tree，建⽴相应的内部数据结构（如HTML 的DOM ）；
- 载⼊解析到的资源⽂件，渲染⻚⾯，完成。

#### 详细版

1. 在浏览器地址栏输⼊URL
2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   1. 如果资源未缓存，发起新请求
   2. 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。
   3. 检验新鲜通常有两个HTTP头进⾏控制Expires 和Cache-Control ：
     - HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期
     - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最⼤新鲜时间

3. 浏览器解析URL获取协议，主机，端⼝，path
4. 浏览器组装⼀个HTTP（GET）请求报⽂
5. 浏览器获取主机ip地址，过程如下：
   1. 浏览器缓存
   2. 本机缓存
   3. hosts⽂件
   4. 路由器缓存
   5. ISP DNS缓存
   6. DNS递归查询（可能存在负载均衡导致每次IP不⼀样）

6. 打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，**三次握⼿**如下：
   1. 客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝
   2. 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
   3. 客户端发送ACK=Y+1， Seq=Z
7. TCP链接建⽴后发送HTTP请求
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序
9. 服务器检查HTTP请求头是否包含**缓存**验证信息。如果验证缓存新鲜，返回304等对应状态码
10. 处理程序读取完整请求并准备**HTTP响应**，可能需要查询数据库等操作
11. 服务器将响应报⽂通过TCP连接发送回浏览器
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的**四次握⼿**如下：
    1. 主动⽅发送Fin=1， Ack=Z， Seq= X报⽂
    2. 被动⽅发送ACK=X+1， Seq=Z报⽂
    3. 被动⽅发送Fin=1， ACK=X， Seq=Y报⽂
    4. 主动⽅发送ACK=Y， Seq=X报⽂
13. 浏览器检查**响应状态码**：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，进⾏缓存
15. 对响应进⾏解码（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML⽂档）
17. 解析HTML⽂档，构建DOM树，下载资源，构造CSSOM树，执⾏js脚本。这些操作没有严格的先后顺序。
18. 构建DOM树：
    1. Tokenizing：根据HTML规范将字符流解析为标记
    2. Lexing：词法分析将标记转换为对象并定义属性和规则
    3. DOM construction：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图⽚、样式表、js⽂件，启动下载
20. 构建CSSOM树：
    1. Tokenizing：字符流转换为标记流
    2. Node：根据标记创建节点
    3. CSSOM：节点创建CSSOM树
21. 根据DOM树和CSSOM树构建渲染树:
    1. 从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身不可⻅的标签。2)被css隐藏的节点，如display: none
    2. 对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤
    3. 发布可视节点的内容和计算样式
22. js解析如下：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此时document.readystate为loading
    2. HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的⽂档内容
    3. 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤document.write()，它们可以访问⾃⼰script和之前的⽂档元素
    4. 当⽂档完成解析，document.readState变成interactive
    5. 所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤document.write()
    6. 浏览器在Document对象上触发DOMContentLoaded事件
    7. 此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊并且所有异步脚本完成载⼊和执⾏，document.readState变为complete，window触发load事件
23. 显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）

#### 详细简版

1. 从浏览器接收url 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程之间的关系）
2. 开启⽹络线程到发出⼀个完整的HTTP 请求（这⼀部分涉及到dns查询， TCP/IP 请求，五层因特⽹协议栈等知识）
3. 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
4. 后台和前台的HTTP 交互（这⼀部分包括HTTP 头部、响应码、报⽂结构、cookie 等知识，可以提下静态资源的cookie 优化，以及编码解码，如gzip 压缩等）
5. 单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catchcontrol
    等）

6. 浏览器接收到HTTP 数据包后的解析流程（解析html -词法分析然后解析成dom 树、解析css ⽣成css 规则树、合并成render 树，然后layout 、painting 渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded 和DOMContentLoaded 等）
7. CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）
8. JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作⽤域链、回收机制等等）
9. 其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）

### 5 ⽹站性能优化、iframe缺点

- 禁⽌使⽤iframe （阻塞⽗⽂档onload 事件）
  - **iframe 会阻塞主⻚⾯的Onload 事件**
  - **搜索引擎的检索程序⽆法解读这种⻚⾯**，不利于SEO
  - iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以**会影响⻚⾯的并⾏加载**
  - 使⽤iframe 之前需要考虑这两个缺点。如果需要使⽤iframe ，最好是通过javascript
  - **动态给iframe 添加src 属性值**，这样可以绕开以上两个问题
- 禁⽌使⽤gif 图⽚实现loading 效果（降低CPU 消耗，提升渲染性能）
- 使⽤CSS3 代码代替JS 动画（尽可能避免重绘重排以及回流）
- 对于⼀些⼩图标，可以使⽤**base64位编码**，以减少⽹络请求。但不建议⼤图使⽤，⽐较耗费CPU

  - ⼩图标优势在于：减少HTTP 请求；避免⽂件跨域；修改及时⽣效
- ⻚⾯头部的`<style></style> <script></script>` 会阻塞⻚⾯；（因为 Renderer进程中 JS 线程和渲染线程是互斥的）
- ⻚⾯中空的 href 和 src 会阻塞⻚⾯其他资源的加载 (阻塞下载进程)
- 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。
- 前端模板 JS+数据，减少由于HTML 标签导致的带宽浪费，前端⽤变量保存AJAX请求结果，每次操作本地变量，不⽤请求，减少请求次数
- ⽤innerHTML 代替DOM 操作，减少DOM 操作次数，优化javascript性能
- 当需要设置的样式很多时设置className ⽽不是直接操作style
- 少⽤全局变量、缓存DOM 节点查找的结果。减少IO 读取操作
- 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
- 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 

#### 优化图片加载

- **图⽚懒加载**，在⻚⾯上的未可视区域可以添加⼀个滚动事件，判断图⽚位置与浏览器顶端的距离与⻚⾯的距离，如果前者⼩于后者，优先加载。
- 如果为幻灯⽚、相册等，可以使⽤**图⽚预加载**技术，将当前展示图⽚的前⼀张和后⼀张优先下载。
- 如果图⽚为css图⽚，可以使⽤CSSsprite ， SVGsprite ， Iconfont 、Base64 等技术。
- 如果图⽚过⼤，可以**使⽤特殊编码的图⽚**，加载时会先加载⼀张压缩的特别厉害的缩略图，以提⾼⽤户体验。
- 如果图⽚展示区域⼩于图⽚的真实⼤⼩，则因在服务器端根据业务需要先⾏进⾏**图⽚压缩**，图⽚压缩后⼤⼩与展示⼀致。

### 6 HTTP状态码及其含义

**1XX ：信息状态码**

- 100 Continue 继续，⼀般在发送post 请求时，已发送了http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
-  **101 是指服务器将按照其上的头信息变为一个不同的协议。** 

**2开头 （请求成功）表示成功处理了请求的状态代码。**

<u>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</u> 
201   （已创建）  请求成功并且服务器创建了新的资源。 
202   （已接受）  服务器已接受请求，但尚未处理。 
203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 
<u>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。</u> 
205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。
<u>206   （部分内容）  服务器成功处理了部分 GET 请求。</u>

**3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。**

300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
<u>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</u>
<u>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</u>
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
<u>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</u> 
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

<u>400   （错误请求） 服务器不理解请求的语法。</u> 
<u>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</u> 
<u>403   （禁止） 服务器拒绝请求。</u>
404   （未找到） 服务器找不到请求的网页。
405   （方法禁用） 禁用请求中指定的方法。 
406   （不接受） 无法使用请求的内容特性响应请求的网页。 
407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408   （请求超时）  服务器等候请求时发生超时。 
409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 
411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 
412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 
415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 
416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417   （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

**5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**

<u>500   （服务器内部错误）  服务器遇到错误，无法完成请求。</u> 
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
<u>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</u> 
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

#### 301和302

301：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

302：请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

两者都是一个POST请求经过 301/302 后会被浏览器转为GET请求

缓存： 对于301请求，浏览器是默认给一个很长的缓存。而302是不缓存的。 

搜索引擎：

301: 旧地址A的资源不可访问了(永久移除), 重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。

302: 旧地址A的资源仍可访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取B网址内容，但是会将网址保存为A的。

安全：

 尽量使用301跳转，以防止网址劫持！ 

 一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。 

####  **什么情况下会返回304状态码？** (http请求图)

 ![Alt text](/../../../../Typora图库/Web前端/http请求图.png) 

**1、是否禁止缓存**

**禁止缓存**指的是缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。

在请求头中，`Cache-Control: no-store`与`Pragma: no-cache`都可以禁止缓存，但两者也有区别

- `Pragma: no-cache`可以兼容`http 1.0` ，而`Cache-Control: no-store`是`http 1.1`提供的。
- 因此，`Pragma: no-cache`可以应用到`http 1.0`和`http 1.1`,而`Cache-Control: no-store`只能应用于`http 1.1`。

**2、是否检查本地副本是否过期**

**是否检查本地版本是否过期**主要由`Cache-Control` 的 `no-cache`和`must-revalidate`这两个可选值控制，其中：

> - `no-cache`: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。
> - `must-revalidate`：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。

**3、本地副本是否过期**

想要知道本地副本是否过期，我们就需要了解**缓存的过期机制**：

(1)、过期机制中，最重要的指令是 `max-age=`,它表示资源能够被缓的最大时间；它通常会和`must-revalidate`一起使用，使用起来就像下面这样：

```js
Cache-Control: max-age=60, must-revalidate
```

(2)、如果不含有`max-age`属性，则会去查看是否包含`Expires`属性，，通过比较`Expires`的值和头里面`Date`属性的值来判断是否缓存还有效。



![Alt text](/../../../../Typora图库/Web前端/Expires.png)

(3)、如果 `max-age` 和 `expires` 属性都没有，找找头里的` Last-Modified`信息。如果有，缓存的寿命就等于头里面 `Date`的值减去`Last-Modified`的值除以10.



![Alt text](/../../../../Typora图库/Web前端/Last-modified.png)



**4、如果本地副本没有过期**

如果本地副本没有过期，则会直接重缓存中读取资源，并返回200状态码。

**5、如果本地副本过期**

如果本地副本过期，则会进行**到源服务器进行有效性校验的前期准备**。

首先，会在请求头里寻找`If-None-Match`字段，其值为服务器上次返回的`ETag`响应头的值:

![Alt text](/../../../../Typora图库/Web前端/if-none-match.png)

![Alt text](/../../../../Typora图库/Web前端/etag.png)



如果请求头里没有`If-None-Match`字段，则会在请求头中寻找`If-Modified-Since`字段，其值为服务器上次返回的`Last-Modified`响应头中的日期值：

![Alt text](/../../../../Typora图库/Web前端/last-modified2.png)

![Alt text](/../../../../Typora图库/Web前端/if-modified-since.png)

如果`If-None-Match`与`If-Modified-Since`都没有，则会直接向服务器请求数据。

**6、到源服务器进行有效性校验**

如果请求头中带有`If-None-Match`或`If-Modified-Since`，则会到源服务器进行有效性校验，**如果源服务器资源没有变化，则会返回304；如果有变化，则返回200；**

#### 私有缓存和公共缓存

在`Cache-Control`还有两个值：`private`与`public`，其中：

- `public` 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了 `public` ，则一些通常不被中间人缓存的页面（因为默认是 `private`）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。
- 而 `private` 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

#### Etag与Cache-Control的区别

Cache-Control: max-age=1000 ：请求完成，响应完毕后，响应体保存1000秒，时间一到缓存就没有了，需要从新请求服务器，去拿对应的数据。1000秒期间，浏览器不会再次发送任何请求，只在本地缓存拿数据。

ETag：对比本地与服务器端的MD5返回值，若一致，不需要重新加载响应体，若不一致（说明文本发生了改变）则重新下载响应体。当数据没发生改变的时候，每次请求虽然不会重新加载响应体，但是还是发送了请求。

如果资源没过期，前者根本不会发送请求，后者会发送请求。

#### **HTTP缓存：强缓存**，协商缓存

 web缓存主要有：数据库缓存、服务器缓存（代理服务器缓存、CDN缓存），浏览器缓存 

 浏览器缓存包括：http缓存、cookie缓存、local storage本地缓存 

浏览器缓存根据是否需要重新向服务器发起请求来分类，分为**强缓存**和**协商缓存**。当客户端请求某个资源时，获取缓存的流程如下

- 先根据这个资源的⼀些 http header 判断它是否命中**强缓存，如果命中，则直接从本地获取缓存资源**，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另⼀些request header验证这个资源是否命中**协商缓存，称为http 再验证，如果命中，服务器将请求返回，但不返回资源，⽽是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源**；
- 强缓存和协商缓存共同之处在于，**如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会**。
- 当**协商缓存也没命中时，服务器就会将资源发送回客户端**。
- 当 ctrl+f5 强制刷新⽹⻚时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 f5 刷新⽹⻚时，跳过强缓存，但是会检查协商缓存；

**强缓存**

- 实现强缓存可以通过两种响应头实现： Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求， **state code 为 200**
- Expires （该字段是 http1.0 时的规范，值为⼀个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
- Cache-Control:max-age （该字段是 http1.1 的规范，强缓存利⽤其 max-age 值来判断缓存资源的最⼤⽣命周期，它的值单位为秒）

**协商缓存**

- 如果缓存过期了，我们就可以使⽤协商缓存来解决问题。协商缓存需要请求，如果**缓存有效会返回 304**

  **Last-Modified 和 If-Modified-Since**

  - If-Modified-Since （通过⽐较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
  - Last-Modified 表示本地⽂件最后修改⽇期， If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该⽇期后资源是否有更新，有更新的话就会将新的资源发送回来。
  - 但是如果在本地打开缓存⽂件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1出现了 ETag

  **ETag 和 If-None-Match**

  - ETag （表示资源内容的唯⼀标识，随服务器response 返回）

  - If-None-Match （服务器通过⽐较请求头部的If-None-Match 与当前资源的ETag 是否⼀致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

  - ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且ETag 优先级⽐ Last-Modified ⾼

  - 不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者 后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。

    ETag解决了Last-Modified使用时可能出现的资源的时间戳变了但内容没变及如果再一秒钟以内资源变化但Last-Modified没变的问题，感觉ETag更加稳妥。

**选择合适的缓存策略**

对于**⼤部分的场景都可以使⽤强缓存配合协商缓存**解决，但是在⼀些特殊的地⽅可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使⽤ Cache-control: no-store ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使⽤ Cache-Control: no-cache 并配合 ETag 使⽤，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000 并配合策略缓存使⽤，然后对⽂件进⾏指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件



### 7 语义化的理解

HTML **语义化就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析**

引入语义化标签的好处主要有下列三点：

- 比`<div>`标签有更加丰富的含义，方便开发与维护
- 搜索引擎能更方便的识别页面的每个部分
- 方便其他设备解析（如移动设备、盲人阅读器等）

对于HTML体系而言，Web语义化是指使用语义恰当的标签，使页面有良好的结构，让页面元素有含义，便于被浏览器、搜索引擎解析、利于SEO。通常我们所说的HTML应该是完全脱离表现信息的，其中的标签应该都是语义化地定义了文档的结构。 代码示例： 

```html
<html>
    <body>
        <article>
            <header>
                <h1>h1 - WEB 语义化</h1>
            </header>
            <nav>
                <ul>
                    <li>nav1 - HTML语义化</li>
                    <li>nav2 - CSS语义化</li>
                </ul>
            </nav>
            <section>
                section1 - HTML语义化
            </section>
            <section>
                section2 - CSS语义化
            </section>
            <time datetime="2018-03-23" pubdate>time - 2018年03月23日</time>
            <footer> footer - by 小维</footer>
        </article>
    </body>
</html>
```

 html语义化标签包括 body, article, nav, aside, section, header, footer, hgroup, 还有 h1-h6 address等。 

标签：`header, nav, aside, footer, article, section`

- header

   通常被放置在页面或者页面中某个区块元素的顶部，包含整个页面或者区块的标题、简介等信息，**起到引导与导航的作用**。  我们不但可以放置页面或者页面中某个区块的标题，还可以放置搜索表单、logo图片等元素，按照最新的W3C标准，我们还可以放置`<nav>`导航栏。 

   一个文档中可以包含一对或者一对以上的`<header>`标签。标签的位置是次要的，不一定非要显示在页面的上方，我们可以为任何需要的区块标签添加`<header>`元素 

  ```html
  <header>
      ![](images/logo.png)
      <h1>**信息科技有限公司</h1>
  </header>
  ```

- nav

   **表示页面的导航，可以通过导航连接到网站的其他页面，或者当前页面的其它部分。** 

   `<nav>`不但可以作为页面独立的导航区域存在，而且我们可以在`<header>`标签中使用。此外，`<nav>`标签还可以显示在侧边栏中。由此可见，一个页面之中可以有多个`<nav>`标签。 
   
   根据HTML5标准，`<nav>`标签只用于页面的主要导航部分。因为搜索引擎或者屏幕阅读器会根据`<nav>`标签来确定网站的主体内容，所以并不是任意一组超链接都适合放置在`<nav>`标签中,我们只要将主要的，基本的链接组放进`<nav>`即可,对于有辅助性的页脚链接则不推荐使用`<nav>`标签。
   
    值得我们注意的是,**HTML5规范不允许将`<nav>`标签嵌套在`<address>`标签中使用**。 
   
   ```html
   <header>
      ![](images/logo.png)
      <h1>**信息科技有限公司</h1>
      <nav>
          <li><a href="#">首页</a></li>
          <li><a href="example.html">客户案例</a></li>
          <li><a href="service_one.html">技术服务</a></li>          
          <li><a href="aboutus_one.html">关于我们</a></li>
          <li><a href="connection.html">联系我们</a></li>
      </nav>
   </header>
   ```
   
- aside

    所包含的内容不是页面的主要内容、具有独立性，是**对页面的补充**。  一般使用在页面、文章的侧边栏、广告、友情链接等区域。 

   ```html
   <article>
      <h1>HTML5学习之语义化标签</h1>
      <p>....正文.....</p>
      <aside>
          <h2>什么是语义化标签</h2>
          <p>语义化标签就是......</p>
      </aside>
   </article>
   ```

- footer

    一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。 

    跟`<header>`标签一样，`<footer>`标签的使用个数没有限制，可以在任意需要的区块底部使用。 

   ```html
   <footer>
       <small>
           版权所有 © 2016-2017 **信息科技有限公司
       </small>
   </footer>
   ```

- article

    表示包含于一个文档、页面、应用程序或网站中的一段独立的内容，可以被独立的发布或者重新使用文章标记标签。 

    应该使用在**相对比较独立、完整的的内容区块** . 通常情况下，一个`<article>`元素包括标题、正文和脚注。和`<nav>`标签一样，该标签同样不能用在`<address>`标签中 

    `<article>`标签还可以嵌套使用，但是它们必须是部分与整体的关系。 

   ```html
   <article>
      <h1>HTML5学习之语义化标签</h1>
      <p>....正文.....</p>
      <footer>版权所有*伪版必究</footer>
   </article>
   ```

- section

     是一个**主题性的内容分组**，通常用于**对页面进行分块或者对文章等进行分段** 。

    `<section>`标签所包裹的是有一组相似的主题的内容，可以用这个标签来实现文章的章节、标签式对话框中的各种标签页等类似的功能。`<section>`通常包含一个头部`<header>`、可能还会包含一个尾部`<footer>`。
    
    ```html
    <article>
        <h1>JavaScript框架</h1>
        <p>Javascript框架是指以Javascript语言为基础搭建的编程框架。</p>
        <section>
            <h2>angular.Js<h2>
            <p>angular.Js是一款优秀的前端JS框架</p>
        </section>
        <section>
            <h2>Vue.js<h2>
            <p>Vue.js是用于构建交互式的Web界面的库</p>
        </section>
        <section>
            <h2>Node.Js<h2>
            <p>Node.js就是运行在服务端的JavaScript</p>
        </section>
    </article>
    ```

`<div>、<section>、<article>`三者的比较：

- `<div>`：应用广泛，只要我们想为一个区域定义一个样式或者为其添加JS行为，就可以使用div标签
- `<section>`：包含的内容是一个明确的主题，通常有标题区域
- `<article>`:如果我们的页面中需要一个单独的模块来实现一个单独的功能，就用`<article>`，其他的时候都用`<section>`。

### 8 渲染引擎和JS 引擎

主要分成两部分：渲染引擎( layout engineer 或Rendering Engine )和JS 引擎

- 渲染引擎：**负责取得⽹⻚的内容**（ HTML 、XML 、图像等等）、**整理讯息**（例如加⼊CSS 等），以及**计算⽹⻚的显示⽅式**，然后会**输出⾄显示器或打印机**。浏览器的内核的不同对于⽹⻚的语法解释会有不同，所以渲染的效果也不相同。所有⽹⻚浏览器、电⼦邮件客户端以及其它需要编辑、显示⽹络内容的应⽤程序都需要内核

- JS 引擎：解析和执⾏javascript 来实现⽹⻚的动态效果

最开始渲染引擎和JS 引擎并没有区分的很明确，后来JS引擎越来越独⽴，内核就倾向于只指渲染引擎

### 9 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下？

在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤户机器上的缓存⽂件

原理： HTML5 的离线存储是**基于⼀个新建的.appcache ⽂件的缓存机制**(不是存储技术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像cookie ⼀样被存储了下来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示

如何使⽤：

- ⻚⾯头部像下⾯⼀样加⼊⼀个manifest 的属性；
- 在cache.manifest ⽂件的编写离线存储的资源
- 在离线状态时，操作window.applicationCache 进⾏需求实现

浏览器是怎么对HTML5 的离线储存资源进⾏管理和加载的呢：

- 在线的情况下，浏览器发现html 头部有manifest 属性，它会请求manifest ⽂件
  - 如果是第⼀次访问app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏离线存储。
  - 如果已经访问过app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的manifest ⽂件与旧的manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。
- 离线的情况下，浏览器就直接使⽤离线存储的资源。

### 10  cookies ， sessionStorage 、 localStorage、IndexedDB

- cookie 是**⽹站为了标示⽤户身份⽽储存在⽤户本地终端（Client Side）上的数据（通常经过加密）**
- cookie数据**始终在同源的http请求中携带**（即使不需要），记会在浏览器和服务器间来回传递
- sessionStorage 和localStorage 不会⾃动把数据发给服务器，**仅在本地保存**
-  IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许**储存大量数据，提供查找接口，还能建立索引**。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 更接近 NoSQL 数据库。 
- 存储⼤⼩：

  - cookie 数据⼤⼩不能超过4k

  - sessionStorage 和localStorage 虽然也有存储⼤⼩的限制，但⽐cookie ⼤得多，可以达到5M或更⼤
- 有期时间：
	- localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据
	- sessionStorage 数据在当前浏览器窗⼝关闭后⾃动删除
	- cookie 设置的cookie 过期时间之前⼀直有效，即使窗⼝或浏览器关闭

![](/../../../../Typora图库/Web前端/cookie和localSrorage、session、indexDB.png)



### 11 **cookie ，session，token**  

#### cookie

cookie由服务器生成，发送给浏览器，浏览器把cookie以KV形式存储到某个目录下的文本文件中，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。所以每个域的cookie数量是有限制的。

**cookie 安全性，响应头设置cookie**

ajax请求时是不会自动带上cookie的，要是想让它带上的会，必须要设置**withCredentials为true**。

有两种方法可以确保 `Cookie` 被安全发送，并且不会被意外的参与者或脚本访问：**`Secure` 属性和`HttpOnly` 属性**。  

- 标记为 `Secure` 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 `Secure` 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，`Secure` 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。  从 Chrome 52 和 Firefox 52 开始，**不安全的站点（`http:`）无法使用Cookie的 `Secure` 标记**。 
- JavaScript {{domxref（“ Document.cookie”）}} API 无法访问带有 `HttpOnly` 属性的cookie；此类 Cookie 仅作用于服务器。例如，**持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 `HttpOnly` 属性**。此预防措施有助于缓解跨站点脚本（XSS）)攻击。 

![](/../../../../Typora图库/Web前端/cookie安全性.png)

#### session

session从字面上讲，就是会话。服务器要知道当前请求发给自己的是谁。为了做这种区分，服务器就是要给每个客户端分配不同的"身份标识"，然后客户端每次向服务器发请求的时候，都带上这个”身份标识“，服务器就知道这个请求来自与谁了。 至于客户端怎么保存这个”身份标识“，可以有很多方式，对于浏览器客户端，大家都采用cookie的方式。

**过程(服务端session + 客户端 sessionId)**

 ![session](/../../../../Typora图库/Web前端/服务端session + 客户端 sessionId.png) 

1. 用户向服务器发送用户名和密码

2. 服务器验证通过后,在当前对话(session)里面保存相关数据,比如用户角色, 登陆时间等;

3. 服务器向用户返回一个`session_id`, 写入用户的`cookie`

4. 用户随后的每一次请求, 都会通过`cookie`, 将`session_id`传回服务器

5. 服务端收到 `session_id`, 找到前期保存的数据, 由此得知用户的身份

**缺点**

单机当然没问题， 如果是服务器集群， 或者是跨域的服务导向架构， 这就要求session数据共享，每台服务器都能够读取session。 

 共享Session：将Session Id 集中存储到一个地方，所有的机器都来访问这个地方的数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败； 

 另一种方案是服务器索性不保存session数据了，所有数据就保存在客户端，每次请求都发回服务器。这种方案就是接下来要介绍的基于Token的验证; 

#### Token

 ![Token](/../../../../Typora图库/Web前端/Token.png) 

1. 用户通过用户名和密码发送请求
2. 程序验证
3. 程序返回一个签名的token给客户端
4. 客户端储存token, 并且每次用每次发送请求
5. 服务端验证Token并返回数据

#### JWT(JSON Web Token，token标准)

JSON Web Tokens由dot（.）分隔的三个部分组成，它们是：

- Header（头部）
- Payload（负载）
- Signature（签名）

因此，JWT通常如下展示：**xxxxx.yyyyy.zzzz**

**Header** 是一个 JSON 对象

```json
{
  "alg": "HS256", // 表示签名的算法，默认是 HMAC SHA256（写成 HS256）
  "typ": "JWT"  // 表示Token的类型，JWT 令牌统一写为JWT
}
```

 **Payload** 部分也是一个 JSON 对象，用来存放实际需要传递的数据 。 JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 

 **Signature** 是对前两部分的签名，防止数据被篡改。 

首先，需要指定一个密钥(secret)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用Header里面指定的签名算法（默认是 **HMAC SHA256**），按照下面的公式产生签名。

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

算出签名后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。

```
JWT = Base64(Header) + "." + Base64(Payload) + "." + $Signature
复制代码
```

**如何保证安全？**

- 发送JWT要使用HTTPS；不使用HTTPS发送的时候，JWT里不要写入秘密数据
- JWT的payload中要设置expire时间

**使用方法**

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。此后，客户端每次与服务端通信，都要带上这个JWT。你可以把它放在Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在HTTP请求的头信息 Authorization 字段里面。

```js
Authorization: Bearer <token>
```

另一种做法是， 跨域的时候， JWT就放在POST请求的数据体里。

**作用**

 最开始的初衷是为了实现授权和身份认证作用的，可以实现无状态，分布式的Web应用授权。大致实现的流程如下 

 ![JWT](/../../../../Typora图库/Web前端/token流程.png) 

1. 客户端需要携带用户名/密码等可证明身份的的内容去授权服务器获取JWT信息；
2. 每次服务都携带该Token内容与Web服务器进行交互，由业务服务器来验证Token是否是授权发放的有效Token，来验证当前业务是否请求合法。

这里需要注意：不是每次请求都要申请一次Token，，如果不是对于安全性要求的情况，不建议每次都申请，因为会增加业务耗时；比如只在登陆时申请，然后使用JWT的过期时间或其他手段来保证JWT的有效性；

JWT最大的优势是**服务器不再需要存储Session，使得服务器认证鉴权业务可以方便扩展**。这也是JWT最大的缺点由于服务器不需要存储Session状态，因此**使用过程中无法废弃某个Token，或者更改Token的权限**。

前面讲的Token，都是Acesss Token，也就是访问资源接口时所需要的Token，还有另外一种Token，**Refresh Token**。

一般情况下，**Refresh Token的有效期会比较长。而Access Token的有效期比较短**，当Acesss Token由于过期而失效时，使用Refresh Token就可以获取到新的Token，如果Refresh Token也失效了，用户就只能重新登录了。<u>Refresh Token及过期时间是存储在服务器的数据库中，只有在申请新的Acesss Token时才会验证</u>，不会对业务接口响应时间造成影响，也不需要向Session一样一直保持在内存中以应对大量的请求。

 ![Refresh Token](/../../../../Typora图库/Web前端/Refresh Token.png) 

#### cookie和session区别

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、建议：

​	一般来说,**登陆验证信息,客户的私人信息**,如姓名,电话等,应该放在Session中.

Cookie则用于**用户登陆网站时的自动登陆以及类似"购物车"的处理**.使用Cookie保存信息时最好通过加密形式来保存数据,同时是否保存登陆信息,需要由用户自行选择。

#### Token和Session的区别

- Session是一种HTTP储存机制， 为无状态的HTTP提供持久机制; 

- Token就是令牌， 比如你授权(登录)一个程序时，它就是个依据，判断你是否已经授权该软件；

Session和Token并不矛盾，作为身份认证Token安全性比Session好，因为每一个请求都有签名还能防止监听以及重放攻击，而Session就必须依赖链路层来保障通讯安全了。如上所说，如果你需要实现有状态的回话，仍然可以增加Session来在服务端保存一些状态。

### 12  web标准、可⽤性、可访问性、可维护性

- Web标准：标签闭合、标签⼩写、不乱嵌套、使⽤外链css 和js 、结构⾏为表现的分离

- 可⽤性（Usability）：产品是否容易上⼿，⽤户能否完成任务，效率如何，以及这过程中⽤户的主观感受可好，是**从⽤户的⻆度来看产品的质量**。可⽤性好意味着产品质量⾼，是企业的核⼼竞争⼒
- 可访问性（Accessibility）：Web内容对于**残障⽤户**的可阅读和可理解性
- 可维护性（Maintainability）：⼀般包含两个层次，⼀是**当系统出现问题时，快速定位并解决问题的成本**，成本低则可维护性好。⼆是**代码是否容易被⼈理解**，是否容易修改和增强功能。

### 13 Doctype作⽤? 严格模式与混杂模式如何区分？它们有何意义?

- `<!DOCTYPE>` 声明位于⽂档中的最前⾯，处于 `<html>` 标签之前。**告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档**
- **严格模式**的排版和 JS 运作模式是 **以该浏览器⽀持的最⾼标准运⾏**
- 在**混杂模式**中，⻚⾯**以宽松的向后兼容的⽅式显示**。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。 DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现

### 14 ⾏内元素、块级元素、行内块级元素、空元素、替换元素

将三者任意转换：

　　(1)display:inline;转换为行内元素

　　(2)display:block;转换为块状元素

　　(3)display:inline-block;转换为行内块状元素

**行内元素**

有：` <a> <b> <span> <img> <input> <select> <strong>`

特征：

- 设置宽高无效
- 对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间
- 不会自动进行换行

**块级元素**

有： `<div> <ul> <ol> <li> <dl> <dt> <dd> <h1> <h2> <h3> <h4>… <p>`

特征：

- 能够识别宽高
- margin和padding的上下左右均对其有效
- 可以自动换行
- 多个块状元素标签写在一起，默认排列方式为从上至下。

**行内块级元素**

结合行内元素和块级元素的特性 ，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。 

特征：

- 不自动换行
- 能够识别宽高
- 默认排列方式为从左到右

**空元素**

有：` <br> <hr> <img> <input> <link> <meta>`

**可替换元素**

 在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。  简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 `` 元素，可能具有自己的样式表，但它们不会继承父文档的样式。 

有：`<iframe>, <img>, <audio>, <video>`

### 15 HTML全局属性(global attribute)有哪些

- class :为元素设置类标识
- data-* : 为元素增加⾃定义属性
- draggable : 设置元素是否可拖拽
- id : 元素id ，⽂档内唯⼀
- lang : 元素内容的的语⾔
- style : ⾏内css 样式
- title : 元素相关的建议信息

### 16 Canvas和SVG有什么区别？

- svg 绘制出来的每⼀个图形的元素都是**独⽴的DOM 节点**，能够⽅便的绑定事件或⽤来修改。canvas 输出的是**⼀整幅画布**
- svg 输出的图形是**⽮量图形**，后期可以修改参数来⾃由放⼤缩⼩，不会失真和锯⻮。⽽canvas 输出**标量画布**，就像⼀张图⽚⼀样，放⼤会失真或者锯⻮

### 17 a 标签的 href 属性和 onclick 事件，如何防止a的链接跳转

 如果 a 标签上出现了 href 属性并同时绑定了 click 事件，是怎样一个执行顺序呢？ 

回答： **click 事件是在页面开始跳转之前执行的**。 

**禁用href**

方法一：javascript:void(0)： 表示一个死链接。

```html
<a href="javascript:void(0)">btn</a>
```

 其中，`javascript` 为协议名称，`expression` 为 javascript 表达式，返回类型为 void ，即无返回值。 不过重要的是，`javascript: void(0)` 毕竟是个伪协议，少写的好。而且存在浏览器兼容 bug（有待考证），因此这种写法并不做推荐。 

方法二： preventDefault() 方法

```js
<a href="#">btn</a>

$("a").click(function(e){
  e.preventDefault();
  alert('a');
})
```

 通过取消事件的默认动作防止跳转。 

方法三：return false

```js
<a href="#">btn</a>

$("a").click(function(){
   alert('a');
   return false;
})
```

当我们每次调用 `return false` 时，都会执行以下三个步骤：

- event.preventDefault();
- event.stopPropagation();
- 停止回调函数执行并立即返回。

举个很简单的例子：

```js
<div class="parent">    
<a herf="#">btn</a></div>
<script>    
$(".parent").click(function(e){        
	alert('b');    
})    
$("a").click(function(e){        
	e.preventDefault();        
	alert('a');    
})</script>
```

因为事件冒泡，当我们点击 btn 按钮时，会先跳出显示 “a” 的提示框，再跳出显示 “b” 的提示框。但是页面不会跳转，因为有 `e.preventDefault()`。

如果我们将 a 的点击事件改成如下处理方式：

```js
$("a").click(function(e){  
	alert('a');  
	return false;
})
```

那么将不再跳出显示内容为 “b” 的提示框，因为在 `return false` 语句中，执行了 `event.stopPropagation()` 方法。

### 18 ⽹⻚验证码是⼲嘛的，是为了解决什么安全问题

- 区分⽤户是计算机还是⼈的公共全⾃动程序。可以防⽌恶意破解密码、刷票、论坛灌⽔
- 有效防⽌⿊客对某⼀个特定注册⽤户⽤特定程序暴⼒破解⽅式进⾏不断的登陆尝试

### 19 viewport

```javascript
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’
    // device-width  设备宽度
    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置
    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数
    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数
    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数
    // user-scalable    是否允许手动缩放
```

-  移动端浏览器通常都在一个比屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是viewport，目的是**正常展示没有做移动端适配的网页**，可以让他们完整的展现给用户。我们有时用移动设备访问桌面版网页就会看到一个横向滚动条，这里可显示区域的宽度就是viewport的宽度。 
- 延伸提问
  - 怎样处理 移动端 1px 被 渲染成 2px 问题
    - 局部处理
      - mate 标签中的 viewport 属性 ， initial-scale 设置为 1
      - rem 按照设计稿标准⾛，外加利⽤transfrome 的scale(0.5) 缩⼩⼀倍即可；
    - 全局处理
      - mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5
      - rem 按照设计稿标准⾛即可

### 20 URL结构分解

URL：统一资源定位符 (Uniform Resource Locator, URL)。

完整的URL由这几个部分构成：`scheme://host:port/path?query#hash：`

**scheme**：通信协议，常用的有http、https、ftp、mailto等。

**host**：端口号，可选。省略时使用协议的默认端口，如http默认端口为80。

**path**：查询，可选。用于传递参数，可有多个参数，用"&"符号隔开，每个参数的名和值用"="符号隔开。

**hash** ：信息片断字符串，也称为锚点。用于指定网络资源中的片断。

```js
用javascript获得其中的各个部分如下：
window.location.href：整个URl字符串，返回值："https://www.baidu.com/index.html?id=1&page=1#name1"。
window.location.protocol：协议部分，返回值："https:"。
window.location.host：主机部分。返回值："www.baidu.com"。
window.location.port：端口部分。如果采用了协议默认的端口，则返回空字符。本例返回值：""。
window.location.pathname：路径部分。返回值："/index.html"。
window.location.search：查询(参数)部分。返回值："?id=1&page=1"。
window.location.hash：锚点。返回值："#name1"。
```

#### URI和URL的区别

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。

- URI：Uniform Resource Identifier 统一资源**标识**符
- URL：Uniform Resource Location 统一资源**定位**符

URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。

URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。

### 21 浏览器的内核分别是什么?

- IE : trident 内核
- Firefox ：gecko 内核

- Safari : webkit 内核
- Opera :Google - Chrome 的Blink 内核
- Chrome:Blink (基于webkit ，Google与Opera Software共同开发)

### 22 div+css的布局较table布局有什么优点？

改版的时候更⽅便 只要改css ⽂件。
⻚⾯加载速度更快、结构化清晰、⻚⾯显示简洁。
表现与结构相分离。
易于优化（ seo ）搜索引擎更友好，排名更容易靠前。

### 23 渐进增强和优雅降级的不同吗

渐进增强：针对低版本浏览器进⾏构建⻚⾯，保证最基本的功能，然后再针对⾼级浏览器进⾏效果、交互等改进和追加功能达到更好的⽤户体验。
优雅降级：⼀开始就构建完整的功能，然后再针对低版本浏览器进⾏兼容。

区别：优雅降级是从复杂的现状开始，并试图减少⽤户体验的供给，⽽渐进增强则是从⼀个⾮常基础的，能够起作⽤的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；⽽渐进增强则意味着朝前看，同时保证其根基处于安全地带

### 24 为什么利⽤多个域名来存储⽹站资源会更有效？

CDN 缓存更⽅便
突破浏览器并发限制
节约cookie 带宽
节约主域名的连接数，优化⻚⾯响应速度
防⽌不必要的安全问题

### 25 src与href的区别

- **src ⽤于替换当前元素，href⽤于在当前⽂档和引⽤资源之间确⽴联系。**
- src 是source 的缩写，指向外部资源的位置，**指向的内容将会嵌⼊到⽂档中当前标签所在位置**；**在请求src 资源时会将其指向的资源下载并应⽤到⽂档内**，例如js 脚本，img 图⽚和frame 等元素
  - `<script src ="js.js"></script>` 当浏览器解析到该元素时，**会暂停其他资源的下载和处理**，直到将该资源加载、编译、执⾏完毕，图⽚和框架等元素也如此，类似于将所指向资源嵌⼊当前标签内。这也是为什么将js脚本放在底部⽽不是头部
- href 是Hypertext Reference 的缩写，**指向⽹络资源所在位置，建⽴和当前元素（锚点）或当前⽂档（链接）之间的链接**，如果我们在⽂档中添加`<link href="common.css" rel="stylesheet"/>`那么浏览器会识别该⽂档为css ⽂件，就会并⾏下载资源并且不会停⽌对当前⽂档的处理。 **页面解析不会暂停**（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。 这也是为什么**建议使⽤link ⽅式来加载css ，⽽不是使⽤@import ⽅式**

### 26 知道的⽹⻚制作会⽤到的图⽚格式有哪些？

- png-8 、png-24 、jpeg 、gif 、svg
- Webp： WebP 格式，⾕歌（google）开发的⼀种旨在加快图⽚加载速度的图⽚格式。图⽚压缩体积⼤约只有JPEG 的2/3 ，并能节省⼤量的服务器带宽资源和数据空间。Facebook Ebay 等知名⽹站已经开始测试并使⽤WebP 格式。
  在质量相同的情况下，WebP格式图像的体积要⽐JPEG格式图像⼩40% 。
- Apng：全称是“Animated Portable Network Graphics” , 是PNG的位图动画扩展，可以实现png格式的动态图⽚效果。04年诞⽣，但⼀直得不到各⼤浏览器⼚商的⽀持，直到⽇前得到 iOS safari 8 的⽀持，有望代替GIF 成为下⼀代动态图标准

### 27 defer和async的区别

![image.png](/../../../../Typora图库/Web前端/defer和async对比.png)

当浏览器碰到 `script` 脚本的时候：

1. `<script src="script.js"></script>` 
   没有 `defer` 或 `async`，浏览器会**立即加载并执行指定的脚本**，“立即”指的是在渲染该 `script` 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 

2. `<script async src="script.js"></script>`

   有 `async`，加载和渲染后续文档元素的过程将和 `script.js` 的加载与执行并行进行（异步）。async 是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 

3. `<script defer src="myscript.js"></script>`

   有 `defer`，加载后续文档元素的过程将和 `script.js` 的加载并行进行（异步），但是 `script.js` 的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。 它是按照加载顺序执行脚本的。

 ![请输入图片描述](/../../../../Typora图库/Web前端/defer和async.png) 

 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 

*defer* 和 *async* 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）,它俩的差别在于**脚本下载完之后何时执行**，显然 defer 是最接近我们对于应用脚本加载和执行的要求的。 

### 28 浏览器内存回收机制

垃圾回收机制（gc）分为：标记-清除算法与引用计数垃圾收集。

**标记-清除算法**

**在JavaScript中，标记清除是最常用的方式.**

例如：在函数中声明一个变量，就将这个变量定义为“进入环境”。从逻辑上讲 进入环境的变量其内存不能被释放，因为只要有流执行，这些变量都可能被用到。当变量离开环境后，解释器标记其为“离开环境”，此时，当垃圾收集器，在下个周期时就会回收这部分的内存.

```js
function foo(){
  let num = 1; //被标记,进入环境
  let count = 60; //被标记,进入环境
}

foo(); //函数执行完毕，num,count被标记为离开环境，被gc回收
```

**引用计数垃圾收集**

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。可以获得的对象，将不会被垃圾回收器回收，不能获得的对象将会被垃圾回收器回收，从而达到释放内存的目的. 具体实现：

```js
function obj(){
  let a={};//定义a引用对象 初始化 a引用次数为0
  let b=a;//a被引用次数1
  let c=a;//a被引用次数2
  b={};//因b引用被切断，此时上下文a的引用次数减一，引用次数变为1
  c=[];//同上此时a的引用次数为0，内存等待回收
}
```

 如上code：a的引用计数为0，对象不再被使用，等待垃圾收集器回收. 理论上，如果按照以上的原理进行coding,内存是能够及时被回收掉，有效的节省内存资源. 

### 29 web开发中会话跟踪的⽅法

会话跟踪就是**浏览器和服务器通信** 

 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才应会话跟踪技术来实现这种要求 

a) **URL重写**： 
URL(统一资源定位符)是Web上特定页面的地址，URL地址重写的原理是**将该用户Session的id信息重写到URL地址中**，以便在服务器端进行识别不同的用户。URL重写能够在客户端停用cookies或者不支持cookies的时候仍然能够发挥作用。

b) **隐藏表单域**： 
**将会话ID添加到HTML表单元素中提交到服务器**，此表单元素并不在客户端显示，浏览时看不到，源代码中有。

c) **Cookie**： 
Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。 服务器创建保存于浏览器端，不可跨域名性，大小及数量有限。客户端可以采用两种方式来保存这个Cookie对象，一种方式是 保存在 客户端内存中，称为临时Cookie，浏览器关闭后 这个Cookie对象将消失。另外一种方式是保存在 客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是 这个Cookie在有效期内。 这样就实现了对客户的跟踪。 
Cookie是可以被禁止的。

d) **session**： 
每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。 保存在服务器端。需要解决多台服务器间共享问题。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。 
在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。 
Session是依赖Cookie的，如果Cookie被禁用，那么session也将失效。

### 30 HTTP request报⽂结构

构成：请求行，请求头，请求正文

1. ⾸⾏是Request-Line包括：**请求⽅法，请求URI，协议版本，CRLF**( 回车换行 )
2. ⾸⾏之后是若⼲⾏请求头，包括general-header，request-header或者entity-header，每个⼀⾏以CRLF结束
3. 请求头和消息实体之间有⼀个CRLF分隔
4. 根据实际请求需要可能包含⼀个消息实体

⼀个请求报⽂例⼦如下：

```js
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML,
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
name=qiu&age=25
```

### 31 HTTP response报⽂结构

构成：状态行，响应头，响应正文

- ⾸⾏是状态⾏包括：HTTP版本，状态码，状态描述，后⾯跟⼀个CRLF
- ⾸⾏之后是若⼲⾏响应头，包括：通⽤头部，响应头部，实体头部
- 响应头部和响应实体之间⽤⼀个CRLF空⾏分隔
- 最后是⼀个可能的消息实体

响应报⽂例⼦如下：

```
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1
{"name": "qiu", "age": 25}
```

### 32 同步和异步的区别

- 同步：浏览器访问服务器请求，**⽤户看得到⻚⾯刷新**，重新发请求,等请求完，⻚⾯刷新，新内容出现，⽤户看到新内容,进⾏下⼀步操作
- 异步：浏览器访问服务器请求，**⽤户正常操作，浏览器后端进⾏请求**。等请求完，⻚⾯不刷新，新内容也会出现，⽤户看到新内容

### 34 attribute和property的区别是什么

- **attribute 是dom 元素在⽂档中作为html 标签拥有的属性；**
- **property 就是dom 元素在js 中作为对象拥有的属性。**
- 对于html 的标准属性来说， attribute 和property 是同步的，是会⾃动更新的；但是对于⾃定义的属性来说，他们是不同步的

![1600501592920](/../../../../Typora图库/Web前端/attr和property.png)

### 35 

### 36 WebSocket

由于 http 存在⼀个明显的弊端（消息只能有客户端推送到服务器端，⽽服务器端不能主动推送到客户端），导致如果**服务器如果有连续的变化，这时只能使⽤轮询，⽽轮询效率过低**，并不适合。于是 WebSocket 被发明出来

相⽐与 http 具有以下有点：

- ⽀持**双向通信**，实时性更强；
- 可以发送⽂本，也可以⼆进制⽂件；
- **协议标识符是 ws ，加密后是 wss** ； 非安全的没有证书，安全的需要SSL证书。  其中WSS表示在TLS之上的WebSocket。WS一般默认是80端口，而WSS默认是443端口。
- 较少的控制开销。连接创建后， ws 客户端、服务端进⾏数据交换时，协议控制的数据包头部较⼩。在不包含头部的情况下，服务端到客户端的包头只有2~10 字节（取决于数据包⻓度），客户端到服务端的的话，需要加上额外的4字节的掩码。⽽HTTP 协议每次通信都需要携带完整的头部；
- ⽀持扩展。ws协议定义了扩展，⽤户可以扩展协议，或者实现⾃定义的⼦协议。（⽐如⽀持⾃定义压缩算法等）
- ⽆跨域问题。

### 37 Electron

electron 实际上是⼀个**套了 Chrome 的 nodeJS 程序**

**1）可以用 Web 前端技术开发跨平台的桌面客户端：**

这是 Electron 最迷人的地方，究其根本是因为它是建立在 Chromium 和 NodeJS 之上的，一个负责界面，一个负责背后的逻辑，典型的"你负责貌美如花，我负责赚钱养家"，为什么 Electron 能够开发跨平台的桌面应用也就可以理解了。

而对于前端开发来说，前端开发可以用自己熟悉的方式去写应用界面，逻辑部分也还是 JS，如果你精通 Node 后端，那后端也可以插一脚。

但是，不同系统间还是会有很大的不同，“同一套代码，编译出跨平台的多个客户端”，话是这么说，但你得因为系统的不同做一些额外的处理，以使得打包出的不同系统下的应用都可以正常工作，这可能是一些“if - else”的成本，但相比于那80%都能完全复用的代码，这些成本已经很小了。

综上所述：**一个 Web 前端开发者可以花很少的成本去上手 Electron**，而相比于以前开发多平台客户端的成本，利用 Electron 开发多平台客户端的成本是极低的。

**2）可以从 NodeJS 的生态获得极大的助力：**

因为 Electron 是基于 NodeJS 的，意味着，NodeJS 这个大生态下的模块，Electron 也都可以用，这减少了很多造轮子的时间。

Electron 从 NodeJS 获益有2个方面，一个方面是如现代的 web 项目一般，开发构建流程可以**引入很多成熟的包**去打造出适合自己项目的开发工作流，另一个方面就是**其应用本身也可以依赖需要的包去完成自己的功能**。

**总结一下，使用Electron开发的理由：**

> a. 使用具有强大生态的Web技术进行开发，开发成本低，可扩展性强，更炫酷的UI；
> b. 跨平台，一套代码可打包为Windows、Linux、Mac三套软件，且编译快速；
> c. 可直接在现有Web应用上进行扩展，提供浏览器不具备的能力；

### 38 

### 39 负载均衡

多台服务器共同协作，不让其中某⼀台或⼏台超额⼯作，发挥服务器的最⼤作⽤

- http 重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第⼀次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip 服务器中的⼀个（可监控性较弱）
- 反向代理负载均衡：访问统⼀的服务器，由服务器进⾏调度访问实际的某个服务器，对统⼀的服务器要求⼤，性能受到 服务器群的数量

### 40 Service worker

本质上**充当Web应⽤程序与浏览器之间的代理服务器**，也可以**在⽹络可⽤时作为浏览器和⽹络间的代理**。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截⽹络请求并基于⽹络是否可⽤以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API

### 41 重绘和回流

- 重绘（Repaint）和回流（Reflow）是渲染步骤中的⼀⼩节，但是这两个步骤对于性能影响很⼤。
- **重绘是当节点需要更改外观⽽不会影响布局的**，⽐如改变 color 就叫称为重绘
- **回流是布局或者⼏何属性需要改变**就称为回流。
- **回流必定会发⽣重绘，重绘不⼀定会引发回流**。回流所需的成本⽐重绘⾼的多，改变深层次的节点很可能导致⽗节点的⼀系列回流。

在以下情况会发生reflow：

1. 改变窗囗大小
2. 改变文字大小
3. 添加/删除样式表
4. 内容的改变，如用户在输入框中敲字(这样也会-_-||)
5. 激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活)
6. 操作class属性
7. 脚本操作DOM
8. 计算offsetWidth和offsetHeight
9. 设置style属性

所以以下⼏个动作可能会导致性能问题：

- 改变 window ⼤⼩
- 改变字体
- 添加或删除样式
- ⽂字改变
- 定位或者浮动
- 盒模型

**减少重绘和回流：**

- 使⽤ translate 替代 top

- 使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）

- 把 DOM 离线后修改，⽐如：先把 DOM 给 display:none (有⼀次 Reflow )，然后你修改100 次，然后再把它显示出来
- 不要把 DOM 结点的属性值放在⼀个循环⾥当成循环⾥的变量
- 不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤requestAnimationFrame
- CSS 选择符从右往左匹配查找，避免 DOM 深度过深
- 将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video标签，浏览器会⾃动将该节点变为图层。

### 42 HTTP / 2.0

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑**HTTP2.0的协议解析决定采用二进制格式**，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。



结论1：从HTTP/1.0到HTTP/2，都是利用TCP作为底层协议进行通信的。

结论2：HTTP/1.1，引进了长连接(keep-alive)，减少了建立和关闭连接的消耗和延迟。

结论3：HTTP/2，引入了多路复用：连接共享，提高了连接的利用率，降低延迟。

### 43 预加载，预渲染

在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候就可以使⽤**预加载**
预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使⽤以下代码开启预加载

```html
<link rel="preload" href="http://example.com">
```

预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后加载，唯⼀缺点就是兼容性不好

可以通过**预渲染**将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染

```html
<link rel="prerender" href="http://poetries.com">
```

预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染

### 44 懒执⾏，懒加载

**懒执⾏**就是**将某些逻辑延迟到使⽤时再计算**。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。**懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤来唤醒**

**懒加载**就是**将不关键的资源延后加载**

懒加载的原理就是**只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内需要加载的东⻄**。对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实的图⽚资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样图⽚就会去下载资源，实现了图⽚懒加载

懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等

### 45 如果一个HTML文档内含有阿拉伯文，应该使用哪种编码

UTF8 是(UNICODE八位交换格式）的简称，UNICODE是国际标准，也是ISO标准10646的等价标准。

UNICODE编码的文件中可以同时对几乎所有地球上已知的文字字符进行书写和表示，而且已经是UNIX/LINUX世界的默认编码标准。在中国简体中文版非常常用的GB2312/GB18030/GBK系列标准是我国的国家标准，但只能对中文和多数西方文字进行编码。

为了网站的通用性起见，用UTF8编码是更好的选择。

**UTF-8是世界通用的语言编码**

浏览UTF-8编码的任何网页，无论是中文、还是日文、韩文、阿拉伯文，都可以正常显示。

### 46 锚伪类

在支持 CSS 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。

```css
a:link{color: #FF0000}/* 未访问的链接 */
a:visited{color: #00FF00}/* 已访问的链接 */
a:hover{color: #FF00FF}/* 鼠标移动到链接上 */
a:active{color: #0000FF}/* 选定的链接 */
```

在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。

在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。

伪类名称对大小写不敏感。

### 47 重构

- ⽹站重构：在不改变外部⾏为的前提下，简化结构、添加可读性，⽽在⽹站前端保持⼀致的⾏为。也就是说是在不改变UI的情况下，对⽹站进⾏优化， 在扩展的同时保持⼀致的UI
- 对于传统的⽹站来说重构通常是：
  - 表格( table )布局改为DIV+CSS
  - 使⽹站前端兼容于现代浏览器(针对于不合规范的CSS 、如对IE6有效的)
  - 对于移动平台的优化
  - 针对于SEO 进⾏优化

### 48 IE & FF区别

1. 自定义属性问题：可以使用获取常规属性的方法来获取自定义属性，也可以使用getAtribute()获取自定义属性，**ff下只能使用getAttribute()获取自定义属性**。

2. 在IE中可以用`eval("idname")`或`getElementById("idname")`来取得id为idname的html对象，**ff下只能用后者`getElementById`**，解决方案，统一用getElementById获取。

3. **IE下html对象的id可以作为document的下属对象变量名直接使用，ff下则不能。ff下可以使用与html对象id相同的变量，ie则不能**。解决方法:使用document.getElementById("idName")代替document.idName.最好不要取HTML对象ID相同的变量名,以减少错误;在声明变量时,一律加上var,以避免歧义.

4. **ie下添加事件函数addEventListener,ff添加attachEvent**。

5. event.srcElement问题。**在ie下event对象有srcElement属性，ff下event(e)对象有target属性**，解决办法：`var obj=event.srcElement?event.srcElement:e.target`;来代替。

6. event.x与event.y 问题，**IE下event对象有x，y属性，但没有pageX，pageY属性，ff下event(e)对象有pageX，pageY属性，但没有x，y属性**。

   解决办法：`var myX=event.x?event.x:event.pageX; var myY=event.y?event.y:event.pageY;`

7. window.event问题。**window.event 只能在IE下运行，而不能在ff中运行**。这是因为ff的even（e）只能在事件发生的现场使用。解决方案：传入一个形参e。

   `function doSom(e){var myEvent=e?e:(window.event?window.event:null)}`

8. input.type属性问题。**IE下input.type属性为只读，但ff下input.type属性为读写**。解决办法：不能修改input.type的属性，如果必须要修改，可以先隐藏原来的input，然后再同样的位置再插入一个新的input元素。

9. const问题。**ff下可以使用const关键字或var关键字定义常量，IE下只能用var关键字来定义常量**，解决方案：统一使用var关键字定义。

10. innerText 的问题，**innerText在IE中能正常工作，但ff需要使用texContent**。**innerHTML同时被ie,ff等浏览器支持，但outerHTML只能被ie使用**。

11. 对象宽高赋值问题
    问题说明：FireFox中类似 obj.style.height = imgObj.height 的语句无效。
    解决方法：统一使用 obj.style.height = imgObj.height + “px”;

### 49 input，textarea的区别

**input标签**

1、需要指定type属性，如text，password等。

2、通过size属性指定显示字符的长度。

3、value属性指定初始值

4、Maxlength属性指定文本框可以输入的最长长度。

5、焦点垂直居中文本框中，单行

**textarea标签**

1、需要`</textarea>`来封闭标签

2、内容写在标签对中

3、使用row、col指定textarea大小

4、焦点在左上角，多行

#### 怎么用div来模拟实现一个textarea？

 关键：我们要知道一个h5的属性，那就是contenteditable，将属性设置成true就会使得div是可以编辑的。 

```html
<!DOCTYPE html>
<html>
  <head>
    <title>div实现textarea效果</title>
    <style>
      #textarea {
        height: 200px;
        width: 300px;
        padding: 4px;
        border: 1px solid #888;
        resize: vertical;
        overflow: auto;
      }
 
      #textarea:empty:before {
        content: attr(placeholder);
        color: #bbb;
      }
    </style>
  </head>
  <body>
    <div id="textarea" contenteditable="true" placeholder="请输入内容..."></div>
  </body>
</html>
```



## 二、CSS

### 1 css sprite

概念：将多个⼩图⽚拼接到⼀个图⽚中。通过background-position 和元素尺⼨调节需要显示的背景图案。

优点：

- **减少HTTP 请求数**，极⼤地提⾼⻚⾯加载速度
- 增加图⽚信息重复度，提⾼压缩⽐，减少图⽚⼤⼩
- 更换⻛格⽅便，只需在⼀张或⼏张图⽚上修改颜⾊或样式即可实现

缺点：

- 图⽚**合并麻烦**
- **维护麻烦**，修改⼀个图⽚可能需要从新布局整个图⽚，样式

### 2 opacity:0; display: none; 与visibility: hidden; 的区别，rgba()和opacity的透明效果有什么不同？

联系：它们都能让元素不可⻅
 **{ display: none; /* 不占据空间，无法点击，不会继承，transition无效 */ }
 { visibility: hidden; /* 占据空间，无法点击，会被继承，子元素可使用visibility: visible;来反隐藏，transition无效 */ }
 { opacity: 0; filter:Alpha(opacity=0); /* 占据空间，可以点击，会被继承，子元素不能反隐藏，transition有效 */ }**
 { position: absolute; top: -999em; /* 不占据空间，无法点击 */ }
 { position: relative; top: -999em; /* 占据空间，无法点击 */ }
 { position: absolute; visibility: hidden; /* 不占据空间，无法点击 */ }
 { height: 0; overflow: hidden; /* 不占据空间，无法点击 */ }
 { position: absolute; opacity: 0; filter:Alpha(opacity=0); /* 不占据空间，可以点击 */ }

**rgba()和opacity的透明效果**

- rgba() 和opacity 都能实现透明效果，但最⼤的不同是**opacity 作⽤于元素**，以及元素内的所有内容的透明度，
- ⽽**rgba() 只作⽤于元素的颜⾊或其背景⾊**。（**设置rgba 透明的元素的⼦元素不会继承透明效果！**）

### 3 link 与@import 的区别

1. link 是**HTML ⽅式**， @import 是**CSS⽅式**
2. link 最⼤限度⽀持**并⾏**下载， @import 过多嵌套导致**串⾏**下载，出现FOUC (⽂档样式短暂失效)
3. link 可以通过rel="alternate stylesheet" 指定候选样式
4. 浏览器对**link ⽀持早于@import** ，可以使⽤@import 对⽼浏览器隐藏样式
5. **@import 必须在样式规则之前**，可以在css⽂件中引⽤其他⽂件
6. 总体来说： link 优于@import

### 4 什么是FOUC?如何避免

Flash Of Unstyled Content ：⽤户定义样式表加载之前浏览器使⽤默认样式显示⽂档，⽤户样式加载渲染之后再从新显示⽂档，造成⻚⾯闪烁。

解决⽅法：把样式表放到⽂档的`<head>`

### 5 Flex Box

 flexbox，是一种**一维**的布局模型。 

 ![容器](/../../../../Typora图库/Web前端/flex容器.png) 

从容器的角度来看，有两个不变的轴，**主轴由 flex-direction 定义，另一根轴始终垂直于它**。默认定义是：

​	1) **水平方向的主轴**（main axis），主轴开始位置称为`main start`，结束位置称为 `main end`

​	2) **垂直方向的交叉轴**（cross axis），交叉轴开始位置称为 `cross start`，结束位置称为 `cross end`

相关属性：

- flex-direction：定义了主轴方向。决定容器内项目排列方向，默认从左到右`row`。如果你选择了 `row` 或者 `row-reverse`，你的主轴将沿着 `inline`(行级)方向延伸；选择 `column` 或者 `column-reverse` 时，你的主轴会沿着上下方向延伸 — 也就是 `block`(块级) 排列的方向。

  ```css
  flex-direction：row | row-reverse | column | column-reverse
  ```

   特别注意：flex-direction设置后会引起主轴和交叉轴方向改变。 

-  flex-wrap：决定容器主轴方向上项目是否换行，默认不换行`nowrap`。`reverse`表示逆序。 

  ```css
  flex-wrap: nowrap | wrap | wrap-reverse;
  ```

-  flex-flow：是`flex-direction` 和`flex-wrap`属性的简写。默认为：`row nowrap`。 

  ```css
  flex-flow: <flex-direction> || <flex-wrap>;
  ```

-  justify-content：决定容器内项目**在主轴上**对齐方式。默认左对齐 `flex-start`。 

  ```css
  justify-content: flex-start | flex-end | center | space-between | space-around;
  /**
  * flex-start（默认值）：左对齐。项目堆放在容器主轴开始位置(main start)；
  * flex-end：右对齐。项目堆放在容器主轴结束位置(main end)；
  * center： 居中。项目沿着主轴居中排列；
  * space-between：两端对齐，项目之间的间隔都相等。
  * space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
  **/
  ```

-  align-items：决定容器内项目**在交叉轴上**对齐方式。默认为`stretch`。 

  ```css
  align-items: flex-start | flex-end | center | baseline | stretch;
  /**
  * flex-start：交叉轴的起点对齐。
  * flex-end：交叉轴的终点对齐。
  * center：交叉轴的中点对齐。
  * baseline: 项目的第一行文字的基线对齐。
  * stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
  **/
  ```

-  align-content：决定容器内项目**在交叉轴上**内容与剩余空间对齐方式。默认为 `stretch`。  特别注意：该属性只对设置了`flex-wrap:wrap`的容器生效，并且容器里的元素构成了多行。 

  ```css
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
  /**
  * flex-start：与交叉轴的起点对齐。
  * flex-end：与交叉轴的终点对齐。
  * center：与交叉轴的中点对齐。
  * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
  * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
  * stretch（默认值）：轴线占满整个交叉轴。
  **/
  ```

 项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。 

相关属性：

-  order：定义项目在容器**主轴方向上的**排列顺序，数值越小排列越靠前。默认为 0 。 

  ```css
  order: <integer>;
  ```

- flex-grow：定义项目基于 `flex-basis` 放大比例，默认为 0 ，即便容器存在剩余空间，也不放大。不允许负值。 **剩余空间**：元素占据完容器空间后的布局空白 

  ```css
  flex-grow: <number>; /* default 0 */
  /**
  * 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。
  * 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
  **/
  ```

-  flex-shrink：定义项目在容器空间不足时的基于 `flex-basis` 缩小比例，默认为1，不允许负值。容器空间不足时该项目要缩小，并且项目内容会换行。只有在flex元素总和超出主轴才会生效。 

  ```css
  flex-shrink: <number>; /* default 1 */
  /**
  * 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。项目缩小内容换行。
  * 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。不换行，即使容器设置了wrap内容过长时也会溢出
  **/
  ```

-  flex-basis：可以理解成设置项目默认大小。定义项目分配多余空间之前，**在主轴上**占据的空间。默认为auto，即项目内容大小。 

  ```css
   flex-basis: <length> | auto; /* default auto */
  ```

   如果容器内所有项目大小总和超过容器，不设置 wrap 的情况下会溢出容器： 

-  flex：是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。 

  ```css
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
  ```

  flex 有几种预定义的值：

  - `flex: initial`     是把flex元素重置为Flexbox的初始值，它相当于 flex: 0 1 auto。
  - `flex: auto`        等同于 flex: 1 1 auto,表明元素既可以拉伸也可以收缩。
  - `flex: none`       可以把flex元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。
  - `flex: ` 常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0或 flex:2 2 0。元素可以在以 flex-basis为0的基础上伸缩。 **建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。**

-  align-self：用于设置单个项目**在交叉轴上**对齐方式，可覆盖容器的 `align-items`属性，默认为 `auto`。如果值为`auto`，则计算值为父元素的 ' align-items（ 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式 ）' 值，否则为指定值。 

  ```css
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
  ```

  如果容器设置了`align-self:center`，但target设置了`align-self`，target按照`align-self`设置

### 6 CSS实现自适应九宫格布局

 首先要注意的是九宫格容器是宽高相等的正方形，并且是自适应的，这里关键是实现宽高相等，有些人想到了相对视口宽度 **vw**，但是它是相对于屏幕可见宽度来设置的，并且会忽略滚动条的宽度，所以这是不可行的。这里我用一种变通方法，看代码… 

**FlexBox**

HTML 结构如下：

```html
<div class="square">
  <ul class="square-inner flex">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
    <li>9</li>
  </ul>
</div>
```

抽取公共样式：

```css
.square{
  position: relative;
  width: 100%;
  height: 0;
  padding-bottom: 100%; /* padding百分比是相对父元素宽度计算的 */
  margin-bottom: 30px;
}
.square-inner{
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%; /* 铺满父元素容器，这时候宽高就始终相等了 */
}
.square-inner>li{
  width: calc(98% / 3);  /* calc里面的运算符两边要空格 */
  height: calc(98% / 3);
  margin-right: 1%;
  margin-bottom: 1%;
  overflow: hidden;
}
```

使用Flex的一个好处是不用再担心高度塌陷的问题，而且还可以轻松实现子元素横向竖向甚至按比例伸缩扩展的布局。

```css
.flex{
  display: flex;
  flex-wrap: wrap;
}
.flex>li{
  flex-grow: 1; /* 子元素按1/n的比例进行拉伸 */
  background-color: #4d839c;
  text-align: center;
  color: #fff;
  font-size: 50px;
  line-height: 2;
}
.flex>li:nth-of-type(3n){ /* 选择个数是3的倍数的元素 */
  margin-right: 0;
}
.flex>li:nth-of-type(n+7){  /* 选择倒数的三个元素，n可以取0 */
  margin-bottom: 0;
}
```

**Grid**

 对于网格布局来说，grid 比 flex 更为方便，代码量更少，可以处理更为复杂的结构。 

```html
<div class="square">
  <div class="square-inner grid">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
    <div>7</div>
    <div>8</div>
    <div>9</div>
  </div>
</div>
```

```css
.grid{
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* 相当于 1fr 1fr 1fr */
  grid-template-rows: repeat(3, 1fr); /* fr单位可以将容器分为几等份 */
  grid-gap: 1%; /* grid-column-gap 和 grid-row-gap的简写 */
  grid-auto-flow: row;
}
.grid>div{
  color: #fff;
  font-size: 50px;
  line-height: 2;
  text-align: center;
  background: linear-gradient(to bottom, #f5f6f6 0%,#dbdce2 21%,#b8bac6 49%,#dddfe3 80%,#f5f6f6 100%);
}
```

**Float**

 浮动实现九宫格 

```html
<div class="square">
  <ul class="square-inner float">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
    <li>9</li>
  </ul>
</div>
```

```css
.float::after{
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
}
.float>li{
  float: left;
  background-color: #42a59f;
  text-align: center;
  color: #fff;
  font-size: 50px;
  line-height: 2;
}
.float>li:nth-of-type(3n){
  margin-right: 0;
}
.float>li:nth-of-type(n+7){
  margin-bottom: 0;
}
```

 除了浮动，这里 li 也可以使用`display: inline-block;`实现同样的效果，不过要注意HTML代码非压缩情况下行块级元素之间会出现默认间隔，不同浏览器下表现还不一样，这时可以给父级元素设置`font-size: 0`; 

**Table**

```html
<div class="square">
  <table class="square-inner table">
    <tbody>
      <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
      </tr>
      <tr>
        <td>4</td>
        <td>5</td>
        <td>6</td>
      </tr>
      <tr>
        <td>7</td>
        <td>8</td>
        <td>9</td>
      </tr>
    </tbody>
  </table>
</div>
```

```css
.table{
  border-collapse: separate;
  border-spacing: 0.57em;
  font-size: 14px;
  empty-cells: hide;
  table-layout: fixed;
}
.table>tbody>tr>td{
  text-align: center;
  background-color: #889ed8;
  overflow: hidden;
}
```

说下用表格实现九宫格有哪些瑕疵：

- 最后一行最后一列的单元格宽高与前面的不一致，虽然相差不大，但是还是有差异的；
- 与前面的两种方法不同，table 单元格之间的间隔是利用`border-spacing`属性实现的，且不支持百分比，单元格四周都有类似margin的外边距效果。

**分析**

综上来看，个人认为 FlexBox 适合用于移动端，PC端 IE10 以下不支持；Grid网格布局比较方便，但是规范还未成熟，主流浏览器厂商尚未推广，不推荐使用在项目中；浮动和行块级式声明可以兼容到IE6，移动端和PC端支持的都不错；Table 因为实现有瑕疵所以不推荐使用。

### 7 清除浮动的⼏种⽅式

浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另⼀个浮动框的边框为⽌。由于浮动框不在⽂档的普通流中，所以⽂档的普通流的块框表现得就像浮动框不存在⼀样。浮动的块框会漂浮在⽂档普通流的块框上

- ⽗级div 定义height

- 结尾处加空div 标签clear:both（不推荐使用）

- **⽗级div 定义伪类:after 和zoom**（最推荐）

  ```css
  .clearfix:after {
      content:"";
      height:0;
      line-height:0;
      display:block;
      clear:both;
      visibility:hidden;  /_将元素隐藏起来_/ 
        在页面的 clearfix 元素后面添加了一个空的块级元素
       （这个元素的高为 0 行高也为 0   并且这个元素清除了浮动）
  }
  .clearfix {
    zoom:1;/_为了兼容 IE6_/
  }
  ```

- ⽗级div 定义overflow:hidden （不推荐使用）

### 8 为什么要初始化CSS样式?

- 因为**浏览器的兼容问题**，不同浏览器对有些标签的默认值是不同的，如果没对CSS 初始化往往会出现浏览器之间的⻚⾯显示差异。
- 当然，初始化样式会对SEO 有⼀定的影响，但⻥和熊掌不可兼得，但⼒求影响最⼩的情况下初始化

### 9 css3有哪些新特性

新增各种css 选择器
圆⻆ border-radius
多列布局
阴影和反射
⽂字特效text-shadow
线性渐变
旋转transform

**CSS3新增伪类有哪些？**

p:first-of-type 选择属于其⽗元素的⾸个`<p>` 元素的每个`<p>` 元素。
p:last-of-type 选择属于其⽗元素的最后 `<p>` 元素的每个`<p>` 元素。
p:only-of-type 选择属于其⽗元素唯⼀的 `<p>` 元素的每个` <p>` 元素。
p:only-child 选择属于其⽗元素的唯⼀⼦元素的每个 `<p>` 元素。
p:nth-child(2) 选择属于其⽗元素的第⼆个⼦元素的每个 `<p>` 元素。
:after 在元素之前添加内容,也可以⽤来做清除浮动。
:before 在元素之后添加内容。
:enabled 已启⽤的表单元素。
:disabled 已禁⽤的表单元素。
:checked 单选框或复选框被选中。

### 10 display有哪些值？说明他们的作⽤

block 转换成块状元素。
inline 转换成⾏内元素。
none 设置元素不可⻅。
inline-block 象⾏内元素⼀样显示，但其内容象块类型元素⼀样显示。
list-item 象块类型元素⼀样显示，并添加样式列表标记。
table 此元素会作为块级表格来显示
inherit 规定应该从⽗元素继承 display 属性的值

### 11 display、float、position的关系

- 如果display 取值为none ，那么position 和float 都不起作⽤，这种情况下元素不产⽣框

- 否则，如果position 取值为absolute 或者fixed ，框就是绝对定位的， float 的计算值为none ， display 根据下⾯的表格进⾏调整。

   盒的位置根据“top”，“right”，“bottom”和“left”属性与盒的包含块决定。 

- 否则，如果float 不是none ，框是浮动的， display 根据下表进⾏调整

- 否则，如果元素是根元素， display 根据下表进⾏调整

- 其他情况下display 的值为指定值

- 总结起来：绝对定位、浮动、根元素都需要调整display

 ![这里写图片描述](/../../../../Typora图库/Web前端/display.png) 

 ![这里写图片描述](/../../../../Typora图库/Web前端/display表.png) 

### 12 盒模型（IE盒模型、标准盒模型）

 当你对一个文档进行布局(laying out)时候, 浏览器引擎会根据CSS-Box模型将所有元素描述为一个盒子, CSS会决定这些盒子的大小, 位置, 属性(颜色, 边框...)。 

 盒模型分为两类: IE盒模型和标准盒模型。 两者的区别在于: 

- IE盒模型：width/height = content + border + padding 

- 标准盒模型：width/height = content 

IE盒模型：

![IE盒模型](/../../../../Typora图库/Web前端/IE盒模型.png) 

标准盒模型：

 ![标准盒模型](/../../../../Typora图库/Web前端/标准盒模型.png) 

### 13 BFC规范

它决定了元素如何对其内容进⾏定位,以及与其他元素的关系和相互作⽤

BFC相对于一个盒子，内部的元素与外界的元素互不干扰，它不会影响外部的布局，外部的布局也不会影响到它。

**形成条件**

- float的值不是none
- position的值不是static或者relative
- display的值是inline-block,table-cell,flex,table-caption或者inline-flex.
- overflow的值不是visible

**特性**

- 内部的盒子会在垂直方向上一个接一个地放置
- 对于同一个BFC的两个相邻的盒子的margin会发生重叠
- 每个元素的左外边距与包含块的左边界相接触
- BFC的区域不会与float的元素区域重叠
- 计算BFC的高度时，浮动子元素也参与计算
- BFC就是页面上的一个隔离的独立容器，不会影响外面的元素

**应用场景**

- 解决浮动子元素导致父元素高度坍塌的问题
- 解决文字环绕在float四周的情况
- 解决边距重叠的问题

### 14 css hack

 css hack ：由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。 

通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的 

**CSS Hack分类**
1、属性级Hack：比如IE6能识别下划线`”_”`和星号” * “，IE7能识别星号” * “，但不能识别下划线`”_”`，而firefox两个都不能认识。
2、选择符级Hack：比如IE6能识别`*html .class{}`，IE7能识别`*+html .class{}`或者`*:first-child+html .class{}`。
3、IE条件注释Hack：IE条件注释是微软从IE5开始就提供的一种非标准逻辑语句。比如针对所有IE：`<!--[if IE]><!--您的代码--><![endif]–>`，针对IE6及以下版本：`<!--[if lt IE 7]><!--您的代码--><![endif]–>`，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都 会生效。

PS：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下被当做注释视而不见。可以通过IE条件注释载入不同的CSS、JS、HTML和服务器代码等。

### 15 CSS三种布局模型

1. 流动模型（Flow）

   流动（Flow）模型是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。

   流动布局模型具有2个比较典型的特征：

   第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。（每一个便签都显示着自己本来默认的那个宽高）

   第二点，在流动模型下，行内元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）

2. 浮动模型 (Float)

    任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动 

   ```css
   div{float:left;}　
   div{float:right;}
   ```

    可以为不同的div设置不同的浮动方式来布局。 

3. 层模型（Layer）

   层模型有三种形式：

   1、相对定位(position: relative)

   2、绝对定位(position: absolute)

   3、固定定位(position: fixed)

   

### 16 PNG\GIF\JPG的区别及如何选

GIF

- 8 位像素， 256 ⾊
- ⽆损压缩
- ⽀持简单动画
- ⽀持boolean 透明
- 适合简单动画

JPEG

- 颜⾊限于256
- 有损压缩
- 可控制压缩质量
- 不⽀持透明
- 适合照⽚

PNG

- 有PNG8 和truecolor PNG
- PNG8 类似GIF 颜⾊上限为256 ，⽂件⼩，⽀持alpha 透明度，⽆动画
- 适合图标、背景、按钮

### 17 ⾏内元素float:left后是否变为块级元素？

**⾏内元素设置成浮动之后变得更加像是inline-block** （⾏内块级元素，设置成这个属性的元素会同时拥有⾏内和块级的特性，最明显的不同是它的默认宽度不是100% ），这时候给⾏内元素设置padding-top 和padding-bottom或者width 、height 都是有效果的

### 18 在⽹⻚中的应该使⽤奇数还是偶数的字体？

偶数字号相对更容易和 web 设计的其他部分构成⽐例关系

### 19 伪类、伪元素

 <img src="/../../../../Typora图库/Web前端/伪类.png" alt="CSS2及CSS3伪类区分" style="zoom: 67%;" />  <img src="/../../../../Typora图库/Web前端/伪元素.png" alt="CSS3伪元素单双冒号区分" style="zoom: 67%;" /> 

 伪元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素 。**单冒号( : )⽤于CSS3 伪类，双冒号( :: )⽤于CSS3 伪元素**

 对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。 

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号

**哪些标签不支持伪元素？**

伪元素虽然强大，但是还是有一些特定的标签是不支持伪元素 before 和 after 的。

诸如 `<img> 、<input>、<iframe>`，这几个标签是不支持类似 img::before 这样使用。

究其原因，要想要标签支持伪元素，需要这个元素是要可以插入内容的，也就是说这个元素要是一个容器。而 input，img，iframe 等元素都不能包含其他元素，所以不能通过伪元素插入内容。

### 20 如果需要⼿动写动画，你认为最⼩时间间隔是多久，为什么？

多数显示器默认频率是60Hz ，即1 秒刷新60 次，所以理论上最⼩间隔为1/60*1000ms ＝ 16.7ms

### 21 CSS合并⽅法

避免使⽤@import 引⼊多个css ⽂件，可以使⽤CSS ⼯具将CSS 合并为⼀个CSS ⽂件，例如使⽤Sass\Compass 等

### 22 CSS优先级算法，CSS不同选择器的权重，CSS的特殊性 

**CSS优先级算法**

**优先级就近原则**，同权重情况下样式定义最近者为准
载⼊样式以**最后载⼊**的定位为准
优先级为: !important > id > class > tag ; !important ⽐ 内联优先级⾼

**CSS的特殊性**/**CSS不同选择器的权重**

 在CSS中，会根据选择器的特殊性来决定所定义的样式规则的次序，具有更特殊选择器的规则优先于具有一般选择器的规则，如果两个规则的特殊性相同，那么后定义的规则优先。计算规则可以看下面一张图： 

 ![img](/../../../../Typora图库/Web前端/css特殊性.png) 

我们把特殊性分为4个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。

*！important 规则最重要，⼤于其它规则*

 第一等：代表内联样式，如: style=””，权值为1000。
 第二等：代表ID选择器，如：#content，权值为100。
 第三等：代表类，伪类和属性选择器，如.content，权值为10。
 第四等：代表类型选择器和伪元素选择器，如div p，权值为1。
 注意：通用选择器（*），子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为0。

### 23 列出你所知道可以改变⻚⾯布局的属性

position 、display 、float 、width 、height 、margin 、padding 、top 、left 、right

### 24 CSS在性能优化⽅⾯的实践

css 压缩与合并、Gzip 压缩
css ⽂件放在head ⾥、不要⽤@import
尽量⽤缩写、避免⽤滤镜、合理使⽤选择器

### 25 CSS3动画（transition 、transform 、animation）

- 依靠CSS3 中提出的三个属性： transition 、transform 、animation
- transition ：定义了元素在变化过程中是怎么样的，包含transition-property 、transition-duration 、transition-timing-function 、transition-delay 。
- transform ：定义元素的变化结果，包含rotate 、scale 、skew 、translate 。
- animation ：动画定义了动作的每⼀帧（ @keyframes ）有什么效果，包括animation-name， animation-duration 、animation-timing-function 、animation-delay、animation-iteration-count 、animation-direction

**transition和animation的区别**

Animation和transition大部分属性是相同的，他们**都是随时间改变元素的属性值**

他们的主要区别是**transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值**，并且transition为2帧，从from .... to，而animation可以一帧一帧的。

**说⼀说css3的animation**

- css3的animation 是css3新增的动画属性，这个css3动画的每⼀帧是通过@keyframes来声明的， keyframes 声明了动画的名称，通过from 、to 或者是百分⽐来定义
- 每⼀帧动画元素的状态，通过animation-name 来引⽤这个动画，同时css3动画也可以定义动画运⾏的时⻓、动画开始时间、动画播放⽅向、动画循环次数、动画播放的⽅式，
- 这些相关的动画⼦属性有： animation-name 定义动画名、animation-duration 定义动画播放的时⻓、animation-delay 定义动画延迟播放的时间、animationdirection定义 动画的播放⽅向、animation-iteration-count 定义播放次数、animation-fill-mode 定义动画播放之后的状态、animation-play-state 定义播放状态，如暂停运⾏等、animation-timing-function
- 定义播放的⽅式，如恒速播放、艰涩播放等。

**关于js动画和css3动画的差异性**

渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。 区别：

- 功能涵盖面，js比css大
- 实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定
- 对帧速表现不好的低版本浏览器，css3可以做到自然降级
- css动画有天然事件支持
- css3有兼容性问题


### 26 base64

优点可以加密，减少了HTTTP 请求
缺点是需要消耗CPU 进⾏编解码

**base64 的使⽤**

⽤于减少 HTTP 请求
适⽤于⼩图⽚
base64 的体积约为原图的4/3

### 27 sass（scss）、less、postcss、stylus等

它们都是css预处理器。**CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用**。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。 

其中比较优秀的： Sass、LESS，Stylus，均具有“变量”、“混合”、“嵌套”、“继承”、“颜⾊混合”五⼤基本特性

- Sass(Syntactically Awesome Stylesheets)：

  Sass是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

  *Sass与Scss是什么关系?*

  Sass的**缩排语法**，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是**用{}取代了原来的缩进**。

- Less：

  Less也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数.  Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。

- Stylus： 

   主要用来给Node项目进行CSS预处理支持，人气不如前两者

  Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。

  需要安装node

  Stylus的语法花样多一些，它的文件扩展名是“.styl”，Stylus也接受标准的CSS语法，但是他也像Sass老的语法规则，使用缩进控制，同时Stylus也接受不带大括号（｛｝）和分号的语法

**为什么要使⽤它们？**

- 结构清晰，便于扩展。
- 可以⽅便地屏蔽浏览器私有语法差异。这个不⽤多说，封装对浏览器语法差异的重复处理，减少⽆意义的机械劳动。
- 可以轻松实现多重继承。
- 完全兼容 CSS 代码，可以⽅便地应⽤到⽼项⽬中。LESS 只是在 CSS 语法上做了扩展，所以⽼的 CSS 代码也可以与 LESS 代码⼀同编译

#### **Sass/Scss与Less、stylus区别**

1 **编译环境不一样**

Sass的安装需要Ruby环境，是在服务端处理的，

Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中。

Stylus需要安装node，然后安装最新的stylus包即可使用

2 **变量符不一样**

Less是@，而Scss是$， Stylus样式中声明变量没有任何限定，你可以使用“$”符号开始。结尾的分号（;）可有可无，但变量名和变量值之间的等号（=）是需要的。

有一点需要注意的是，如果我们使用“@”符号开头来声明变量，Stylus会进行编译，但其对应的值并不会赋值给变量。换句话说，**在Stylus中不要使用“@”符号开头声明变量**。Stylus中调用变量的方法和LESS、Sass是完全相同的。 

3 **变量的作用域不一样**

less和scss、stylus中的变量会随着作用域的变化而不一样。Sass的作用域最差，less和stylus一样，都是向上查找，直到找到根部位置 

4 **输出设置**

Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded，stylus不知。

输出样式的风格可以有四种选择，默认为nested：

- nested：嵌套缩进的css代码
- expanded：展开的多行css代码
- compact：简洁格式的css代码
- compressed：压缩后的css代码

5 **处理条件语句**

Sass支持条件语句，可以使用if{}else{},for{}循环等等。

LESS的条件语句使用有些另类，他不是我们常见的关键词if和else if之类，而其实现方式是利用关键词“when”。

stylus的条件语句的使用和其他编程的条件语句使用基本类似，不同的是他可以在样式去省略大括号｛｝

6 **引用外部CSS文件**

scss引用的外部文件命名必须以`_`开头, 如下例所示:其中`_test1.scss`、`_test2.scss`文件分别设置的h1 h2 。文件名如果以下划线`_`开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.

Less引用外部文件和css中的@import没什么差异。

Stylus同样可以用@import，也支持其他文件通过@import进行引入

7 **工具库不同**

Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。

Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。

stylus有一个的英文面向移动端的样式工具库 Archer。Archer于起源est项目，专注纯移动端的浏览器

**总结：**

不管是Sass，还是Less或者stylus，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass、stylus的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。

#### postcss

-  PostCSS 是目前流行的一个对 CSS 进行处理的工具（平台）。 
-  PostCSS 本身是一个功能比较单一的工具。它提供了⼀个解析器来处理 CSS。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。 
- 通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的CSS ，postcss 可以对sass处理过后的css 再处理 最常⻅的就是autoprefixer

### 28

### 29 

### 30 层叠(z-index)

#### **层叠上下文** 

**层叠上下文** (堆叠上下文, Stacking Context)，是HTML中一个三维的概念。在CSS2.1规范中，每个元素的位置是三维的，当元素发生层叠，这时它可能覆盖了其他元素或者被其他元素覆盖；**排在z轴越靠上的位置，距离屏幕观察者越近**。 

每一个网页都有一个默认的层叠上下文。 这个层叠上下文（桌子）的根源就是`html`元素。 html标签中的一切都被置于这个默认的层叠上下文的一个层叠层上（物品放在桌子上）。当你给一个元素赋予了除 auto (自动) 外的z-index值时，你就创建了一个新的层叠上下文，其中有着独立于页面上其他层叠上下文和层叠层的层叠层。 这就相当于你把另一张桌子带到了房间里。

在层叠上下文中，其子元素按照上面解释的规则进行层叠。形成层叠上下文的方法有：

- 根元素 `<html></html>`
- position值为 absolute|relative，且 z-index值不为 auto
- position 值为 fixed|sticky
- z-index 值不为 auto 的flex元素，即：父元素 display:flex|inline-flex
- opacity 属性值小于 1 的元素
- transform 属性值不为 none的元素
- mix-blend-mode 属性值不为 normal 的元素
- filter、 perspective、 clip-path、 mask、 mask-image、 mask-border、 motion-path 值不为 none 的元素
- perspective 值不为 none 的元素
- isolation 属性被设置为 isolate 的元素
- will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值
- -webkit-overflow-scrolling 属性被设置 touch的元素

总结：

1. 层叠上下文可以包含在其他层叠上下文中，并且一起组建了一个有层级的层叠上下文
2. 每个层叠上下文完全独立于它的兄弟元素，**当处理层叠时只考虑子元素**，这里类似于BFC
3. 每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会**在父级叠上下文**中按顺序进行层叠



#### **层叠等级** 

**层叠等级** (层叠水平, Stacking Level) 决定了同一个层叠上下文中元素在z轴上的显示顺序的**概念**：

- 普通元素的层叠等级优先由其所在的层叠上下文决定
- 层叠等级的比较只有在同一个层叠上下文元素中才有意义
- 在同一个层叠上下文中，层叠等级描述定义的是该层叠上下文中的元素在Z轴上的上下顺序

注意，层叠等级并不一定由 z-index 决定，只有定位元素的层叠等级才由 z-index 决定，其他类型元素的层叠等级由层叠顺序、他们在HTML中出现的顺序、他们的父级以上元素的层叠等级一同决定，详细的规则见下面层叠顺序的介绍。



#### **z-index**

CSS允许我们对z-index属性设置三种值。

- auto (自动，默认值)
- (整数)
- inherit (继承)

目前，先让我们关注在整数值上。 整数值可以是正值，负值，或0。数值越大，元素也就越靠近观察者。 数值越小，元素看起来也就越远。

z-index 只适用于定位的元素，对非定位元素无效，它可以被设置为正整数、负整数、0、auto，如果一个定位元素没有设置 z-index，那么默认为auto。

元素的 z-index 值只在同一个层叠上下文中有意义。如果父级层叠上下文的层叠等级低于另一个层叠上下文的，那么它 z-index 设的再高也没用。所以如果你遇到 z-index 值设了很大，但是不起作用的话，就去看看它的父级层叠上下文是否被其他层叠上下文盖住了。



#### **层叠顺序**

**层叠顺序** (层叠次序, 堆叠顺序, Stacking Order) 描述的是元素在同一个层叠上下文中的顺序**规则**，从层叠的底部开始，共有七种层叠顺序：

1. **背景和边框**：形成层叠上下文的元素的背景和边框。
2. **负z-index值**：层叠上下文内有着负z-index值的定位子元素，负的越大层叠等级越低；
3. **块级盒**：文档流中块级、非定位子元素；
4. **浮动盒**：非定位浮动元素；
5. **行内盒**：文档流中行内、非定位子元素；
6. **z-index: 0**：z-index为0或auto的定位元素， 这些元素形成了新的层叠上下文；
7. **正z-index值**：z-index 为正的定位元素，正的越大层叠等级越高；

同一个层叠顺序的元素按照在HTML里出现的顺序层叠；
第7级顺序的元素会显示在之前顺序元素的上方，也就是看起来覆盖了更低级的元素：

 ![7阶层叠水平](/../../../../Typora图库/Web前端/7阶层叠水平.png) 

**比较两个DOM元素显示顺序**

- 如果是在相同的层叠上下文，按照层叠水平的规则来显示元素
- 如果是在不同的层叠上下文中，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下这个两个元素所在的局部层叠上下文的层叠水平。

### 31 外边距重叠

外边距重叠就是margin-collapse

在CSS当中，**相邻的两个盒⼦**（可能是兄弟关系也可能是祖先关系）**的外边距可以结合成⼀个单独的外边距**。这种合并外边距的⽅式被称为折叠，并且因⽽所结合成的外边距称为折叠外边距。

折叠结果遵循下列计算规则：

- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较⼤的值。
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较⼤值。
- 两个外边距⼀正⼀负时，折叠结果是两者的相加的和。

### 32 去除display:inline-block间隙

在CSS布局中，如果我们想要将一些元素在同一行显示，其中的一种方法就是把要同行显示对的元素设置display属性为inline-block。但是你会发现这些同行显示的inline-block元素之间经常会出现一定的空隙。

元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，所以元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。

1、删去元素之间的空白

```html
<ul> 
    <li> 
    one</li><li>
    two</li><li> 
    three</li> 
</ul> 
<!-- or --> 
<ul> 
    <li>one</li  
    ><li>two</li  
    ><li>three</li> 
</ul> 
<!-- or -->
 <ul> 
     <li>one</li><!--  
     --><li>two</li><!--  
     --><li>three</li> 
 </ul>
```

2、使用margin负值

```css
.space a {
    display: inline-block;
    margin-right: -3px;
}
```

此方法不靠谱，不同浏览器空格大小不统一，不能一次性解决问题。

3、在父元素中设置font-size: 0，然后在子元素上重置正确的font-size。

 缺点：inline-block元素必须设定字体，不然行内元素中的字体不不显示。 

```css
<div class="demo">
        <span>我是一个span
        <span>我是一个span</span>
    </div>
    .demo {font-size: 0;}
    .demo span{
         background:#ddd;
         display: inline-block;
         font-size: 14px; /*要设置相应的字号*/
    }
```

4、使用letter-spacing

给父级元素设置一个较大在负值，在元素上将letter-spacing归0。

 优点：因为使用了letter-spacing相对单位em表示距离，所以不需要根据字体大小改变代码来去除元素间距。 

```css
<div>
    <span>测试</span>
    <span>测试</span>
</div>
div{
   letter-spacing: -0.5em;
}
span{
    display: inline-block;
    letter-spacing: 0;
}
```

5、使用word-spacing

 优点：因为使用了word-spacing相对单位em表示距离，所以不需要根据字体大小改变代码来去除元素间距。 

```css
.space {
    word-spacing: -6px;
}
.space a {
    word-spacing: 0;
}
```

 一个是字符间距(`letter-spacing`)一个是单词间距(`word-spacing`)，大同小异。据我测试，`word-spacing`的负值只要大到一定程度，其兼容性上的差异就可以被忽略。因为，貌似，`word-spacing`即使负值很大，也不会发生重叠。 

6、取消标签闭合

```html
<div class="space">
    <a href="##">惆怅
    <a href="##">淡定
    <a href="##">热血
</div>
```

### 33 css中可以让⽂字在垂直和⽔平⽅向上重叠的两个属性是什么？

垂直⽅向： line-height
⽔平⽅向： letter-spacing

### 34 如何使⽤CSS实现硬件加速？

硬件加速是指通过创建独⽴的复合图层，让GPU来渲染这个图层，从⽽提⾼性能。

⼀般触发硬件加速的CSS 属性有transform 、opacity 、filter ，为了避免2D动画在开始和结束的时候的repaint 操作，⼀般使⽤tranform:translateZ(0)

### 35 px和em的区别

- px 和em 都是⻓度单位，区别是， **px 的值是固定的**，指定是多少就是多少，计算⽐较容易。em 的值不是固定的，并且**em 会继承⽗级元素的字体⼤⼩**。
- 浏览器的默认字体⾼都是16px 。所以**未经调整的浏览器都符合: 1em=16px** 。那么12px=0.75em , 10px=0.625em 。

### 36 css的content属性

css的content 属性**专⻔应⽤在 before/after 伪元素**上，**⽤于来插⼊⽣成内容**。最常⻅的应⽤是**利⽤伪类清除浮动**。

### 37

### 38 ⽔平居中的⽅法

- 元素为⾏内元素，设置⽗元素text-align:center
- 如果元素宽度固定，可以设置左右margin 为auto ;
- 如果元素为绝对定位，设置⽗元素position 为relative ，元素设left:0;right:0;margin:auto;
- 使⽤flex-box 布局，指定justify-content 属性为center
- display 设置为tabel-ceil

### 39 垂直居中的⽅法

- 将显示⽅式设置为表格， display:table-cell ,同时设置vertial-align：middle
- 使⽤flex 布局，设置为align-item：center
- 绝对定位中设置bottom:0,top:0 ,并设置margin:auto
- 绝对定位中固定⾼度时设置top:50%，margin-top 值为⾼度⼀半的负值
- ⽂本垂直居中设置line-height 为height 值

### 40 两种以上⽅式实现已知或者未知宽度的垂直⽔平居中

- **flex**

   Flex布局即为弹性布局，只需将父元素设置三个属性即可**(display,justify-content,align-items)** 

- **绝对定位+margin负值（已知宽高）**

  利用负边距实现子元素居中(相对于父元素(position:relative))，需已知子元素的width与height；且把子元素的position设为absolute，绝对定位；以及设置left和top为50%；再加上负边距，margin-left值为width的一半，同样的，margin-top值为height的一半。

  我们来理解一下，绝对定位的子元素，通过自身的边界来相对于父元素进行定位，这个边界就是margin，当我们设置了left和top各为50%时，子元素左边界距父元素左边界50%,上边界距父元素上边界50%，其实此时，我们可以知道，子元素的左上角这个点，是水平垂直居中的，当我们设了负边距时，我们可以理解为这个子元素向右向上各移了自身长度的一半，这就达到了水平垂直居中。当然我们也可以这么理解，其实真正相对于父元素来定位的点就是子元素左上角的点，当我们设了负边距，子元素的中心点就取代了它左上角的点，若希望子元素能水平垂直居中，这时只需再设left和top各为50%时便可。

- **绝对定位+transfrom负值（未知宽高）**

- **绝对定位top left right bottom 0 + margin auto**

  使用绝对定位方式, 以及left:0;right:0;top:0;bottom:0;margin:auto

  当我们为子元素设置left:0;right:0;top:0;bottom:0;时，浏览器将给子元素重新分配一个边界框，此时子元素将填充其父元素的所有可用空间，当我们给子元素设置一个width或height，防止子元素占据所有的可用空间，浏览器将根据新的边界框重新计算，再加上margin:auto,由于被绝对定位，脱离了正常的文档流，浏览器会给margin-left,margin-right相同的值，margin-top,margin-bottom相同的值，使元素块在父元素中水平垂直居中。

- **display:table**

总结：

1.利用负边距方法优点是具有良好的跨浏览器特性，兼容IE6/IE7，但是缺点是不能自适应，需设置子元素的宽高，不支持百分比，且负边距值与padding和是否定义box-sizing: border-box有关，计算需要根据不同情况。

2.利用margin:auto方法支持跨浏览器，支持百分比，但是必须声明子元素的width或height(至少一项，不然会占据父元素所有空间)。

*这两种绝对定位方法，可在子元素中，设置overflow:auto来防止内容越界溢出*。

3.利用flex或transform方法的好处是代码量少，且你不用设置子元素的width与height,内容可由子元素里的子元素任意撑开，优雅地溢出。但flex IE8/IE9不支持，transform IE8不支持，且属性需要写浏览器厂商前缀。

```css
/** 1 **/
.wraper {
	.box {
		display: flex;
		justify-content:center;
		align-items: center;
		height: 100px;
	}
}

/** 2 **/
.wraper {
	position: relative;
	.box {
		position: absolute;
		top: 50%;
		left: 50%;
		width: 100px;
		height: 100px;
		margin: -50px 0 0 -50px;
        overflow: auto;
	}
}

/** 3 **/
.wraper {
	position: relative;
	.box {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
	}
}

/** 4 **/
.wraper {
	position: relative;
	.box {
		position: absolute;
		top: 0;
        bottom: 0;
		left: 0;
        right: 0;
		width: 100px;
		height: 100px;
		margin: auto;
        overflow: auto;
	}
}

/** 5 **/
.wraper {
	display: table;
	.box {
		display: table-cell;
		vertical-align: middle;
	}
}
```

### 41 margin/padding百分比值的计算

在默认的水平文档流方向下，CSS margin和padding属性的垂直方向的百分比值都是相对于**父元素宽度**计算的。

 为何这么设计呢？其实相对高度计算也没什么问题，但是如果padding相对于height计算，大多数情况下计算值都是0，跟摆设没什么区别，还不如相对宽度计算，因为CSS默认的是水平流，计算值一直会有效 。

### 42 CSS控制前端图片HTTP请求的各种情况示例

1.  **隐藏图片** 

   ```html
   <img src="haorooms.jpg" style="display: none" /> 
   ```

    结论：只有Opera不产生请求。 注意：用visibility: hidden隐藏图片时，在Opera下也会产生请求。 

2.  **重复图片** 

   ```html
   <img src="haorooms.jpg" />  
   <img src="haorooms.jpg" />  
   ```

    结论：所有浏览器都只产生一次请求 。 

3.  **重复背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg) }   
       .test2 { background: url(haorooms.jpg) }   
   </style>   
   
   <div class="test1">test1</div>   
   <div class="test2">test2</div> 
   ```

    结论：所有浏览器都只产生一次请求。 

4.  **不存在的元素的背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg) }   
       .test2 { background: url(http2.jpg) } /* 页面中没有class为test2的元素 */  
   </style>   
   
   <div class="test1">test1</div>  
   ```

    结论：背景仅在应用的元素在页面中存在时，才会产生请求。这对CSS框架来说，很有意义。 

5.  **隐藏元素的背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg); display: none; }   
       .test2 { background: url(http2.jpg); visibility: hidden; }   
   </style>   
     
   <div class="test1">test1</div> 
   ```

    结论：Opera和Firefox对于用display: none隐藏的元素背景，不会产生HTTP请求。仅当这些元素非display: none时，才会请求背景图片。 

6.  **多重背景** 

   ```html
   <style type="text/css">   
       .test1 { background: url(haorooms.jpg); }   
       .test1 { background: url(http2.jpg); }   
   </style>   
   
   <div class="test1">test1</div>  
   ```

   上面这段代码的http请求，只会请求http2.jpg这一张图片，原因是test1的class把上面的给覆盖掉了，**所有只请求后面的一张图片！**

   假如用css3多张背景图片的写法：

   ```html
   <style type="text/css">   
       .test1 { background-image:url("haorooms.jpg"),url("http2.jpg"); }   
   </style>   
   
   <div class="test1">test1</div>  
   ```

    webkit引擎浏览器对背景图都请求，是因为支持CSS3中的多背景图。 

7.  **hover的背景加载** 

   ```html
   <style type="text/css">   
       a.test1 { background: url(haorooms.jpg); }   
       a.test1:hover { background: url(http2.jpg); }   
   </style>   
   
   <a href="#" class="test1">test1</a>  
   ```

    结论：触发hover时，才会请求hover状态下的背景。不触发的话，只请求默认的背景图片。 

### 43 position值

**position: absolute**

- 绝对定位是以**父元素的左上角原点**为定位基准点，absolute 会**将对象拖离出正常的文档流**绝对定位而不考虑它周围内容的布局。
- 假如其他具有不同 z-index 属性的对象已经占据了给定的位置，他们之间不会相互影响，而会在同一位置层叠。
- 如果父级（无限）没有设定position属性，那么当前的absolute则结合TRBL属性**以浏览器左上角**为原始点进行定位；
- 如果父级（无限）设定position属性，那么当前的absolute则结合TRBL属性以**父级（最近）的左上角**为原始点进行定位。
-  注意：绝对定位的窗口一般都要设置相对距离，当你同时设置top和bottom的时候，只有top会生效，同理，同时设置left和right的时候，只有left会生效。 

**Tips:**

- **要激活对象的绝对(absolute)定位，必须指定 left ， right ， top ， bottom 属性中的至少一个**，并且设置此属性值为 absolute 。否则上述属性会使用他们的默认值 auto ，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递。
- **TRBL属性（TOP、RIGHT、BOTTOM、LEFT）只有当设定了position属性才有效**，position：relative也可以生效。

**position:relative**

- 相对定位是相对其初始位置进行偏移定位的，当设定position: relative 则**参照父级（最近）的内容区的左上角为原始点结合TRBL属性进行定位**（或者说相对于被定位元素在父级内容区中的上一个元素进行偏移），无父级则以BODY的左上角为原始点。
- 相对定位是不能层叠的。在使用相对定位时，**无论元素是否进行移动，元素依然占据原来的空间**（如果不好理解，下面案例说明了这一点）。因此，移动元素会导致它覆盖其他框。

**总结**

图层覆盖顺序由上到下为：**相对>绝对>默认**，初始状态（没有加top偏移时候的初始状态）的相对div在左上角覆盖绝对div的上半部分，经过top偏移后移动到下方，但是默认的那个div仍然没有自动顶上去，because相对定位的初始位置依然是被占据的。

父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。

**position的几种值**

**absolute** ：⽣成绝对定位的元素，相对于 static 定位以外的第⼀个⽗元素进⾏定位， 其他盒子与其他盒子内的文本都会无视它， 都绝对定位了，肯定脱离了文档流。 元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。可通过z-index进行层次分级。

**fixed** ：⽣成绝对定位的元素，相对于浏览器窗⼝进⾏定位， 相对于浏览器了，也和正常顺序排下来没什么关系。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。可通过z-index进行层次分级。

**relative** ：⽣成相对定位的元素，相对于其正常位置进⾏定位 。生成相对定位，也就是说还在原本的上下左右之间，上下左右的元素都不变，so这个没有能脱离文档流。这个是 **半脱离文档流**的方法。通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。

> 所谓的半脱离文档流，本体还在文档流中占有位置，但是却可以通过改变位置使其漂浮到其他的地方，其定位方式是相对其原先在文档流中的位置进行定位的。 

**static** 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

**inherit** 规定从⽗元素继承 position 属性的值

### 44 脱离文档流

**什么是文档流？**

将窗体自上而下分成一行一行，并在每行中按从左至右依次排放元素，称为文档流，也称为普通流。

这个应该不难理解，HTML中全部元素都是盒模型，盒模型占用一定的空间，依次排放在HTML中，形成了文档流。

**什么是脱离文档流？**

元素脱离文档流之后，将**不再在文档流中占据空间**，而是处于**浮动状态**（可以理解为漂浮在文档流的上方）。脱离文档流的元素的定位基于正常的文档流，当一个元素脱离文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。

**怎么脱离文档流？**

1. float

    使用float可以脱离文档流。  注意！！！：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。 

2. absolute

    absolute称为绝对定位，其实博主觉得应该称为相对定位，因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，并且这个父类元素的position必须是非static定位的（static是默认定位方式）。 

3. fixed

    完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。 

### 45  box-shadow 实现阴影

```css
/* offset-x | offset-y | color */
box-shadow: 60px -16px teal;
 
/* offset-x | offset-y | blur-radius | color */
box-shadow: 10px 5px 5px black;
 
/* offset-x | offset-y | blur-radius | spread-radius | color */
box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);
 
/* inset | offset-x | offset-y | color */
box-shadow: inset 5em 1em gold;
 
/* Any number of shadows, separated by commas */
box-shadow: 3px 3px red, -1em 0 0.4em olive;
 
/* Global keywords */
box-shadow: inherit;
box-shadow: initial;
box-shadow: unset;
```

取值说明：

- `inset`: 默认阴影在边框外。使用 inset 后，阴影在边框内（即使是透明边框），背景之上内容之下。也有些人喜欢把这个值放在最后，浏览器也支持。

- ` <offset-x> <offset-y>`: 这是头两个 `<length>`值，用来设置阴影偏移量。`<offset-x>` 设置水平偏移量，如果是负值则阴影位于元素左边。 `<offset-y>` 设置垂直偏移量，如果是负值则阴影位于元素上面。可用单位请查看 `<length>`。如果两者都是0，那么阴影位于元素后面。这时如果设置了 `<blur-radius>` 或 `<spread-radius>` 则有模糊效果。

- `<blur-radius>`: 这是第三个 `<length>` 值。值越大，模糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。

- `<spread-radius>` : 这是第四个 `<length>` 值。取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素同样大。

- `<color>` : 相关事项查看 `<color>` 。如果没有指定，则由浏览器决定——通常是color的值，不过目前Safari取透明。

再说的具体一点：

```css
div {
    width: 150px;
    height: 150px;
    background-color: #fff;
    
    box-shadow: 120px 80px 40px 20px #0ff;
    /* 顺序为: offset-x, offset-y, blur-size, spread-size, color */
    /* blur-size 和 spread-size 是可选的 (默认为 0) */
}
```

 ![CSS3 box-shadow 属性图解](/../../../../Typora图库/Web前端/box-shadow-diagram.png) 

## 三、JavaScript

### 1 闭包

- 闭包就是**能够读取其他函数内部变量的函数**，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。 

- 闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域

  ```js
  function A() {
  	let a = 1
  	function B() {
  		console.log(a)
  	}
  	return B
  }
  //为什么函数 A 已经弹出调⽤栈了，为什么函数 B 还能引⽤到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。
  ```

- 闭包的特性：
  - 函数内再嵌套函数
  - 内部函数可以引⽤外层的参数和变量
  - 参数和变量不会被垃圾回收机制回收

对闭包的理解：

- 使⽤闭包主要是**为了设计私有的⽅法和变量**。闭包的优点是可以**避免全局变量的污染**，缺点是**闭包会常驻内存，会增⼤内存使⽤量**，使⽤不当很容易造成内存泄露。**在js中，函数即闭包，只有函数才会产⽣作⽤域的概念**
- 闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中
- 闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法
- 好处：能够实现封装和缓存等；
- 坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题

使⽤闭包的注意点：

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露
- 解决⽅法是，**在退出函数之前，将不使⽤的局部变量全部删除**

**具体场景**

**1. 闭包应用场景之setTimeout**

原生的setTimeout传递的第一个函数不能带参数,通过闭包可以实现传参效果

```js
    setTimeout(function(param){
        alert(param)
    },1000)

    //通过闭包可以实现传参效果
    function func(param){
        return function(){
            alert(param)
        }
    }
    var f1 = func(1);
    setTimeout(f1,1000);
```

**2.闭包应用场景之回调**

我们定义行为，然后把它关联到某个用户事件上（点击或者按键）。我们的代码通常会作为一个回调（事件触发时调用的函数）绑定到事件上

```js
<body>
    <p>哈哈哈哈哈哈</p>
    <h1>hhhhhhhhh</h1>
    <h2>qqqqqqqqq</h2>
    <a href="#" id="size-12">12</a>
    <a href="#" id="size-14">14</a>
    <a href="#" id="size-16">16</a>

<script>
    function changeSize(size){
        return function(){
            document.body.style.fontSize = size + 'px';
        };
    }

    var size12 = changeSize(12);
    var size14 = changeSize(14);
    var size16 = changeSize(16);

    document.getElementById('size-12').onclick = size12;
    document.getElementById('size-14').onclick = size14;
    document.getElementById('size-16').onclick = size16;
</script>
</body>
```

**3.闭包应用场景之封装变量**

用闭包定义能访问私有函数和私有变量的公有函数

```js
    var counter = (function(){
        var privateCounter = 0; //私有变量
        function change(val){
            privateCounter += val;
        }
        return {
            increment:function(){   //三个闭包共享一个词法环境
                change(1);
            },
            decrement:function(){
                change(-1);
            },
            value:function(){
                return privateCounter;
            }
        };
    })();

    console.log(counter.value());//0
    counter.increment();
    counter.increment();//2
```

1. 共享的环境创建在一个匿名函数体内，立即执行。
2. 环境中有一个局部变量一个局部函数，通过匿名函数返回的对象的三个公共函数访问。

封装一个私有变量另一个例子：用JavaScript创建一个计数器：

```js
'use strict';
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
```

运行结果：

```js
var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说， **闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。**

**4.闭包应用场景之为节点循环绑定click事件**

```js
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
```

在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。

你可能认为调用f1()，f2()和f3()结果应该是 `1 4 9`， 但实际结果是：

```js
f1(); // 16
f2(); // 16
f3(); // 16
```

全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。

**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**

如果一定要引用循环变量怎么办？方法是**再创建一个函数**，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```js
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];

f1(); // 1
f2(); // 4
f3(); // 9
```

注意这里用了一个“创建一个匿名函数并立刻执行”的语法：

```js
(function (x) {
    return x * x;
})(3); // 9
```

**5.ES6不经意中闭包的应用**

有时候闭包会在你不经意的时候出现，你可能已经看到了我们称之为局部应用程序的示例，如下面的代码所示。

```js
let c = 4
const addX = x => n => n + x
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)
```

如果不使用箭头函数，等效的代码如下：

```js
let c = 4
function addX(x) {
  return function(n) {
     return n + x
  }
}
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)
```

我们声明了一个通用加法函数 addX，它接受一个参数（x）并返回另一个函数。

返回的函数也接受一个参数并将其与变量 x 相加。

变量 x 是闭包的一部分，当在本地上下文中声明变量 addThree 时，它会分配到一个函数定义和一个闭包，闭包含变量 x。

所以，当调用并执行 addThree 时，它可以从闭包中访问变量 x 和变量 n（作为参数传递进去），并返回相加的和。

在这个示例中，控制台将打印数字 7。


### 2 JavaScript作用域和作⽤域链

- 作⽤域链的作⽤是**保证执⾏环境⾥有权访问的变量和函数是有序的**，作⽤域链的**变量只能向上访问**，变量访问到window 对象即被终⽌，作⽤域链向下访问变量是不被允许的
- 简单的说，作⽤域就是变量与函数的可访问范围，即**作⽤域控制着变量与函数的可⻅性和⽣命周期**



1. 在JavaScript中，通过 `let` 和 `const` 定义的变量具有块级作用域的特性。
2. 通过 `var` 定义的变量会在它自身的作用域中进行提升，而 `let` 和 `const` 定义的变量不会。
3. 每个JavaScript程序都具有一个全局作用域，每创建一个函数都会创建一个作用域。
4. 在创建函数时，将这些函数进行嵌套，它们的作用域也会嵌套，形成作用域链，子作用域可以访问父作用域，但是父作用域不能访问子作用域。
5. 在执行一个函数时，如果我们需要查找某个变量值，那么会去这个函数被 **定义** 时所在的作用域链中查找，一旦找到需要的变量，就会停止向上查找。
6. “变量的**值**由函数定义时的位置决定”这句话有歧义，准确说是**查找**变量时，是去定义这个函数时所在的作用域链查找。

 其实记住2条规则，大部分作用域的面试题都可以解，**1、function 提升 优先 var 2、同名的，后面覆盖前面。** 

 ![img](/../../../../Typora图库/Web前端/作用域链.png)

### 3 JavaScript原型，原型链

- 每个对象都会在其内部初始化⼀个属性，就是prototype (原型)，当我们访问⼀个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype ⾥找这个属性，这个prototype ⼜会有⾃⼰的prototype ，于是就这样⼀直找下去，也就是我们平时所说的原型链的概念
- 关系：` instance.constructor.prototype = instance.__proto__`
- 特点：JavaScript 对象是**通过引⽤来传递的**，我们创建的每个新对象实体中并没有⼀份属于⾃⼰的原型副本。当我们修改原型时，与之相关的对象也会继承这⼀改变（复制需要深拷贝）
- 当我们需要⼀个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的Prototype 对象是否有这个属性，如此递推下去，⼀直检索到 Object 内建对象

![2018-07-10 2 38 27](/../../../../Typora图库/Web前端/原型.png) 

- 每个函数都有 prototype 属性，除了 Function.prototype.bind() ，该属性指向原型。
- 每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]] ，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使⽤ _proto_ 来访问。
- 对象可以通过__proto__ 来寻找不属于该对象的属性， __proto__ 将对象连接起来组成了原型链。

#### `Function._proto_(getPrototypeOf)`是什么？

获取一个对象的原型，在chrome中可以通过__proto__的形式，或者在ES6中可以通过`Object.getPrototypeOf`的形式。

那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。

```js
Function.__proto__ == Object.prototype //false
Function.__proto__ == Function.prototype//true
```

我们发现**Function的原型也是Function**。

### 4 构造函数，原型对象，实例对象三者之间的关系

1. 构造函数可以实例化对象

2. 构造函数中有有一个属性叫prototype，是构造函数的原型对象

3. 构造函数的原型对象（prototype）中有一个constructor构造器，这个构造器指向的就是自己所在的原型对象的所在构造函数

4. 实例对象的原型对象（__ proto __）指向的是该构造函数的原型对象

5. 构造函数的原型对象（prototyoe）中的方法是可以被实例对象直接访问的

    ![在这里插入图片描述](/../../../../Typora图库/Web前端/构造函数，原型对象，实例对象.png) 

### 5 Javascript如何实现继承(object.create)

1. 构造继承
2. 原型继承
3. 实例继承
4. 拷⻉继承
5. 组合继承
6. 寄生组合继承

（1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。

下面来创建一个Animal类：

```js
// 定义一个动物类
function Animal (name) {
  // 属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function(){
    console.log(this.name + '正在睡觉！');
  }
}
// 原型方法
Animal.prototype.eat = function(food) {
  console.log(this.name + '正在吃：' + food);
};
```

这样就生成了一个Animal类，实力化生成对象后，有方法和属性。

（2）类的继承——原型链继承

```js
--原型链继承
function Cat(){ }
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';
//&emsp;Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.eat('fish'));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
```

- 介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。
- 特点：基于原型链，既是父类的实例，也是子类的实例
- 缺点：无法实现多继承

（3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

- 特点：可以实现多继承
- 缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。

（4）实例继承和拷贝继承

实例继承：为父类实例添加新特性，作为子类实例返回

拷贝继承：拷贝父类元素上的属性和方法

上述两个实用性不强，不一一举例。

（5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
```

- 特点：可以继承实例属性/方法，也可以继承原型属性/方法
- 缺点：调用了两次父类构造函数，生成了两份实例

（6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
```

- 较为推荐

原型prototype 机制或apply 和call ⽅法去实现较简单，建议使⽤**构造函数与原型混合⽅式**

```javascript
function Parent(){
	this.name = 'wang';
}
function Child(){
	this.age = 28;
}
Child.prototype = new Parent();//继承了Parent，通过原型
var demo = new Child();
alert(demo.age);
alert(demo.name);//得到被继承的属性
```

在 ES5 中，我们可以使⽤如下⽅式解决继承的问题

```js
function person(name){
  this.name=name;
  this.className="person"
}
person.prototype.getName=function(){
   console.log(this.name)
}

function man(name){
   person.apply(this,arguments)
}
man.prototype = Object.create(person.prototype);

var man1=new man("Davin");
console.log(man1.name);      //Davin
console.log(man1.getName());     //Davin
  //constructor 属性返回对创建此对象的数组函数的引用。
console.log(person.prototype.constructor); //function person(name){... }
console.log(man.prototype.constructor); //function person(name){... }
```

以上继承实现思路就是将⼦类的原型设置为⽗类的原型

在 ES6 中，我们可以通过 class 语法轻松解决这个问题

```js
class MyDate extends Date {
	test() {
		return this.getTime()
	}
}
let myDate = new MyDate()
myDate.test()
```

但是 ES6 不是所有浏览器都兼容，所以我们需要使⽤ Babel 来编译这段代码。

如果你使⽤编译过得代码调⽤ myDate.test() 你会惊奇地发现出现了报错，因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调⽤ Date ⾥的函数的。所以这也侧⾯的说明了： ES6 中的 class 继承与ES5 中的⼀般继承写法是不同的。

既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承

```js
function MyData() {
}
MyData.prototype.test = function () {
	return this.getTime()
}
let d = new Date()
Object.setPrototypeOf(d, MyData.prototype)
Object.setPrototypeOf(MyData.prototype, Date.prototype)
```

以上继承实现思路：先创建⽗类实例 => 改变实例原先的 _proto__ 转⽽连接到⼦类的prototype => ⼦类的 prototype 的 __proto__ 改为⽗类的 prototype 。

通过以上⽅法实现的继承就可以完美解决 JS 底层的这个限制

### 6 This对象的理解

- this 总是指向函数的直接调⽤者（⽽⾮间接调⽤者）
- 如果有new 关键字， this 指向new 出来的那个对象
- 在事件中， this 指向触发这个事件的对象，特殊的是， IE 中的attachEvent 中的this 总是指向全局对象Window

#### this 指向有哪几种

- 1.默认绑定：全局环境中，this默认绑定到window。

- 2.隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象。

- 3.隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window。

  显式绑定：通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。

- 4.new绑定：如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。
  - 构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。
  - 如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。
  - 如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。

详解：

**直接调用**： 对于这直接调用方法来说，最后只要类似fun()这种调用，this最后都指向window 

```js
var name='window'
function fun(){
  var name="name"
  console.log(this.name)
}
fun()       //window

var name='window'
function fun(){
  var name='fun'
  console.log(this.name)
}
let obj={
  fun:fun,
  name:'hkj'
}
let f=obj.fun
f()         //window

var name='window'
function hello(){
  var name='hello'
  console.log(this.name)
}
let obj1={
  name:'obj1',
  hello
}
let obj2={
  name:'obj2',
  obj1
}
let fun=obj2.obj1.hello;
fun()       //window
```

**箭头函数**： 无论嵌套多少层箭头函数中的this与最外层非箭头函数this相同，**最外层非箭头函数**为fun()，其中的this指向window所以里面两个箭头函数也一样。 

```js
var name='hkj'
function fun(){
  var name="hkj1"
  return ()=>{
    var name='hkj2'
    console.log(this.name)          //hkj
    return ()=>{
      var name='hkj3'
      console.log(this.name)        //hkj
    }
  }
}
fun()()()
```

**当做属性调用**： 被当做属性调用时，函数中this指向对最后一个调用函数的对象。

```js
var name='window'
function fun(){
  var name='fun'
  console.log(this.name)
}
let obj={
  fun:fun,
  name:'hkj'
}
obj.fun()       //hkj
//这里指向obj,所以name为hkj

var name='window'
function hello(){
  var name='hello'
  console.log(this.name)
}
let obj1={
  name:'obj1',
  hello
}
let obj2={
  name:'obj2',
  obj1
}
obj2.obj1.hello()           //obj1
//这里引用了多层，但用上面的方法判断,hello()前面是obj1,所以this指向obj1，最后name为obj1
```

**定时器内this指向**： setTimeout中的this都指向window。 

```js
var name='window'
function hello(){
  setTimeout(function(){
    console.log(this.name)
  }, 100);
}
let obj={
  name:'obj',
  hello
}
obj.hello()     //widow

var name='window'
function hello(){
  console.log(this.name)
}
let obj={
  name:'obj',
  hello
}
setTimeout(obj.hello,1000)          //window
```

 解决办法：改为箭头函数，在setTimeout外层将this赋值给其他变量然后传入，或者call，aplly，bind等 

#### 改变函数内部 this 指针的指向函数（bind，apply，call的区别）

**call 和 apply 都是为了解决改变 this 的指向**。作⽤都是相同的，只是传参的⽅式不同。除了第⼀个参数外， **call 可以接收⼀个参数列表， apply 只接受⼀个参数数组**

```javascript
let a = {
	value: 1
}
function getValue(name, age) {
	console.log(name)
	console.log(age)
	console.log(this.value)
}
getValue.call(a, 'yck', '24')
getValue.apply(a, ['yck', '24'])
```

bind 的作⽤与call 和apply 相同，区别是**call 和apply 是⽴即调⽤函数，⽽bind 是返回了⼀个函数，需要调⽤的时候再执⾏。** 

```js
   var a ={
       name : "Cherry",
       fn : function (a,b) {
           console.log( a + b)
       }
   }
   var b = a.fn;
   b.call(a,1,2);//立即调用该函数
   b.bind(a,1,2)();//手动调用()，它返回一个原函数的拷贝（新的，不是原函数），并拥有指定的this值和初始参数。
```

 bind 的第一个参数会作为原函数运行时的 this 指向，不多说；而第二个开始的参数是可选的，当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。 

```js
function fn(a, b, c) {
  return a + b + c;
}

var _fn = fn.bind(null, 10);
var ans = _fn(20, 30, 40); // 60
```

 fn 函数需要三个参数，_fn 函数将 10 作为默认的第一个参数，所以只需要传入两个参数即可，如果你不小心传入了三个参数，放心，也只会取前两个。 



⼀个简单的call 函数实现如下

```javascript
Function.prototype.myCall = function (context) {
	var context = context || window
	// 给 context 添加⼀个属性
	// getValue.call(a, 'yck', '24') => a.fn = getValue
	context.fn = this
	// 将 context 后⾯的参数取出来
	var args = [...arguments].slice(1)
	// getValue.call(a, 'yck', '24') => a.fn('yck', '24')
	var result = context.fn(...args)
	// 删除 fn
	delete context.fn
	return result
}
```

⼀个简单的apply 函数实现如下

```javascript
Function.prototype.myApply = function (context) {
	var context = context || window
	context.fn = this
	var result
	// 需要判断是否存储第⼆个参数
	// 如果存在，就将第⼆个参数展开
	if (arguments[1]) {
		result = context.fn(...arguments[1])
	} else {
		result = context.fn()
	}
	delete context.fn
	return result
}
```

⼀个简单的bind 函数实现如下

```javascript
Function.prototype.bind = function(ctx) {
	var fn = this;
	return function() {
		fn.apply(ctx, arguments);
	};
};
```

#### 箭头函数

- 1.箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着**如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this**
- 2.箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象
- 3.不可以当作构造函数，也就是说，**不可以使⽤new 命令**，同样也没有new.target值和原型
- 4.**不可以使⽤yield 命令**，因此箭头函数不能⽤作Generator 函数

### 7  事件绑定、事件监听、事件委托（事件代理） 

**事件绑定：**

要想让 JavaScript 对用户的操作作出响应，首先要**对 DOM 元素绑定事件处理函数**。所谓事件处理函数，就是**处理用户操作的函数**，不同的操作对应不同的名称。

在JavaScript中，有三种常用的绑定事件的方法：

- 在DOM元素中直接绑定： 我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。 
- 在JavaScript代码中绑定： 在JavaScript代码中（即`script`标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 
- 绑定事件监听函数： 用 addEventListener() 或 attachEvent() 来绑定事件监听函数。 

**事件监听：**

-  element.addEventListener(event, function, useCapture) 
    -  event : （必需）事件名，支持所有[DOM事件](http://www.runoob.com/jsref/dom-obj-event.html)。
      function：（必需）指定要事件触发时执行的函数。
      useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 
  
-  element.attachEvent(event, function) 
  -  event：（必需）事件类型。需加“on“，例如：onclick。
  - function：（必需）指定要事件触发时执行的函数。 
  
-  优点：

    -   可以绑定多个事件。  常规的事件绑定只执行最后绑定的事件。 

    -   可以解除相应的绑定 （ removeEventListener ）

    -  封装事件监听

        ```js
        //绑定监听事件
        function addEventHandler(target,type,fn){
        	if(target.addEventListener){
        		target.addEventListener(type,fn);
        	}else{
        		target.attachEvent("on"+type,fn);
        	}
        }
        //移除监听事件
        function removeEventHandler(target,type,fn){
        	if(target.removeEventListener){
        		target.removeEventListener(type,fn);
        	}else{
        		target.detachEvent("on"+type,fn);
        	}
        }
        //测试
        var btn5 = document.getElementById("btn5");
        addEventHandler(btn5,"click",hello1);//添加事件hello1
        addEventHandler(btn5,"click",hello2);//添加事件hello2
        removeEventHandler(btn5,"click",hello1);//移除事件hello1
        ```

**事件委托：**

- 事件代理（ Event Delegation ），⼜称之为事件委托。是 JavaScript 中常⽤绑定事件的常⽤技巧。 事件委托就是**利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果**。 

- 事件代理的**原理是DOM元素的事件冒泡**。

  ```js
  <input type="button" value="click me" id="btn6">
  var btn6 = document.getElementById("btn6");
  document.onclick = function(event){
  	event = event || window.event;
  	var target = event.target || event.srcElement;
  	if(target == btn6){
  		alert(btn5.value);
  	}
  }
  ```

- 使⽤事件代理的好处是可以提⾼性能，可以⼤量节省内存占⽤，减少事件注册，⽐如在table 上代理所有td 的click 事件就⾮常棒

  ````js
  var item1 = document.getElementById("item1");
  var item2 = document.getElementById("item2");
  var item3 = document.getElementById("item3");
  document.addEventListener("click",function(event){
  	var target = event.target;
  	if(target == item1){
  		alert("hello item1");
  	}else if(target == item2){
  		alert("hello item2");
  	}else if(target == item3){
  		alert("hello item3");
  	}
  })
  ````

-  动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。 

  ```js
  //传统写法，点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。
  <ul id="list">
    <li id="item1" >item1</li>
    <li id="item2" >item2</li>
    <li id="item3" >item3</li>
  </ul>
  <script>
  var list = document.getElementById("list");
  var item = list.getElementsByTagName("li");
  for(var i=0;i<item.length;i++){
  	(function(i){
  		item[i].onclick = function(){
  			alert(item[i].innerHTML);
  		}
  	})(i)
  }
  var node=document.createElement("li");
  var textnode=document.createTextNode("item4");
  node.appendChild(textnode);
  list.appendChild(node);
  </script>
  
  //当点击item4时，item4有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件。
  <ul id="list">
    <li id="item1" >item1</li>
    <li id="item2" >item2</li>
    <li id="item3" >item3</li>
  </ul>
  <script>
  var list = document.getElementById("list");
  document.addEventListener("click",function(event){
  	var target = event.target;
  	if(target.nodeName == "LI"){
  		alert(target.innerHTML);
  	}
  })
  var node=document.createElement("li");
  var textnode=document.createTextNode("item4");
  node.appendChild(textnode);
  list.appendChild(node);
  </script>
  ```

### 8 拖拽功能的实现

首先是三个事件，分别是**mousedown，mousemove，mouseup** 当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。

clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是：

**鼠标移动时候的坐标-鼠标按下去时候的坐标。**

也就是说定位信息为：

鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.

还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，**我们改变的是绝对定位条件下的left 以及top**等等值。

### 9 Ajax原理

- Ajax 的原理简单来说是**在⽤户和服务器之间加了—个中间层( AJAX 引擎)**，通过XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后⽤javascript来操作DOM ⽽更新⻚⾯。使⽤户操作与服务器响应异步化。这其中最关键的⼀步就是**从服务器获得请求数据**
- Ajax 的过程只涉及JavaScript 、XMLHttpRequest 和DOM 。**XMLHttpRequest 是Ajax的核⼼机制**

```javascript
/** 1. 创建连接 **/
var xhr = null;
xhr = new XMLHttpRequest()
/** 2. 连接服务器 **/
xhr.open('get', url, true)
/** 3. 发送请求 **/
xhr.send(null);
/** 4. 接受请求 **/
xhr.onreadystatechange = function(){
	if(xhr.readyState == 4){
		if(xhr.status == 200){
			success(xhr.responseText);
		} else {
		/** false **/
		fail && fail(xhr.status);
		}
	}
}
```

ajax 有那些优缺点?

- 优点：
  - 通过异步模式，提升了⽤户体验.
  - 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占⽤.
  - Ajax 在客户端运⾏，承担了⼀部分本来由服务器承担的⼯作，减少了⼤⽤户量下的服务器负载。
  - Ajax 可以实现动态不刷新（局部刷新）
- 缺点：
  - 安全问题 AJAX 暴露了与服务器交互的细节。
  - 对搜索引擎的⽀持⽐较弱。
  - 不容易调试。

**Ajax状态**

1. 未初始化。尚未调用 open()方法。
2. 启动。已经调用 open()方法，但尚未调用 send()方法。
3. 发送。已经调用 send()方法，但尚未接收到响应。
4. 接收。已经接收到部分响应数据。
5. 完成。已经接收到全部响应数据，而且已经可以在客户端使用了。

### 10 同源限制，跨域

 **什么是同源策略？** 

**同源策略/SOP（Same origin policy）** 是⼀种约定，由Netscape公司1995年引⼊浏览器，**它是浏览器最核⼼也最基本的安全功能**，如果缺少了同源策略，浏览器很容易受到XSS 、CSFR 等攻击。

所谓**同源是指"协议+域名+端⼝"三者相同**，即便两个不同的域名指向同⼀个ip地址，也⾮同源

同源策略是⼀种安全协议。举例说明：⽐如⼀个⿊客程序，他利⽤Iframe 把真正的银⾏登录⻚⾯嵌到他的⻚⾯上，当你使⽤真实的⽤户名，密码登录时，他的⻚⾯就可以通过Javascript 读取到你的表单中input 中的内容，这样⽤户名，密码就轻松到⼿了。

**同源策略限制以下几种行为：**

1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送


**什么是跨域？**

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。

广义的跨域：

1.) 资源跳转： A链接、重定向、表单提交

2.) 资源嵌入： `<link>`、`<script>`、`<img>`、`<frame>`等dom标签，还有样式中`background:url()`、`@font-face()`等文件外链 

3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等

其实**我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景**。

**常见跨域场景**

| URL                                                          | 说明                     | 是否允许通信 |
| ------------------------------------------------------------ | ------------------------ | ------------ |
| `http://www.domain.com/a.js`<br/>`http://www.domain.com/b.js  `  <br/>`http://www.domain.com/lab/c.js` | 同一域名，不同文件或路径 | 允许         |
| `http://www.domain.com:8000/a.js`<br> `http://www.domain.com/b.js  ` | 同一域名，不同端口       | 不允许       |
| `http://www.domain.com/a.js`<br/>`http://192.168.4.12/b.js  ` | 域名和域名对应相同ip     | 不允许       |
| `http://www.domain.com/a.js`<br/>`http://x.domain.com/b.js ` <br/>  `http://domain.com/c.js` | 主域相同，子域不同       | 不允许       |
| `http://www.domain1.com/a.js`<br/>`http://www.domain2.com/b.js ` | 不同域名                 | 不允许       |

#### **跨域解决方案**

1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

**1. 通过jsonp跨域**

 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以**通过动态创建script，再请求一个带参网址实现跨域通信**。 

1.）原生实现：

```js
 <script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>

 //服务端返回如下（返回时即执行全局函数）：
 handleCallback({"status": true, "user": "admin"})
```

2.）jquery ajax：

```js
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
```

3.）vue.js：

```js
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

后端node.js代码示例：

```js
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();

server.on('request', function(req, res) {
    var params = qs.parse(req.url.split('?')[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

jsonp缺点：只能实现get一种请求。

**2. document.domain + iframe跨域**

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

```js
1.）父窗口：(http://www.domain.com/a.html)
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>

2.）子窗口：(http://child.domain.com/b.html)
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

**3. location.hash + iframe**

实现原理： a域与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

```js
1.）a.html：(http://www.domain1.com/a.html)
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>

2.）b.html：(http://www.domain2.com/b.html)
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>

3.）c.html：(http://www.domain1.com/c.html)
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

**4. window.name + iframe跨域**

 window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 

```js
1.）a.html：(http://www.domain1.com/a.html)
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};

// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});

2.）proxy.html：(http://www.domain1.com/proxy....
中间代理页，与a.html同域，内容为空即可。

3.）b.html：(http://www.domain2.com/b.html)
<script>
    window.name = 'This is domain2 data!';
</script>
```

 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 

**5. postMessage跨域**

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
a.） 页面和其打开的新窗口的数据传递
b.） 多窗口之间消息传递
c.） 页面与嵌套的iframe消息传递
d.） 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数
data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

```js
1.）a.html：(http://www.domain1.com/a.html)
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>

2.）b.html：(http://www.domain2.com/b.html)
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

**6. 跨域资源共享（CORS）**

普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。

**(1) 前端设置：**

1.）原生ajax

```js
// 前端设置是否带cookie
xhr.withCredentials = true;
```

示例代码：

```js
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
```

2.）jQuery ajax

```js
$.ajax({
    ...
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
    ...
});
```

(2) **服务端设置：**

若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。

1.）Java后台：

```js
/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */

// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 

// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
response.setHeader("Access-Control-Allow-Credentials", "true"); 

// 提示OPTIONS预检时，后端需要设置的两个常用自定义头
response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");
```

2.）Nodejs后台示例：

```js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

**7. nginx代理跨域**

**1、 nginx配置解决iconfont跨域**

浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。

```
location / {
  add_header Access-Control-Allow-Origin *;
}
```

**2、 nginx反向代理接口跨域**

跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

nginx具体配置：

```js
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

1.) 前端代码示例：

```js
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.send();
```

2.) Nodejs后台示例：

```js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));

    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取
    });

    res.write(JSON.stringify(params));
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

**8. nodejs中间件代理跨域**

node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。

**1、 非vue框架的跨域（2次跨域）**

利用node + express + http-proxy-middleware搭建一个proxy服务器。

1.）前端代码示例：

```js
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问http-proxy-middleware代理服务器
xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
xhr.send();
```

2.）中间件服务器：

```js
var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();

app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.domain2.com:8080',
    changeOrigin: true,

    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },

    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
}));

app.listen(3000);
console.log('Proxy server is listen at port 3000...');
```

3.）Nodejs后台同（六：nginx）

**2、 vue框架的跨域（1次跨域）**

利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。

webpack.config.js部分配置：

```js
module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            context: '/login',
            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
            changeOrigin: true,
            secure: false,  // 当代理某些https服务报错时用
            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}
```

**9. WebSocket协议跨域**

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

1.）前端代码：

```js
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });

    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});

document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

2.）Nodejs socket后台：

```js
var http = require('http');
var socket = require('socket.io');

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');

// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });

    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```



#### JSONP原理和优缺点

**jsonp的原理：动态创建script标签，回调函数**

JSONP(JSON with Padding)是JSON的一种"使用模式"，可用于解决主流浏览器的跨域数据访问的问题。**利用`<script>`元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料**，而这种使用模式就是所谓的JSONP。用JSONP抓到的资料并不是JSON，而是任意的javaScript，用javaScript直译器执行而不是用JSON解析器解析。

优点

- JSONP可以跨越同源策略，实现跨域传输，不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制
- JSONP兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持
- 在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方

缺点

- 它只支持GET请求而不支持POST等其它类型的HTTP请求，因为script标签的scr只能进行GET请求
- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
- jsonp在调用失败的时候不会返回各种HTTP状态码。
- 缺乏安全性。假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的,那么所有调用这个jsonp的网站都会存在漏洞,这样的话危险就不止在一个域名下。

### 11 模块化开发怎么做？

- ⽴即执⾏函数,不暴露私有成员

  ```javascript
  var module1 = (function(){
  	var _count = 0;
  	var m1 = function(){
  		//...
  	};
  	var m2 = function(){
  		//...
  	};
  	return {
  		m1 : m1,
  		m2 : m2
  	};
  })();
  ```

### 12 异步加载JS的⽅式

- **方案一、$(document).ready()**

  > 需要引入jquery
  >  兼容所有浏览器

  ```jsx
  $(document).ready(function() {
  alert("加载完成！");
   });
  ```

  **方案二、标签的async="async"属性**

  > 1.async属性是HTML5新增属性，需要Chrome、FireFox、IE9+浏览器支持
  >  2.async属性规定**一旦脚本可用，则会异步执行**
  >  3.async属性**仅适用于外部脚本**
  >  4.此方法不能保证脚本按顺序执行

  ```xml
  <script type="text/javascript" src="xxx.js" async="async"></script>
  ```

  **方案三、标签的defer="defer"属性**

  > 1.defer属性规定**是否对脚本执行进行延迟，直到页面加载为止**
  >  2.如果脚本不会改变文档的内容，可将defer属性加入到<script>标签中，以便加快处理文档的速度
  >  3.**兼容所有浏览器**
  >  4.此方法可以确保所有**设置了defer属性的脚本按顺序执行**

  **方案四、动态创建标签**

  > **兼容所有浏览器**

  ```jsx
  (function(){
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = "http://code.jquery.com/jquery-1.7.2.min.js";
      var tmp = document.getElementsByTagName('script')[0];
      tmp.parentNode.insertBefore(script, tmp);
  })();
  ```

### 13 内存泄漏与避免

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。顾名思义，就是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果的现象。

> 即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。 一般是堆区内存泄漏，栈区不会泄漏。
>
> 基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以对象、数组之类的，才会发生内存泄漏。

**内存泄漏的情形**

- setTimeout 的第⼀个参数使⽤字符串⽽⾮函数的话，会引发内存泄漏

- 闭包使⽤不当

  原因：闭包可以维持函数内局部变量，使其得不到释放。

  解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

- 控制台⽇志

- 循环（在两个对象彼此引⽤且彼此保留时，就会产⽣⼀个循环）

-  意外的全局变量引起的内存泄漏 

  原因：全局变量，不会被回收。

  解决：使用严格模式避免。

- 没有清理的DOM元素引用

  原因：虽然别的地方删除了，但是对象中还存在对dom的引用

  解决：手动删除。

- 被遗忘的定时器或者回调

  原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。

  解决：手动删除定时器和dom。

- 子元素存在引用引起的内存泄漏

  原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。

  解决：手动删除清空。

**内存泄漏的避免**

1. 谨慎使用闭包 

   a、在业务不需要用到的内部函数，可以重构在函数外，实现解除闭包.

   b、闭包内，局部变量使用后或不再需要，及时的清除掉

2. 减少不必要的全局变量，使用严格模式避免意外创建全局变量。

3. 减少生命周期较长的对象，及时对无用的数据进行释放销毁.

4. 在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。避免创建过多的对象，对不用的对象及时的释放。对注册的事件，再不用的时候，及时的解耦，释放资源。

5. 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。


### 14 JSON 的了解，XML和JSON的区别？

JSON(JavaScript Object Notation) 是⼀种轻量级的数据交换格式。它是基于JavaScript 的⼀个⼦集。数据格式简单, 易于读写, 占⽤带宽⼩

在 JavaScript 中，预先提供了 `JSON.parse` 函数，它接受一个 JSON 字符串作为参数，并返回这个 JSON 字符串解释得到的结果。

由于 JSON 的解释速度比 JavaScript 代码快很多，并且 `JSON.parse` 作为内置函数，JSON 字符串会交由 JavaScript 解释器内部的 C/C++ 代码进行解释，并直接跳过 JavaScript 语法解释器部分，直接在解释器内部生成并返回 JavaScript 对象的引用。

在这个过程中，**JavaScript 解释器只需要解释到 `JSON.parse('`，即可得知后面是一个字符串，并一路向后寻找字符串的结尾，这之间不会有复杂的语法（反引号 字符串中包含的 `${}` 除外），最多就只有转义字符 `\` 的转义。随后就会将解释所得到的字符串交给 `JSON.parse` 函数进行处理了**。

因此，这个过程会比直接去解释一个 JavaScript 对象快得多

- JSON 字符串转换为JSON对象:
    ```javascript
    var obj = eval('('+ str +')');
    var obj = str.parseJSON();
    var obj = JSON.parse(str);
    ```

- JSON 对象转换为JSON字符串：

  ```javascript
  var last = obj.toJSONString();
  var last = JSON.stringify(obj);
  ```

XML和JSON的区别:
- 数据体积⽅⾯：JSON 相对于XML 来讲，数据的体积⼩，传递的速度更快些。

- 数据交互⽅⾯：JSON 与JavaScript 的交互更加⽅便，更容易解析处理，更好的数据交互

- 数据描述⽅⾯：JSON 对数据的描述性⽐XML 较差

- 传输速度⽅⾯：JSON 的速度要远远快于XML

### 15 async、await 优缺点

async 和 await 相⽐直接使⽤ Promise 来说，优势在于**处理 then 的调⽤链**，能够更清晰准确的写出代码。缺点在于滥⽤ await 可能会导致**性能问题**，因为 await 会**阻塞代码**，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性

```javascript
var a = 0
var b = async () => {
	a = a + await 10
	console.log('2', a) // -> '2' 10
	a = (await 10) + a
	console.log('3', a) // -> '3' 20
}
b()
a++
console.log('1', a) // -> '1' 1
```

- ⾸先函数b 先执⾏，在执⾏到 await 10 之前变量 a 还是 0 ，因为在 await 内部实现了 generators ， generators 会保留堆栈中东⻄，所以这时候 a = 0 被保存了下来
- 因为 await 是异步操作，**遇到await 就会⽴即返回⼀个pending 状态的Promise 对象，暂时返回执⾏代码的控制权，使得函数外的代码得以继续执⾏**，所以会先执⾏console.log('1', a)
- 这时候**同步代码执⾏完毕，开始执⾏异步代码**，将保存下来的值拿出来使⽤，这时候 a =10
- 然后后⾯就是常规执⾏代码了

### 16 模块化CommonJS、AMD、CMD规范

***nodejs遵循了CommonJS规范***
CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。
根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。
CommonJS的核心思想就是通过 **require** 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。
**优点：**
CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。
**缺点：**
由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的

***require.js遵循了AMD规范***
AMD规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。
**优点：**
适合在浏览器环境中异步加载模块。可以并行加载多个模块。
**缺点：**
提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。

***seajs遵循了CMD规范***
CMD规范与AMD规范很类似，实现库为seajs，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的
**优点：**
同样实现了浏览器端的模块化加载，可以按需加载，依赖就近。
**缺点：**
依赖SPM打包，模块的加载逻辑偏重。
AMD和CMD的区别：
前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。

#### 模块化

在有 Babel 的情况下，我们可以直接使⽤ ES6 的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}
import {a, b} from './a.js'
import XXX from './b.js'
```

**CommonJS**

CommonJs 是 Node 独有的规范，浏览器中使⽤就需要⽤到 Browserify解析了。

```js
// a.js
module.exports = {
	a: 1
}
// or
exports.a = 1
// b.js
var module = require('./a.js')
module.a // -> log 1
```

在上述代码中， module.exports 和 exports 很容易混淆，让我们来看看⼤致内部实现

```js
var module = require('./a.js')
module.a
// 这⾥其实就是包装了⼀层⽴即执⾏函数，这样就不会污染全局变量了，
// 重要的是 module 这⾥，module 是 Node 独有的⼀个变量
module.exports = {
	a: 1
}
// 基本实现
var module = {
exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports ⽤法相似的原因
var exports = module.exports
var load = function (module) {
	// 导出的东⻄
	var a = 1
	module.exports = a
	return module.exports
};
```

module.exports 和exports ，⽤法其实是相似的，但是不能对exports 直接赋值，不会有任何效果。

对于 CommonJS 和 ES6 中的模块化的两者区别是：

- **前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持**，但是已有提案,前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤。
- ⽽**后者是异步导⼊**，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很⼤影响
- **前者在导出时都是值拷⻉**，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次。
- 但是**后者采⽤实时绑定的⽅式**，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化
- **后者会编译成 require/exports 来执⾏的**

AMD 是由 RequireJS 提出的

```js
// AMD
define(['./a', './b'], function(a, b) {
	a.do()
	b.do()
})
define(function(require, exports, module) {
	var a = require('./a')
	a.doSomething()
	var b = require('./b')
	b.doSomething()
})
```



### 17 常⻅web安全及防护原理

- sql 注⼊原理：通过把SQL 命令插⼊到Web 表单递交或输⼊域名或⻚⾯请求的查询字符串，最终达到欺骗服务器执⾏恶意的SQL命令
- 总的来说有以下⼏点
  - 永远不要信任⽤户的输⼊，**要对⽤户的输⼊进⾏校验**，可以通过正则表达式，或限制⻓度，对单引号和双"-" 进⾏转换等
  - 永远不要使⽤动态拼装SQL，可以使⽤参数化的SQL 或者直接使⽤存储过程进⾏数据查询存取
  - 永远不要使⽤管理员权限的数据库连接，为每个应⽤使⽤单独的权限有限的数据库连接
  - 不要把机密信息明⽂存放，请**加密或者hash 掉密码和敏感的信息**

### 18 XSS和CSRF

- XSS原理及防范

  Xss(cross-site scripting) 攻击指的是**攻击者往Web ⻚⾯⾥插⼊恶意html 标签或者javascript 代码**。⽐如：攻击者在论坛中放⼀个看似安全的链接，骗取⽤户点击后，窃取cookie 中的⽤户私密信息；或者攻击者在论坛中加⼀个恶意表单，当⽤户提交表单的时候，却把信息传送到攻击者的服务器中，⽽不是⽤户原本以为的信任站点

- XSS防范⽅法

  ⾸先代码⾥对**⽤户输⼊**的地⽅和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’” 等字符做过滤；其次**任何内容写到⻚⾯之前都必须加以encode**，避免不⼩⼼把html tag 弄出来。这⼀个层⾯做好，⾄少可以堵住超过⼀半的XSS 攻击

- CSRF

  跨站请求伪造（英语： Cross-site request forgery ），也被称为 oneclickattack 或者 session riding ，通常缩写为 CSRF 或者 XSRF ，是⼀种**挟制⽤户在当前已登录的Web 应⽤程序上执⾏⾮本意的操作的攻击⽅**。CSRF 就是利⽤⽤户的登录态发起恶意请求。假设⽹站中有⼀个通过 Get 请求提交⽤户评论的接⼝，那么攻击者就可以在钓⻥⽹站中加⼊⼀个图⽚，图⽚的地址就是评论接⼝

- CSRF的防御

  - Get 请求不对数据进⾏修改
  - 不让第三⽅⽹站访问到⽤户 Cookie
  - 阻⽌第三⽅⽹站请求接⼝
  - 服务端的CSRF ⽅式⽅法很多样，但总的思想都是⼀致的，就是**在客户端⻚⾯增加伪随机数**
  - 请求时附带验证信息，⽐如**验证码或者 token**

- XSS与CSRF有什么区别吗？

  **XSS 是获取信息**，不需要提前知道其他⽤户⻚⾯的代码和数据包。**CSRF 是代替⽤户完成指定的动作**，需要知道其他⽤户⻚⾯的代码和数据包。

  要完成⼀次CSRF 攻击，受害者必须依次完成两个步骤

  - 登录受信任⽹站A ，并在本地⽣成Cookie
  - 在不登出A 的情况下，访问危险⽹站B


### 19 ⽤过哪些设计模式？

- ⼯⼚模式：
  ⼯⼚模式解决了重复实例化的问题，但还有⼀个问题,那就是识别问题，因为根本⽆法主要好处就是可以消除对象间的耦合，通过使⽤⼯程⽅法⽽不是new 关键字
- 构造函数模式
  使⽤构造函数的⽅法，即解决了重复实例化的问题，⼜解决了对象识别的问题，该模式与⼯⼚模式的不同之处在于直接将属性和⽅法赋值给 this 对象;

### 20  offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别

- offsetWidth/offsetHeight 返回值包含content + padding + border，效果与e.getBoundingClientRect()相同，只读属性
- clientWidth/clientHeight 返回值只包含content + padding，如果有滚动条，也不包含滚动条，只读属性
- scrollWidth/scrollHeight 返回值包含content + padding + 溢出内容的尺⼨，可读写属性

### 21 javascript有哪些⽅法创建对象

javascript 创建对象简单的说,⽆⾮就是使⽤内置对象或各种⾃定义对象，当然还可以⽤JSON ；但写法有很多种，也能混合使⽤

- 对象字⾯量的⽅式

  ```javascript
  person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
  ```

- ⽤function 来模拟构造函数

  ```javascript
  //模拟⽆参的构造函数
  function Person(){}
  	var person=new Person();//定义⼀个function
  	person.name="Mark";
  	person.age="25";
  	person.work=function(){
  	alert(person.name+" hello...");
  }
  person.work();
  
  //模拟有参构造函数来实现（⽤this 关键字定义构造的上下⽂属性）
  function Pet(name,age,hobby){
  	this.name=name;//this作⽤域：当前对象
  	this.age=age;
  	this.hobby=hobby;
  	this.eat=function(){
  	alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
  	}
  }
  var maidou =new Pet("⻨兜",25,"coding");//实例化、创建对象
  maidou.eat();//调⽤eat⽅法
  ```

  - 寄生构造函数模式

    ```javascript
    function Person(name) {
      var o = new Object()
      o.name = name
      o.say = function() {
        alert(this.name)
      }
      return o
    }
    var peron1 = new Person('hanmeimei')
    ```

  - 稳妥构造模式

    ```javascript
    function Person(name) {
      var o = new Object()
      o.say = function() {
        alert(name)
      }
    }
    var person1 = new Person('hanmeimei');
    person1.name  // undefined
    person1.say() //hanmeimei
    ```

    

- ⽤⼯⼚⽅式来创建（内置对象）

  ```javascript
  function Person() {
    var o = new Object();
    o.name = 'hanmeimei';
    o.say = function() {
      alert(this.name);
    }
    return o;
  }
  var person1 = Person();
  ```
  
- ⽤原型⽅式来创建

  ```javascript
  function Dog(){}
  	Dog.prototype.name="旺财";
  	Dog.prototype.eat=function(){
  	alert(this.name+"是个吃货");
  }
  var wangcai =new Dog();
  wangcai.eat();
  ```

  - 动态原型模式

    ```javascript
    function Person(name) {
      this.name = name
      if(typeof this.say != 'function') {
        Person.prototype.say = function(
        alert(this.name)
      }
    }
    ```

- ⽤混合⽅式来创建

  ```javascript
  function Car(name,price){
  	this.name=name;
  	this.price=price;
  }
  Car.prototype.sell=function(){
  	alert("我是"+this.name+"，我现在卖"+this.price+"万元");
  }
  var camry =new Car("凯美瑞",27);
  camry.sell();
  ```

### 22 es6 class中constructor方法和super的作用

constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。

 `super` 这个关键字，既可以当做函数使用，也可以当做对象使用。 

1.  当做函数使用 

   ```js
   class A {}
   class B extends A {
     constructor() {
       super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。
     }
   }
   ```

   注：在 `constructor` 中必须调用 `super` 方法，因为**子类没有自己的 `this` 对象，而是继承父类的 `this` 对象，然后对其进行加工,而 `super` 就代表了父类的构造函数**。`super` 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 `super` 内部的 `this` 指的是 B，因此 `super()` 在这里相当于 ``A.prototype.constructor.call(this, props)``。

   ```js
   class A {
     constructor() {
       console.log(new.target.name); // new.target 指向当前正在执行的函数
     }
   }
   
   class B extends A {
     constructor {
       super();
     }
   }
   
   new A(); // A
   new B(); // B
   ```

    可以看到，在 `super()` 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，`super()` 内部的 `this` 指向的是 B。 

2. 当做对象使用

    **在普通方法中，指向父类的原型对象；在静态方法中，指向父类。** 

   ```js
   class A {
     c() {
       return 2;
     }
   }
   
   class B extends A {
     constructor() {
       super();
       console.log(super.c()); // 2
     }
   }
   
   let b = new B();
   //上面代码中，子类 B 当中的 `super.c()`，就是将 `super` 当作一个对象使用。这时，`super` 在普通方法之中，指向 `A.prototype`，所以 `super.c()` 就相当于 `A.prototype.c()`。
   ```

   **通过 `super` 调用父类的方法时，`super` 会绑定子类的 `this`。**

   ```js
   class A {
     constructor {
       this.x = 1;
     }
     s() {
       console.log(this.x);
     }
   }
   
   class B extends A {
     constructor {
       super();
       this.x = 2;
     }
     m() {
       super.s();
     }
   }
   
   let b = new B();
   b.m(); // 2
   
   //super.s() 虽然调用的是 A.prototytpe.s()，但是 A.prototytpe.s()会绑定子类 B 的 this，导致输出的是 2，而不是 1。也就是说，实际上执行的是 super.s.call(this)。
   ```

    由于绑定子类的 `this`，所以如果通过 `super` 对某个属性赋值，这时 `super` 就是 `this`，赋值的属性会变成子类实例的属性。 

   ```js
   class A {
     constructor {
       this.x = 1;
     }
   }
   
   class B extends A {
     constructor {
       super();
       this.x = 2;
       super.x = 3;
       console.log(super.x); // undefined
       console.log(this.x); // 3
     }
   }
   
   let b = new B();
   
   //上面代码中，super.x 赋值为 3，这时等同于对 this.x 赋值为 3。而当读取 super.x 的时候，调用的是 A.prototype.x，但并没有 x 方法，所以返回 undefined。
   ```

    注意，使用 `super` 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。 

   ```js
   class A {}
   class B extends A {
     constructor() {
       super();
       console.log(super); // 报错
     }
   }
   
   //上面代码中，console.log(super); 的当中的 super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这是，如果能清晰的表明 super 的数据类型，就不会报错。
   ```

    由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 `super` 关键字。 

### 23 generator 原理(yield)

Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来**异步编程**

```javascript
// 使⽤ * 表示这是⼀个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调⽤ next 恢复执⾏
function* test() {
	let a = 1 + 2;
	yield 2;
	yield 3;
}
let b = test();
console.log(b.next()); // > { value: 2, done: false }
console.log(b.next()); // > { value: 3, done: false }
console.log(b.next()); // > { value: undefined, done: true }
```

从以上代码可以发现，**加上 * 的函数执⾏后拥有了 next 函数**，也就是说函数执⾏后返回了⼀个对象。**每次调⽤ next 函数可以继续执⾏被暂停的代码**。

对于Generator函数，可以将它**理解为一个状态机，封装了多个内部状态；此外它还是一个遍历器生成函数**，这个函数可以遍历出状态机的所有状态。

函数特征：关键字function与函数名之间有*，函数体内部yeild关键字。

**生成器函数与普通函数的区别**：函数调用后不执行，而是返回一个指针对象（遍历器对象）。调用对象的next()方法，执行一段yield逻辑。故函数的分段执行的，**yield是暂停执行的标志，next()可以恢复执行**。

**yield与return的区别**：**yield有记忆功能**，return没有；一个函数可以多次执行yeild，但只会return一次

可以将生成器函数赋值给对象的Symbol.iterator属性，使得对象可遍历。生成器函数实现了可以在函数运行的不同阶段从外部注入不同的值，从而调整函数的行为。Generator函数是ES6对协程的实现（不完全实现）。可以将生成器函数作为异步任务的容器，所有需要异步操作的地方都用yeild来标明。此外，**生成器函数具有如下特性：函数内外的参数交换（next函数又可以输入参数又可以返回值）和错误处理机制（函数体可以捕获函数体外抛出的错误）**。Generator需要Thunk函数来执行、进行流程管理。

生成器函数的应用：1.异步操作的同步化表达；2.控制流管理；3.部署iterator结口；4.作为数据结构

### 24 你觉得jQuery源码有哪些写的好的地⽅

- jquery 源码**封装在⼀个匿名函数的⾃执⾏环境中，有助于防⽌变量的全局污染**，然后通过传⼊window 对象参数，可以**使window 对象作为局部变量使⽤**，好处是当jquery 中访问window 对象的时候，就不⽤将作⽤域链退回到顶层作⽤域了，从⽽可以更快的访问window对象。同样，传⼊undefined 参数，可以缩短查找undefined 时的作⽤域链
- jquery 将⼀些原型属性和⽅法封装在了jquery.prototype 中，为了缩短名称，⼜赋值给了jquery.fn ，这是很形象的写法
- 有⼀些数组或对象的⽅法经常能使⽤到， jQuery 将其保存为局部变量以提⾼访问速度jquery 实现的链式调⽤可以节约代码，所返回的都是同⼀个对象，可以提⾼代码效率

### 25 类型转换

**转Boolean**
在条件判断时，除了 undefined ， null ， false ， NaN ， '' ，0 ， -0 ，其他所有值都转为 true ，包括所有对象

**对象转基本类型**
对象在转换基本类型时，⾸先会调⽤ valueOf 然后调⽤ toString 。并且这两个⽅法你是可以重写的

**四则运算符**

只有**当加法运算时，其中⼀⽅是字符串类型，就会把另⼀个也转为字符串类型**。**其他运算只要其中⼀⽅是数字，那么另⼀⽅就转为数字**。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串

```javascript
1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'
```

对于加号需要注意这个表达式 'a' + + 'b'

```js
'a' + + 'b' // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在⼀些代码中看到过 + '1' -> 1
```

**== 操作符**

这⾥来解析⼀道题⽬ [] == ![] // -> true ，下⾯是这个表达式为何为true 的步骤

```js
// [] 转成 true，然后取反变成 false
[] == false
// 根据第 8 条得出
[] == ToNumber(false)
[] == 0
// 根据第 10 条得出
ToPrimitive([]) == 0
// [].toString() -> ''
'' == 0
// 根据第 6 条得出
0 == 0 // -> true
```

**⽐较运算符**

如果是对象，就通过 toPrimitive 转换对象
如果是字符串，就通过 unicode 字符索引来⽐较

### 26 JavaScript数组

 数据就是原型链中有 `Array.prototype` 的对象 。 数组的索引可以不是连续的，访问 `index` 不存在的元素的时候返回 `undefined` 。

API：

 `splice` 方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。 

```js
//删除 splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素
var a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(4, 2) // ["e", "f"]
a // ["a", "b", "c", "d"]

a.splice(4, 2, 1, 2) // ["e", "f"]
a // ["a", "b", "c", "d", 1, 2]

//如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0
var a = [1, 1, 1];
a.splice(1, 0, 2) // []
a // [1, 2, 1, 1]
```

 `slice` 方法用于提取目标数组的一部分，返回一个**新数组**，原数组不变。  第一个参数代表开始位置,第二个参数代表结束位置的下一个位置,截取出来的字符串的长度为第二个参数与第一个参数之间的差;若参数值为负数,则将该值加上字符串长度后转为正值;若第一个参数等于大于第二个参数,则返回空字符串. 

```js
var a = [1,2,3,4,5];
a.slice(1,2);//2 从 a 下标为1开始，到下标为2结束(不包括2)，做为新数组，原数组不变
```

`substring` **第一个参数代表开始位置,第二个参数代表结束位置的下一个位置**;若参数值为负数,则将该值转为0;两个参数中,取较小值作为开始位置,截取出来的字符串的长度为较大值与较小值之间的差. 

` substr() `**第一个参数代表开始位置,第二个参数代表截取的长度**

 `reverse` 方法用于将数组逆序，与之前不同的是它会修改原数组 

```js
var a = [1,2,3,4,5];
a.reverse();
console.log(a); //[5, 4, 3, 2, 1]
```

 `join` 方法是把数组元素（对象调用其 `toString()` 方法）使用参数作为连接符连接成一字符串，不会修改原数组内容。如果不提供参数，默认用逗号分隔。 

```js
var a = [1, 2, 3];

a.join(' ') // '1 2 3'
a.join(' . ') // "1 . 2 . 3"
a.join() // "1,2,3"
```

 `concat` 方法用于拼接数组，`a.concat(b)` 返回一个 a 和 b 共同组成的新数组，同样不会修改任何一个原始数组，也不会递归连接数组内部数组。 

```js
var a = [1,2,3,4,5]; 
var b = [6,7,8,9]; 
console.log(a.concat(b));    //[1, 2, 3, 4, 5, 6, 7, 8, 9] 
console.log(a);     //[1, 2, 3, 4, 5] 
console.log(b);     //[6, 7, 8, 9]
```

 `forEach` 方法对数组的所有成员依次执行参数函数，该函数接受三个参数：`value`、`key`、整个数组。 

```js
var a = ['a', 'b', 'c'];
a.forEach(function(q, w, e){
    console.log(q, w, e)
})

// a 0 (3) ["a", "b", "c"]
// b 1 (3) ["a", "b", "c"]
// c 2 (3) ["a", "b", "c"]
```

 `sort` 方法对数组成员进行排序，默认是按照转换为的字符串的诸个字符的 Unicode 位点进行排序。排序后，原数组将被改变。 

```js
[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

//想让sort方法按照自定义方式排序，可以传入一个函数作为参数。sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。
var items = [
    { name: 'Edward', value: 37},
    { name: 'Sharpe', value: 24},
    { name: 'And', value: 45 }
];
items.sort(function (a, b) {
    return (a.value - b.value)
});

// {name: "Sharpe", value: 24}
// {name: "Edward", value: 37}
// {name: "And", value: 45}
```

 `map` 方法对数组中每一元素进行处理，函数返回值组成一个**新数组**返回，新数组索引结构和原数组一致，原数组保持不变。 

```js
var arr = [1, 2, 3, 4, 5, 6]
arr.map(function(val){
     return val*val

// [1, 4, 9, 16, 25, 36]
```

 `filter` 方法用于过滤数组成员，接受一个函数，所有数组成员依次执行该函数，返回结果为 `true` 的成员组成一个**新数组**返回。 

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr.filter(function (val) {
  return (val > 5);
})
// [6, 7, 8, 9]
```

 `reduce` 方法依次处理数组的每个成员，两元素（或参数）执行操作，数组元素返回组合成一个值，遍历数组，继续和数组中 其他元素组合，最终得出结果。 

```js
var arr = [1, 2, 3, 4, 5]
arr.reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 15

//map 可以用 reduce 表示
var a = [1, 2, 3]
a.reduce(function(arr, n){
    arr.push(n * 2)
    return arr
}, [])
// [2, 4, 6]

//filter 可以用 reduce表示
var a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a.reduce(function(arr, n){    
    if(n % 2 === 0){
        arr.push(n)
    }
    return arr
}, [])
// [2, 4, 6, 8, 10]
```



### 27 js的数据类型，js有哪些内置对象，js有⼏种类型的值，如何判断对象类型

 ![img](/../../../../Typora图库/Web前端/js对象分类.png) 

- 基本数据类型（ 简单的数据段 ）：Undefined 、Null 、Boolean 、Number 、String 、Symbol（ es6新增 ）
- 内置对象：
  - Object 是 JavaScript 中所有对象的⽗对象
  - 引用类型（ 可能由多个值构成的对象 ）： Object（Object、Array、Function）
  - 其他对象： Arguments 、Math 、Date 、RegExp 、Promise、Proxy、Error
- 类型
  - 栈：原始数据类型（ Undefined ， Null ， Boolean ， Number 、String ）， 自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址 
  - 堆：引⽤数据类型（Object、Array、Function）， 动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。 
  - 两种类型的区别是：存储位置不同；
  - 原始数据类型直接存储在栈( stack )中的简单数据段，占据空间⼩、⼤⼩固定，属于被频繁使⽤数据，所以放⼊栈中存储；
  - 引⽤数据类型存储在堆( heap )中的对象,占据空间⼤、⼤⼩不固定,如果存储在栈中，将会影响程序运⾏的性能；引⽤数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引⽤值时，会⾸先检索其在栈中的地址，取得地址后从堆中获得实体
- 判断
  - 可以通过 Object.prototype.toString.call(xx) 。这样我们就可以获得类似 [objectType] 的字符串。
  - instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype

### 28 JavaScript的基本规范

- 不要在同⼀⾏声明多个变量
- 请使⽤===/!== 来⽐较true/false 或者数值
- 使⽤对象字⾯量替代new Array 这种形式
- 不要使⽤全局函数
- Switch 语句必须带有default 分⽀
- If 语句必须使⽤⼤括号
- for-in 循环中的变量 应该使⽤var 关键字明确限定作⽤域，从⽽避免作⽤域污

### 29 eval是做什么的

它的功能是把**对应的字符串解析成JS 代码并运⾏**
应该**避免使⽤eval ，不安全，⾮常耗性能**（ 2 次，⼀次解析成js 语句，⼀次执⾏）
由JSON 字符串转换为JSON对象的时候可以⽤eval，`var obj =eval('('+ str +')')`

### 30 null，undefined 的区别

- undefined 表示不存在这个值。
  undefined :是⼀个表示"⽆"的原始值或者说表示"缺少值"，就是此处应该有⼀个值，但是还没有定义。当尝试读取时会返回 undefined
  例如变量被声明了，但没有赋值时，就等于undefined
- null 表示⼀个对象被定义了，值为“空值”
  null : 是⼀个对象(空对象, 没有任何属性和⽅法)
  例如作为函数的参数，表示该函数的参数不是对象；
  在验证null 时，⼀定要使⽤ === ，因为 == ⽆法分别null 和 undefined

### 31 两个等号 == 和 三个等号 === 的区别

(1)  "=="叫做相等运算符，"==="叫做严格运算符。

(2) ==，equality -> 等同 的意思， 两边值类型不同的时候，要先进行类型转换为同一类型后，再比较值是否相等。 

===，identity -> 恒等 的意思，不做类型转换，类型不同的结果一定不等。 

(3) "=="表示只要值相等即可为真，而"==="则要求不仅值相等，而且也要求类型相同。

### 32 "use strict"：严格模式

use strict 是⼀种ECMAscript 5 添加的（严格）运⾏模式,这种模式使得 Javascript在更严格的条件下运⾏,使JS 编码更加规范化的模式,消除Javascript 语法的⼀些不合理、不严谨之处，减少⼀些怪异⾏为

严格模式的限制：

- 变量必须声明后再使⽤
- 函数的参数不能有同名属性，否则报错
- 不能使⽤with 语句
- 禁⽌this 指向全局对象

### 33 JS单线程和异步

 **常说的单线程其实指的是主线程**。JavaScript引擎负责解析，执行JavaScript代码，但它并不能单独运行，它需要一个宿主环境，熟知的宿主环境有**“浏览器”和“Node.js”**, 单线程是宿主环境没有给 JavaScript 执行过程中创建新线程的能力导致的，也称之为“主线程”。也就意味着我们（开发者）写的所有代码，都在 这一条主线程中执行。从这一点可以得出结论 JavaScript 是阻塞的：只要有一个地方发生阻塞，就会导致整个应用瘫痪。 

JavaScript 采用异步编程原因有两点，

- 一是 JavaScript 是单线程；
- 二是为了提高 CPU 的利用率。

 主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。 

 工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现喃？答案就是就是消息队列与事件循环。  工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。 

- 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。
- 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。

### 34 事件模型，事件流（捕获，冒泡）

**事件模型**

W3C 中定义事件的发⽣经历三个阶段：**捕获阶段（ capturing ）、⽬标阶段（ targetin ）、冒泡阶段（ bubbling ）**

- 冒泡型事件：当你使⽤**事件冒泡时，⼦级元素先触发，⽗级元素后触发**
- 捕获型事件：当你使⽤**事件捕获时，⽗级元素先触发，⼦级元素后触发**
- DOM 事件流：**同时⽀持两种事件模型：捕获型事件和冒泡型事件**
- 阻⽌冒泡：在W3c 中，使⽤stopPropagation() ⽅法；在IE下设置cancelBubble =true
- 阻⽌捕获：阻⽌事件的默认⾏为，例如`click - <a>` 后的跳转。在W3c 中，使⽤preventDefault() ⽅法，在IE 下设置window.event.returnValue = false

由此， addEventListener 的第三个参数设置为true 和false 的区别已经⾮常清晰了

- true 表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件
- false 表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件

**事件流**

事件流分为两种，**捕获事件流**和**冒泡事件流**

- 捕获事件流从根节点开始执⾏，⼀直往⼦节点查找执⾏，直到查找执⾏到⽬标节点
- 冒泡事件流从⽬标节点开始执⾏，⼀直往⽗节点冒泡查找执⾏，直到查到到根节点

事件流分为三个阶段，⼀个是**捕获节点**，⼀个是**处于⽬标节点阶段**，⼀个是**冒泡阶段**

### 35 语句和表达式

 JavaScript区分表达式和语句。

- 表达式是输出值的，并且可以写在任何需要一个值的地方。  笼统来说，一个语句表示执行了一个动作。  一个程序基本上就是一系列的语句的集合（这里我们忽略声明（declarations））。 
-  在JavaScript中需要语句的地方，也可以写入一个表达式。这样的语句可以称为表达式语句*（expression statement）*。 
-  但是反过来则行不通了，你不能够在需要表达式的地方写入一个语句。例如，一个if语句不能作为函数的实参。 

下面是一个if语句的例子:

```js
var x;if (y >= 0) {x = y;} else {x = -y;}
```

类似if语句功能的表达式叫做条件运算符.上面的语句等价于下面的.

```js
var x = (y >= 0 ? y : -y);
```

在等于号=和分号;之间的代码就是条件表达式.



 表达式是由运算符构成，并运算产生结果的语法结构。

程序是由语句构成，语句则是由“；（分号）”分隔的句子或命令。

如果在表达式后面加上一个“；”分隔符，这就被称为“表达式语句”。它表明“只有表达式，而没有其他语法元素的语句” 

 ![img](/../../../../Typora图库/Web前端/表达式和语句.png) 

### 36 mouseover和mouseenter的区别

mouseenter：当鼠标移入某元素时触发。

mouseleave：当鼠标移出某元素时触发。

mouseover：当鼠标移入某元素时触发，移入和移出其子元素时也会触发。

mouseout：当鼠标移出某元素时触发，移入和移出其子元素时也会触发。

mousemove：鼠标在某元素上移动时触发，即使在其子元素上也会触发。

mouseout、mouseover和mouseleave、mouseenter最大的区别，在于**子元素连带触发**。

 当绑定着两个事件的元素里面没有子元素的时候，这两个事件的触发效果是一致的。  当绑定事件的元素里面有子元素的时候，鼠标经过绑定mouseover的当前元素以及它里面的子元素的时候，都会触发，而经过绑定mouseenter的元素时，只会在鼠标刚进入的时候触发，当进入其子元素的时候，是不会再触发的了。 

**总结两句话**

- 不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。对应mouseout
- 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。对应mouseleave

### 37 setTimeout 和setInterval

JS 是单线程的，所以 setTimeout 的误差其实是⽆法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致。这也是为什么⻚⾯开久了，定时器会不准的原因。

 定时器是属于 **宏任务(macrotask)** 。如果当前 **执行栈** 所花费的时间大于 **定时器** 时间，那么定时器的回调在 **宏任务(macrotask)** 里，来不及去调用，所有这个时间会有误差。 

```js
setTimeout(function () {
	console.log('biubiu');
}, 1000);

某个执行时间很长的函数();
```

如果定时器下面的函数执行要 5秒钟，那么定时器里的log 则需要 5秒之后再执行，函数占用了当前 **执行栈** ，要等执行栈执行完毕后再去读取 **微任务(microtask)**，等 **微任务(microtask)** 完成，这个时候才会去读取 **宏任务(macrotask)** 里面的 **setTimeout** 回调函数执行。**setInterval** 同理，例如每3秒放入宏任务，也要等到执行栈的完成。

setTimeout出现误差是因为：

1. 要先执行同步任务，才会执行异步任务；
2. 异步任务中，微任务执行顺序大于宏任务执行顺序。

 还有一种情况 , 如果timeout嵌套大于 5层，而时间间隔小于4ms，则时间间隔增加到4ms。



setInterval的缺陷:

首先来看setInterval的缺陷，使用setInterval()创建的定时器**确保了定时器代码规则地插入队列中**。这个问题在于：**如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔**。不过幸运的是：javascript引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。

这种重复定时器的规则有两个问题：**1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。**

#### **用setTimeout来实现setInterval**

```js
let timeMap = {}
let id = 0 // 简单实现id唯一
const mySetInterval = (cb, time) => {
  let timeId = id // 将timeId赋予id
  id++ // id 自增实现唯一id
  let fn = () => {
    cb()
    timeMap[timeId] = setTimeout(() => {
      fn()
    }, time)
  }
  timeMap[timeId] = setTimeout(fn, time)
  return timeId // 返回timeId
}

const myClearInterval = (id) => {
  clearTimeout(timeMap[id]) // 通过timeMap[id]获取真正的id
  delete timeMap[id]
}
```



### 38 map与forEach的区别

- forEach ⽅法，是最基本的⽅法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item 、数组索引index 、和当前遍历数组Array
- map ⽅法，基本⽤法与forEach ⼀致，但是不同的，**它会返回⼀个新的数组**，所以在callback需要有return 值，如果没有，会返回undefined

### 39 Object.create()、new Object()和{}的区别

直接字面量创建

```js
var objA = {};
objA.name = 'a';
objA.sayName = function() {
    console.log(`My name is ${this.name} !`);
}
// var objA = {
//     name: 'a',
//     sayName: function() {
//         console.log(`My name is ${this.name} !`);
//     }
// }
objA.sayName();
console.log(objA.__proto__ === Object.prototype); // true
console.log(objA instanceof Object); // true
```

new关键字创建

```js
var objB = new Object();
// var objB = Object();
objB.name = 'b';
objB.sayName = function() {
    console.log(`My name is ${this.name} !`);
}
objB.sayName();
console.log(objB.__proto__ === Object.prototype); // true
console.log(objB instanceof Object); // true
```

 **new绑定**时`new`操作符其实做了以下四步： 

- 创建⼀个空对象，并且 this 变量引⽤该对象
- 继承了该函数的原型
- 属性和⽅法被加⼊到 this 引⽤的对象中
- 新创建的对象由 this 所引⽤，并且最后隐式的返回 this

```js
var obj = new Object(); // 创建一个空对象
obj.__proto__ = F.prototype; // obj的__proto__指向构造函数的prototype
var result = F.call(obj); // 把构造函数的this指向obj，并执行构造函数把结果赋值给result
if (typeof(result) === 'object') {
    objB = result; // 构造函数F的执行结果是引用类型，就把这个引用类型的对象返回给objB
} else {
    objB = obj; // 构造函数F的执行结果是值类型，就返回obj这个空对象给objB
}
```

 这样一比较，其实字面量创建和new关键字创建并没有区别，创建的新对象的`__proto__`都指向`Object.prototype`，只是字面量创建更高效一些，少了`__proto__`指向赋值和`this`。 

**Object.create()**

 `Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`。 

```js
const person = {
  isHuman: false,
  printIntroduction: function () {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};
const me = Object.create(person); // me.__proto__ === person
me.name = "Matthew"; // name属性被设置在新对象me上，而不是现有对象person上
me.isHuman = true; // 继承的属性可以被重写
me.printIntroduction(); // My name is Matthew. Am I human? true
```

Object.create(proto[, propertiesObject])

- `proto`必填参数，是新对象的原型对象，如上面代码里新对象`me`的`__proto__`指向`person`。注意，如果这个参数是`null`，那新对象就彻彻底底是个空对象，没有继承`Object.prototype`上的任何属性和方法，如`hasOwnProperty()、toString()`等。

  ```js
  var a = Object.create(null);
  console.dir(a); // {}
  console.log(a.__proto__); // undefined
  console.log(a.__proto__ === Object.prototype); // false
  console.log(a instanceof Object); // false 没有继承`Object.prototype`上的任何属性和方法，所以原型链上不会出现Object
  ```

- `propertiesObject`是可选参数，指定要添加到新对象上的可枚举的属性（即其自定义的属性和方法，可用`hasOwnProperty()`获取的，而不是原型对象上的）的描述符及相应的属性名称。

  ```js
  var bb = Object.create(null, {
      a: {
          value: 2,
          writable: true,
          configurable: true
      }
  });
  console.dir(bb); // {a: 2}
  console.log(bb.__proto__); // undefined
  console.log(bb.__proto__ === Object.prototype); // false
  console.log(bb instanceof Object); // false 没有继承`Object.prototype`上的任何属性和方法，所以原型链上不会出现Object
  
  // ----------------------------------------------------------
  
  var cc = Object.create({b: 1}, {
      a: {
          value: 3,
          writable: true,
          configurable: true
      }
  });
  console.log(cc); // {a: 3}
  console.log(cc.hasOwnProperty('a'), cc.hasOwnProperty('b')); // true false 说明第二个参数设置的是新对象自身可枚举的属性
  console.log(cc.__proto__); // {b: 1} 新对象cc的__proto__指向{b: 1}
  console.log(cc.__proto__ === Object.protorype); // false
  console.log(cc instanceof Object); // true cc是对象，原型链上肯定会出现Object
  ```

 `Object.create()`创建的对象的原型指向传入的对象。跟字面量和`new`关键字创建有区别。 

**总结**

- 字面量和`new`关键字创建的对象是`Object`的实例，原型指向`Object.prototype`，继承内置对象`Object`
- `Object.create(arg, pro)`创建的对象的原型取决于`arg`，`arg`为`null`，新对象是空对象，没有原型，不继承任何对象；`arg`为指定对象，新对象的原型指向指定对象，继承指定对象




### 40 js怎么控制一次加载一张图片，加载完后再加载下一张

1. ```js
   <script type="text/javascript">
   var obj=new Image();
   obj.src="http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg";
   obj.onload=function(){
   alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);
   document.getElementById("mypic").innnerHTML="<img src='"+this.src+"' />";
   }
   </script>
   <div id="mypic">onloading……</div>
   ```

2. ```js
   <script type="text/javascript">
   var obj=new Image();
   obj.src="http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg";
   obj.onreadystatechange=function(){
   if(this.readyState=="complete"){
   alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);
   document.getElementById("mypic").innnerHTML="<img src='"+this.src+"' />";
   }
   }
   </script>
   <div id="mypic">onloading……</div>
   ```

   

### 41 异步编程的实现⽅式

- 回调函数
  优点：简单、容易理解
  缺点：不利于维护，代码耦合⾼
- 事件监听(采⽤时间驱动模式，取决于某个事件是否发⽣)：
  优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
  缺点：事件驱动型，流程不够清晰
- 发布/订阅(观察者模式)
  类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者

- Promise对象
  优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；
  缺点：编写和理解，相对⽐较难
- Generator函数
  优点：函数体内外的数据交换、错误处理机制
  缺点：流程管理不⽅便
- async函数
  优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。
  缺点：错误处理机制

### 42 对原⽣Javascript了解程度

数据类型、运算、对象、Function、继承、闭包、作⽤域、原型链、事件、RegExp 、JSON 、Ajax 、DOM 、BOM 、内存泄漏、跨域、异步装载、模板引擎、前端MVC 、路由、模块化、Canvas 、ECMAScript

### 43 JS 数组和对象的遍历⽅式，以及⼏种⽅式的⽐较

for in 循环
for 循环
forEach

- 在⽅式⼀中， **for-in 需要分析出array 的每个属性，这个操作性能开销很⼤**。⽤在key 已知的数组上是⾮常不划算的。所以尽量不要⽤for-in ，除⾮你不清楚要处理哪些属性，例如 JSON 对象这样的情况
- 在⽅式2中，**循环每进⾏⼀次，就要检查⼀下数组⻓度**。读取属性（数组⻓度）要⽐读局部变量慢，尤其是当 array ⾥存放的都是 DOM 元素，因为每次读取都会扫描⼀遍⻚⾯上的选择器相关元素，速度会⼤⼤降低
- forEach 回调中两个参数分别为 value ， index；forEach ⽆法遍历对象；IE不⽀持该⽅法； Firefox 和 chrome ⽀持；forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环

### 44 gulp是什么

- gulp 是前端开发过程中⼀种基于流的代码构建⼯具，是⾃动化项⽬的构建利器；它不仅能对⽹站资源进⾏优化，⽽且在开发过程中很多重复的任务能够使⽤正确的⼯具⾃动完成
- Gulp的核⼼概念：流。流，简单来说就是建⽴在⾯向对象基础上的⼀种抽象的处理数据的⼯具。在流中，定义了⼀些处理数据的基本操作，如读取数据，写⼊数据等，程序员是对流进⾏所有操作的，⽽不⽤关⼼流的另⼀头数据的真正流向
- gulp正是通过流和代码优于配置的策略来尽量简化任务编写的⼯作
- Gulp的特点：
  - 易于使⽤：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理
  - 构建快速 利⽤ Node.js 流的威⼒，你可以快速构建项⽬并减少频繁的 IO 操作
  - 易于学习 通过最少的 API ，掌握 gulp 毫不费⼒，构建⼯作尽在掌握：如同⼀系列流管道

### 45 function let var const

let

- 允许你声明⼀个作⽤域被限制在块级中的变量、语句或者表达式
- let绑定不受变量提升的约束，这意味着let声明不会被提升到当前
- 该变量处于从块开始到初始化处理的“暂存死区”

var

- 声明变量的作⽤域限制在其声明位置的上下⽂中，⽽⾮声明变量总是全局的
- 由于变量声明（以及其他声明）总是在任意代码执⾏之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明

const

- 声明创建⼀个值的只读引⽤ (即指针)
- 基本数据当值发⽣改变时，那么其对应的指针也将发⽣改变，故造成 const 申明基本数据类型时，值不可以修改
- 但是如果是引用类型时，仅保存对象的指针， const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。 

**function let var const**

- function,var声明的变量依附在最近函数作用域或全局作用域，let,const声明的变量依附在最近块级作用域、函数作用域或全局作用域
- function,var声明的变量在编译阶段产生变量提升，且函数优先提升。let，const不会产生变量提升
- fucntion，var在同一作用域重复声明变量，后者会覆盖前者（前者与后者的关系要看编译环节过后的代码）；而let,const 会直接抛出语法错误
- const 声明变量的同时需要赋值，否则抛出语法错误，且变量的指向不能变（但是变量指向的内容可以变）

| 关键字 | 变量提升 | 块级作用域 | 初始值 | 更改值 | 通过window调用 |
| ------ | -------- | ---------- | ------ | ------ | -------------- |
| var    | √        | x          | -      | Yes    | Yes            |
| let    | x        | √          | -      | Yes    | No             |
| const  | x        | √          | Yes    | No     | No             |

### 46 希望获取到⻚⾯中所有的checkbox怎么做？

不使⽤第三⽅框架

```javascript
var domList = document.getElementsByTagName(‘input’)
var checkBoxList = [];
var len = domList.length; //缓存到局部变量
while (len--) { //使⽤while的效率会⽐for循环更⾼
	if (domList[len].type == ‘checkbox’) {
		checkBoxList.push(domList[len]);
	}
}
```

### 47 添加、移除、移动、复制、创建和查找节点

创建新节点

```javascript
createDocumentFragment() //创建⼀个DOM⽚段
createElement() //创建⼀个具体的元素
createTextNode() //创建⼀个⽂本节点
```

添加、移除、替换、插⼊

```javascript
appendChild() //添加
removeChild() //移除
replaceChild() //替换
insertBefore() //插⼊
```

查找

```javascript
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name属性的值
getElementById() //通过元素Id，唯⼀性
```

### 48 正则表达式

正则表达式构造函数`var reg=new RegExp(“xxx”) `与正则表达字⾯量`var reg=//` 有什么不同？

当使⽤RegExp() 构造函数的时候，不仅需要转义引号（即\ ”表示”），并且还需要双反斜杠（即\\ 表示⼀个\ ）。**使⽤正则表达字⾯量的效率更⾼**

语法：

 字面量, 构造函数和工厂符号都可以定义一个正则对象 

```js
/pattern/flags
new RegExp(pattern, [flags])
RegExp(pattern, [flags])
//例如
var re = new RegExp(/^\d{3,}$/, ["i"])
```

pattern：正则表达式的文本
flags：修饰符 

| flags | 描述                                                         |
| :---: | :----------------------------------------------------------- |
|   i   | 执行对大小写不敏感的匹配                                     |
|   g   | 全局匹配（会查找所有匹配结果，不会在查找到第一个匹配后就停止） |
|   m   | 执行多行匹配                                                 |

元字符

| 定位符 | 描述                                                       |
| :----: | :--------------------------------------------------------- |
|   ^    | 匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置 |
|   $    | 匹配行或字符串的结尾                                       |
|   \b   | 匹配单词边界，即单词与空格间的位置                         |
|   \B   | 匹配非单词边界                                             |

|  字符  | 描述                                                         |
| :----: | :----------------------------------------------------------- |
|   \d   | 匹配数字                                                     |
|   \D   | 匹配任意非数字的字符                                         |
|   \w   | 匹配字母，数字，下划线                                       |
|   \W   | 匹配任意不是字母，数字，下划线的字符                         |
| **.**  | 匹配除了换行符以外的任何字符                                 |
|  ( )   | 标记一个子表达式的开始和结束位置，常用于分组，子表达式可以获取供以后使用 |
|   \|   | 类似于或运算符，匹配两项之间的一个选择                       |
|   [    | 中括号表达式的开始                                           |
|   {    | 限定符表达式的开始                                           |
|   \    | 将下一个字符进行转义，要匹配’\d’，请使用’\\d’                |
| [abc]  | 匹配括号内指定元素的字符，也可以写成 [a-z] 匹配所有小写英文字母 |
| [^abc] | 匹配除了abc以外的任意字符                                    |

| 非打印字符 | 描述                                                         |
| :--------: | :----------------------------------------------------------- |
|    \cx     | 匹配由x指明的控制字符，例如 \cM 匹配一个 Control-M 或回车符，x 的值必须为A-Z或a-z之一 |
|     \f     | 匹配一个换页符，等价于 \x0c 和 \cL                           |
|     \n     | 匹配一个换行符，等价于 \x0a 和 \cJ                           |
|     \r     | 匹配一个回车符，等价于 \x0d 和 \cM                           |
|     \s     | 匹配任何空白字符，包括空格、制表符、换页符等等，等价于 [\f\n\r\t\v] |
|     \S     | 匹配任何非空白字符，等价于 [^\f\n\r\t\v]                     |
|     \t     | 匹配一个制表符，等价于 \x09 和 \cI                           |
|     \v     | 匹配一个垂直制表符，等价于 \x0b 和 \cK                       |

| 贪婪限定符 | 描述                               |
| :--------: | :--------------------------------- |
|     *      | 匹配前面的子表达式任意次           |
|     +      | 匹配前面的子表达式一次或多次       |
|     ?      | 匹配前面的子表达式零次或一次       |
|    {n}     | 匹配n次( n>0 )                     |
|    {n,}    | 至少匹配n次( n>0 )                 |
|   {n,m}    | 至少匹配n次且最多匹配m次( m>=n>0 ) |

| 惰性限定符 | 描述                                                 |
| :--------: | :--------------------------------------------------- |
|     *?     | 匹配前面的子表达式任意次，但是尽可能少重复           |
|     +?     | 匹配前面的子表达式一次或多次，但是尽可能少重复       |
|     ??     | 匹配前面的子表达式零次或一次，但是尽可能少重复       |
|   {n,}?    | 至少匹配n次( n>0 )，但是尽可能少重复                 |
|   {n,m}?   | 至少匹配n次且最多匹配m次( m>=n>0 )，但是尽可能少重复 |

正则进阶

|      捕获型      | 描述                                  |
| :--------------: | :------------------------------------ |
|     ( abc )      | 匹配abc，并捕获文本到自动命名的组里   |
| `( ?<name>abc )` | 匹配abc，并捕获文本到名称为name的组里 |

| 非捕获型 | 描述                                                         |
| :------: | :----------------------------------------------------------- |
| ( ?:x )  | 匹配abc，不捕获匹配的文本，也不给此分组分配组号              |
| ( ?=x )  | 零宽度正先行断言，仅当子表达式 x 在此位置的右侧匹配时才继续匹配，且此构造不会回溯。例如，/\d+(?=\.)/ 匹配 “3.141” 中数字后面是".“的实例，也就是"3”。 |
| ( ?!x )  | 零宽度负先行断言，仅当子表达式 x 不在此位置的右侧匹配时才继续匹配，例如，/\d+(?!\.)/ 匹配 “3.141x159” 中数字后面不是".“的实例，也就是"141”。 |
| ( ?<=x ) | 零宽度正后发断言（ES9已支持），仅当子表达式 x 在此位置的左侧匹配时才继续匹配，且此构造不会回溯，例如，/(?<=\.)\d+/ 匹配 “3.141” 中跟在".“后面的数字实例，也就是"141”。 |
| ( ?<!x ) | 零宽度负后发断言（ES9已支持），仅当子表达式 x 不在此位置的左侧匹配时才继续匹配，例如，/(?!\.)\d{3}/ 匹配 “3.141x592” 中没有跟在".“后面的三位数字实例，也就是"592”。 |

#### string支持4种使用正则表达式的方式

**search()** 

不支持全局匹配，会忽略修饰符g

```js
//@params: 一个正则表达式，如果参数不是一个正则表达式，那么会通过 `RegExp` 构造函数转成正则表达式
//@return: 第一个与之匹配的字符串的起始位置，若是没有发生匹配就返回数字 `-1`
  var a = 'javascript'
  'fsfsdjavsssjavasdfsfsjfjhhshh3r98u'.search(a) // 11
  
  var a = /[Jj]ava([Ss]crit)*/g;
  '012345javascript 67890'.search(a) // 6
```

replace()

```js
@params: RegExp | string (正则表达式，可以设置修饰符)
@params: function | string
@return: 返回一个新的字符串，不改变源对象
```

如果第一个参数是一个string，那么 `replace()` 将直接搜索这个字符串然后进行替换（注意这里指替换第一个搜索到的结果），并不会先转成 `RegExp` 进行匹配。 如果第一个参数是一个 `RegExp`，那么 `replace()` 将会进行正则匹配，将第一次匹配到结果进行替换，这里正则表达式可以设置修饰符。`g` 会进行全局多次匹配，将所有匹配到的结果进行替换

如果第二个参数是一个 `string`，那么 `replace()` 将匹配的结果直接用这个字符串替换 如果第二个参数是一个 `function`，我们看看可以有哪些参数： @params: 完整模式匹配到的结果 @params: 完整模式下的子模式匹配到的结果，看正则表达式中有多少个圆括号，那么这里就可以有多少个这样的参数，每个参数表示对应的子模式匹配的结果 @return: 使用 `return` 的返回值替换匹配到的值

```js
    var a = /([Jj]ava([Ss]cript))\sis\s(fun\w*)/g;
    var b = 'ffhfhjavascript is functionsdfffsff';
    
    b.replace(a, function(match) {
        // 打印的结果就是 javascript is functionsdfffsff 123
    	console.log(match, 123);
    	return '@@@@'
    });
    // ffhfh@@@@

    b.replace(a, function(match, v1, v2, v3) {
        // 打印的结果就是 javascript is functionsdfffsff 123
        console.log(match, 123);
        // javascript
        console.log(v1);
        // script
        console.log(v2);
        // functionsdfffsff
        console.log(v3);
    
    	return '@@@@'
    });
    // ffhfh@@@@
```

**match()**

```js
@params: 正则表达式 | string（通过 `RegExp` 的构造函数转化成正则表达式）
@return: 数组，
```

如果这个正则表达式没有设置修饰符 `g`，`match()` 就不会进行全局检索，只检索第一个匹配。在这种情况下：数组的第一个元素就是就是完整模式匹配的结果，其余的元素则是正则表达式中圆括号的子表达式匹配的结果（如果没有圆括号就不会有这些元素）。`index` 表示匹配的位置，`input` 表示目标字符串

```js
  var a = /([Jj]ava([Ss]cript))\sis\s(fun\w*)/;
  var b = 'ffhfhjavascript is functionsdfffsff';
  
  b.match(a)
  // ["javascript is functionsdfffsff", "javascript", "script", "functionsdfffsff", index: 5, input: "ffhfhjavascript is functionsdfffsff", groups: undefined]

```

如果添加了修饰符`g`，那么返回的数组中就是多次全局模式匹配的结果

```js
  var a = /123(sxx)456(hello)/g;
  var b ='123sxx456helloffffjfljfj123sxx456hellojjweww123456hello123sxx456hello';
  
  b.match(a)
  // ["123sxx456hello", "123sxx456hello", "123sxx456hello"]
```

#### RegExp的两种方法：exec() 和 test()

**exec()**

```js
@params: string
@return: 数组 | null
```

如果匹配到结果就返回一个数组，结果和字符串的 `match()` 方法的非全局匹配返回的结果一样。但是有一点和 `match()` 不一样，就是不管式全局还是非全局都是一样的结构。如果没有匹配到结果就返回 `null`

```js
  var a = /123(sxx)456(hello)/g;
  var b ='123sxx456helloffffjfljfj123sxx456hellojjweww123456hello123sxx456hello';
  a.exec(b);
  // [“123sxx456hello", "sxx", "hello", index: 0, input: "123sxx456helloffffjfljfj123sxx456hellojjweww123456hello123sxx456hello", groups: undefined]
```

**test()**

```js
@params: string
@return: boolean
```

这个方法很简，匹配成功就返回`true`，否则就返回`false`

#### 常用正则

 目前收集整理了21个常用的javaScript正则表达式，其中包括用户名、密码强度、整数、数字、电子邮件地址（Email）、手机号码、身份证号、URL地址、 IP地址、 十六进制颜色、 日期、 微信号、车牌号、中文正则等。 

**密码强度正则**

密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符

```js
var pattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).*$/;
```

**数字相关正则**

```js
var posPattern = /^\d+$/; // 正整数正则
var negPattern = /^-\d*\.\d+$/; // 负浮点数正则
var posPattern = /^\d*\.?\d+$/; // 正数正则
var numPattern = /^-?\d*\.?\d+$/; // 数字正则
```

**通用日期正则**

```js
var dP2 = /^\d{4}-\d{1,2}-\d{1,2}$/;
```

**Email正则**

- 基本Email正则

```js
var pattern = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;
```

- 特定域名Email正则 在手机验证码出现之前，差不多邮箱验证是保证用户唯一性的唯一条件。而临时邮箱（也称10分钟邮箱或一次性邮箱）的出现，则使得邮箱验证及帐户激活这种机制失去了意义。而临时邮箱的地址是不可枚举的，我们只能才采取白名单的方式，只允许有限的邮箱域名通过验证。

```js
var pattern = /^([A-Za-z0-9_\-\.])+\@(163.com|qq.com)$/;
```

此方法虽然能保证验证安全性，但是如果白名单太长会造成模式字符串太长。这时可以将邮箱域名白名单写成数组，利用正则表达式做初步验证，用白名单做域名的二次验证。

常用域名白名单数组：

```js
var domains= ["qq.com","163.com","vip.163.com","263.net","yeah.net","sohu.com","sina.cn","sina.com","eyou.com","gmail.com","hotmail.com"];
```

上述白名单只列举了常用的11种邮箱域名，可以根据需要适当补充或删减。

**手机号码正则**

```js
var mPattern = /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d{8}$/;
```

**身份证号（18位）正则**

```js
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
```

**URL正则**

```js
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
```

**IP地址**

// IPv4地址正则

```js
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
```

// IPv6地址正则

```js
var pattern = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;
```

**十六进制颜色正则 / RGB Hex颜色正则**

```js
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
```

**QQ号正则，5至11位**

```js
var qqPattern = /^[1-9][0-9]{4,10}$/;
```

**微信号正则，6至20位，以字母开头，字母，数字，减号，下划线**

```js
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
```

**车牌号正则**

```js
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
```

**包含中文正则**

```js
var cnPattern = /[\u4E00-\u9FA5]/;
```

**中国邮编(中国邮政编码为6位数字)**

```js
var pattern = /^[1-9]\d{5}(?!\d)$/
```

**空白行的正则表达式**

```js
var pattern = /\n\s*\r/ (可以用来删除空白行)
```

### 49 Javascript中callee和caller的作⽤？

- caller 是**返回⼀个对函数的引⽤，该函数调⽤了当前函数**；
- callee 是**返回正在被执⾏的function 函数，也就是所指定的function 对象的正⽂**

如果⼀对兔⼦每⽉⽣⼀对兔⼦；⼀对新⽣兔，从第⼆个⽉起就开始⽣兔⼦；假定每对兔⼦都是⼀雌⼀雄，试问⼀对兔⼦，第n个⽉能繁殖成多少对兔⼦？（使⽤callee 完成）

```javascript
var result=[];
function fn(n){ //典型的斐波那契数列
	if(n==1){
		return 1;
	}else if(n==2){
		return 1;
	}else{
		if(result[n]){
			return result[n];
		}else{
			//argument.callee()表示fn()
			result[n]=arguments.callee(n-1)+arguments.callee(n-2);
			return result[n];
		}
	}
}
```

### 50 DOMContentLoaded，load，beforeunload，unload

HTML页面的生命周期包含三个重要事件：

- `DOMContentLoaded`–浏览器已完全加载HTML，并且已构建DOM树，但是`  <img>  `可能尚未加载外部资源（如图片和样式表）。
- `load` –不仅加载HTML，而且还加载所有外部资源：图像，样式等。
- `beforeunload/unload` –用户正在离开页面。

每个事件都可能有用：

- `DOMContentLoaded` 事件– DOM准备就绪，因此处理程序可以查找DOM节点，初始化接口。
- `load` 事件-加载了外部资源，因此应用了样式，已知图像大小等。
- `beforeunload` 事件–用户要离开：我们可以检查用户是否保存了更改，并询问他们是否真的要离开。
- `unload` –用户几乎离开了，但是我们仍然可以启动一些操作，例如发送统计信息。

#### **DOMContentLoaded**

该DOMContentLoaded事件发生在document对象上。我们必须使用addEventListener它来捕获它：

```js
document.addEventListener("DOMContentLoaded", readyFunc);
```

 当浏览器处理HTML文档并遇到`  <script>  `标签时，它需要在继续构建DOM之前执行。这是一种预防措施，因为脚本可能想要修改DOM，甚至要对其进行修改`document.write`，因此`DOMContentLoaded`必须等待。

```html
<script>
  document.addEventListener("DOMContentLoaded", () => {
    alert("DOM ready!");
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>

<script>
  alert("Library loaded, inline script executed");
</script>

//we first see “Library loaded…”, and then “DOM ready!” (all scripts are executed).
```

此规则有两个例外：

1. 与脚本`async`属性，不阻塞`DOMContentLoaded`。
2. 动态生成`document.createElement('script')`并随后添加到网页的脚本也不会阻止此事件。

 外部样式表css不会影响DOM，因此`DOMContentLoaded`不要等待它们。但是有一个陷阱,如果样式后面有一个脚本，则该脚本必须等待样式表加载。 这样做的原因是脚本可能希望获取元素的坐标和其他与样式相关的属性 。

```html
<link type="text/css" rel="stylesheet" href="style.css">
<script>
  // the script doesn't not execute until the stylesheet is loaded
  alert(getComputedStyle(document.body).marginTop);
</script>
```

 Firefox，Chrome 和 Opera 都会在 `DOMContentLoaded` 中自动填充表单。 

#### window.onload

当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件。可以通过 onload 属性获取此事件。

```js
<script>
  window.onload = function() { // 与此相同 window.addEventListener('load', (event) => {
    alert('Page loaded');

    // 此时图片已经加载完成
    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);
  };
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
```

**document.ready和window.onload的区别**

页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。

**ready事件在DOM结构绘制完成之后就会执行**，这样能确保就算有大量的媒体文件没加载出来，JS代码一样可以执行。Dom Ready的意义是：在Dom节点创建完成后执行。通常一个页面加载的顺序是，域名解析——加载html——加载js和css——加载图片等其他信息。那么**Dom Ready应该在“加载js和css”和“加载图片等其他信息”之间**。

```js
$(function(){ 
      // do something 
});
//$(function()){}是jQuery的方法
//$(document).ready(function(){})；$().ready(function(){})；和$(function(){})三者都是一样的
```

**load事件必须等到网页中所有内容全部加载完毕之后才被执行**。如果一个网页中有大量的图片的话，则就会出现这种情况：网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致load事件不能够即时被触发。Dom Load的意义是：在页面所有资源加载完后执行，document文档包括了加载图片等其他信息。那么**Dom Load就是在页面响应加载的顺序中的“加载图片等其他信息”之后**。 

用一例子来通俗地解释：比如，页面中只有一个img标签，加载页面时，window.οnlοad=function(){}中的代码要等图片完全显示出来之后才执行（假设其他代码都在图片显示之前加载完了）；而 $(function(){ }) 等`<img/>`标签加载完就执行了，这时候图片可能还没有显示出来。

DOM文档加载步骤：
1、解析HTML结构
2、加载外部的脚本和样式文件
3、解析并执行脚本代码
4、执行$(function(){})内对应代码
5、加载图片等二进制资源
6、页面加载完毕，执行window.onload

区别：

- `$(document).ready`要比`window.onload`先执行

- `window.onload`只能出来一次，`$(document).ready`可以出现多次

  ```js
  window.onload=function(){
  alert(3)
  }
  window.onload=function(){
  alert(5)
  }
  //两个window.onload，则只会弹出5
  
  $(document).ready(function(){
  	alert("1")
  })
  $(document).ready(function(){
  	alert("2")
  })
  $(document).ready(function(){
  	alert("3")
  })
  //同时多个$(document).ready()，则会全部弹出1,2,3
  ```



#### window.onunload

当访问者离开页面时，window 对象上的 unload 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。

有一个值得注意的特殊情况是**发送分析数据**。

假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。

自然地，当用户要离开的时候，我们希望通过 `unload` 事件将数据保存到我们的服务器上。有一个特殊的 `navigator.sendBeacon(url, data)` 方法可以满足这种需求。它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 `sendBeacon`。

```css
let analyticsData = { /* 带有收集的数据的对象 */ };

window.addEventListener("unload", function() {
  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
};
```

#### window.onbeforeunload

如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将要求进行更多确认。如果我们要取消事件，浏览器会询问用户是否确定。

```js
window.onbeforeunload = function() {
  return "There are unsaved changes. Leave now?";
};
```

#### readyState

如果我们将 DOMContentLoaded 事件处理程序设置在文档加载完成之后，会发生什么？
很自然地，它永远不会运行。

在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。
document.readyState 属性可以为我们提供当前加载状态的信息。

它有 3 个可能值：

- loading —— 文档正在被加载。

- interactive —— 文档被全部读取。

- complete —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。

所以，我们可以检查 document.readyState 并设置一个处理程序，或在代码准备就绪时立即执行它。

```js
function work() { /*...*/ }

if (document.readyState == 'loading') {
  // 仍在加载，等待事件
  document.addEventListener('DOMContentLoaded', work);
} else {
  // DOM 已就绪！
  work();
}
```

 还有一个 `readystatechange` 事件，会在状态发生改变时触发，因此我们可以打印所有这些状态 

```js
// 当前状态
console.log(document.readyState);

// 状态改变时打印它
document.addEventListener('readystatechange', () => console.log(document.readyState));
```

**总结**

 让我们看看完整的事件流。 

```js
<script>
  log('initial readyState:' + document.readyState);

  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));
  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));

  window.onload = () => log('window onload');
</script>

<iframe src="iframe.html" onload="log('iframe onload')"></iframe>

<img src="http://en.js.cx/clipart/train.gif" id="img">
<script>
  img.onload = () => log('img onload');
</script>
```

典型输出：

1. [1] initial readyState:loading
2. [2] readyState:interactive
3. [2] DOMContentLoaded
4. [3] iframe onload
5. [4] img onload
6. [4] readyState:complete
7. [4] window onload

方括号中的数字表示发生这种情况的大致时间。标有相同数字的事件几乎是同时发生的（± 几毫秒）。

- 在 `DOMContentLoaded` 之前，`document.readyState` 会立即变成 `interactive`。它们俩的意义实际上是相同的。
- 当所有资源（`iframe` 和 `img`）都加载完成后，`document.readyState` 变成 `complete`。这里我们可以发现，它与 `img.onload`（`img` 是最后一个资源）和 `window.onload` 几乎同时发生。转换到 `complete` 状态的意义与 `window.onload` 相同。区别在于 `window.onload` 始终在所有其他 `load` 处理程序之后运行。

页面生命周期事件：

- 当 DOM 准备就绪时，document 上的 DOMContentLoaded 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。
  - 诸如 `<script>...</script>` 或 `<script src="..."></script>` 之类的脚本会阻塞 DOMContentLoaded，浏览器将等待它们执行结束。
  - 图片和其他资源仍然可以继续被加载。
  - 当页面和所有资源都加载完成时，window 上的 load 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。

- 当用户想要离开页面时，window 上的 beforeunload 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。
  当
- 用户最终离开时，window 上的 unload 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 navigator.sendBeacon 来发送网络请求。
- document.readyState 是文档的当前状态，可以在 readystatechange 事件中跟踪状态更改：
  - loading —— 文档正在被加载。
  - interactive —— 文档已被解析完成，与 DOMContentLoaded 几乎同时发生，但是在 DOMContentLoaded 之前发生。
  - complete —— 文档和资源均已加载完成，与 window.onload 几乎同时发生，但是在 window.onload 之前发生。

### 51 addEventListener()和attachEvent()

- addEventListener() 是符合W3C规范的标准⽅法; attachEvent() 是IE低版本的⾮标准⽅法
- addEventListener() ⽀持事件冒泡和事件捕获; - ⽽attachEvent() 只⽀持事件冒泡
- addEventListener() 的第⼀个参数中,事件类型不需要添加on ; attachEvent() 需要添加'on'
- 如果为同⼀个元素绑定多个事件, addEventListener() 会按照事件绑定的顺序**依次执⾏**,attachEvent() 会按照事件绑定的顺序**倒序执⾏**

### 52 获取⻚⾯所有的checkbox

```javascript
var resultArr= [];
var input = document.querySelectorAll('input');
for( var i = 0; i < input.length; i++ ) {
	if( input[i].type == 'checkbox' ) {
		resultArr.push( input[i] );
	}
}
//resultArr即中获取到了⻚⾯中的所有checkbox
```

### 53 Javascript全局函数和全局变量

全局变量

- Infinity 代表正的⽆穷⼤的数值。
- NaN 指示某个值是不是数字值。
- undefined 指示未定义的值。

全局函数

- decodeURI() 解码某个编码的 URI 。
- decodeURIComponent() 解码⼀个编码的 URI 组件。
- encodeURI() 把字符串编码为 URI。
- encodeURIComponent() 把字符串编码为 URI 组件。
- escape() 对字符串进⾏编码。
- eval() 计算 JavaScript 字符串，并把它作为脚本代码来执⾏。
- isFinite() 检查某个值是否为有穷⼤的数。
- isNaN() 检查某个值是否是数字。
- Number() 把对象的值转换为数字。
- parseFloat() 解析⼀个字符串并返回⼀个浮点数。
- parseInt() 解析⼀个字符串并返回⼀个整数。
- String() 把对象的值转换为字符串。
- unescape() 对由escape() 编码的字符串进⾏解码

### 54 执⾏上下⽂

当执⾏ JS 代码时，会产⽣三种执⾏上下⽂

- 全局执⾏上下⽂
- 函数执⾏上下⽂
- eval 执⾏上下⽂

每个执⾏上下⽂中都有三个重要的属性

- 变量对象（ VO ），包含变量、函数声明和函数的形参，该属性只能在全局上下⽂中访问
- 作⽤域链（ JS 采⽤词法作⽤域，也就是说变量的作⽤域是在定义时就决定了）
- this

```js
var a = 10
function foo(i) {
	var b = 20
}
foo()
```

对于上述代码，执⾏栈中有两个上下⽂：全局上下⽂和函数 foo 上下⽂。

```js
stack = [
	globalContext,
	fooContext
]
```

对于全局上下⽂来说， VO ⼤概是这样的

```js
globalContext.VO === globe
globalContext.VO = {
	a: undefined,
	foo: <Function>,
}
```

对于函数 foo 来说， VO 不能访问，只能访问到活动对象（ AO ）

```js
fooContext.VO === foo.AO
fooContext.AO {
	i: undefined,
	b: undefined,
	arguments: <>
}
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是⼀个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调⽤者
```

对于作⽤域链，可以把它理解成包含⾃身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量

```js
fooContext.[[Scope]] = [
	globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
	fooContext.VO,
	globalContext.VO
]
```

接下来让我们看⼀个⽼⽣常谈的例⼦， var

```js
b() // call b
console.log(a) // undefined
var a = 'Hello world'
function b() {
	console.log('call b')
}
```

想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释应该是：在⽣成执⾏上下⽂时，会有两个阶段。第⼀个阶段是创建的阶段（具体步骤是创建 VO ）， JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以直接提前使⽤。

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```js
b() // call b second
function b() {
	console.log('call b fist')
}
function b() {
	console.log('call b second')
}
var b = 'Hello world'
```

var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。let 不能在声明前使⽤，但是这并不是常说的 let 不会提升， let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使⽤。

对于⾮匿名的⽴即执⾏函数需要注意以下⼀点

```js
var foo = 1
(function foo() {
	foo = 10
	console.log(foo)
}()) // -> ƒ foo() { foo = 10 ; console.log(foo) }
```

因为当 JS 解释器在遇到⾮匿名的⽴即执⾏函数时，会创建⼀个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到foo ，但是这个值⼜是只读的，所以对它的赋值并不⽣效，所以打印的结果还是这个函数，并且外部的值也没有发⽣更改。

```js
specialObject = {};
Scope = specialObject + Scope;
foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}
delete Scope[0]; // remove specialObject from the front of scope chain
```

### 55 怎么判断两个对象相等？（stringify）

```javascript
obj={
	a:1,
	b:2
}
obj2={
	a:1,
	b:2
}
obj3={
	a:1,
	b:'2'
}

JSON.stringify(obj)==JSON.stringify(obj2);//true
JSON.stringify(obj)==JSON.stringify(obj3);//false
```

### 56 

### 57 如何实现sleep的效果

(1)while循环的方式

```js
function sleep(ms){
   var start=Date.now(),expire=start+ms;
   while(Date.now()<expire);
   console.log('1111');
   return;
}
```

执行sleep(1000)之后，休眠了1000ms之后输出了1111。上述循环的方式缺点很明显，容易造成死循环。

(2)通过promise来实现

```js
function sleep(ms){
  var temple=new Promise(
  (resolve)=>{
  console.log(111);setTimeout(resolve,ms)
  });
  return temple
}
sleep(500).then(function(){
   //console.log(222)
})
//先输出了111，延迟500ms后输出222
```

(3)通过async封装

```js
function sleep(ms){
  return new Promise((resolve)=>setTimeout(resolve,ms));
}
async function test(){
  var temple=await sleep(1000);
  console.log(1111)
  return temple
}
test();
//延迟1000ms输出了1111
```

(4).通过generate来实现

```js
function* sleep(ms){
   yield new Promise(function(resolve,reject){
             console.log(111);
             setTimeout(resolve,ms);
        })  
}
sleep(500).next().value.then(function(){console.log(2222)})
```



### 58 防抖/节流

**防抖： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。** 返回函数连续调⽤时，空闲时间必须⼤于或等于 wait，func 才会执⾏

 通过闭包保存一个标记来保存 `setTimeout` 返回的值，每当用户输入的时候把前一个 `setTimeout` clear 掉，然后又创建一个新的 `setTimeout`，这样就能保证输入字符后的 `interval` 间隔内如果还有字符输入的话，就不会执行 `fn` 函数了。 

```javascript
function debounce(func, ms) {
  let timer;
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      func.apply(this, args);
    }, ms);
  };
}
```

**节流： 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。** 

 函数的节流就是通过闭包保存一个标记（`canRun = true`），在函数的开头**判断**这个标记是否为 `true`，如果为 `true` 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 `false`，然后把外部传入的函数的执行包在一个 `setTimeout` 中，最后在 `setTimeout` 执行完毕后再把标记设置为 `true`（这里很关键），表示可以执行下一次的循环了。当 `setTimeout` 还未执行的时候，`canRun` 这个标记始终为 `false`，在开头的判断中被 return 掉。 

```javascript
function throttle(func, ms) {
  let canRun = true;
  return function (...args) {
    if (!canRun) return;
    canRun = false;
    setTimeout(() => {
      func.apply(this, args);
      canRun = true;
    }, ms);
  };
}
```

总结

- 函数防抖和函数节流**都是防止某一时间频繁触发**，但是这两兄弟之间的原理却不一样。
- **函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。**

结合应用场景

- debounce 
  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- throttle 
  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

### 59 变量提升

**当执⾏ JS 代码时，会⽣成执⾏环境，只要代码不是写在函数中的，就是在全局执⾏环境中，函数中的代码会产⽣函数执⾏环境，只此两种执⾏环境.**

通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释应该是：在⽣成执⾏环境时，会有两个阶段。**第⼀个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以直接提前使⽤**

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```javascript
b() // call b second
function b() {
	console.log('call b fist')
}
function b() {
	console.log('call b second')
}
var b = 'Hello world'
```

复制代码var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。let 不能在声明前使⽤，但是这并不是常说的 let 不会提升， let 提升了，在第⼀阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使⽤

### 60 单线程和异步的关系

单线程 - 只有⼀个线程，只能做⼀件事

原因 - 避免 DOM 渲染的冲突

- 浏览器需要渲染 DOM
- JS 可以修改 DOM 结构
- JS 执⾏的时候，浏览器 DOM 渲染会暂停
- 两段 JS 也不能同时执⾏（都修改 DOM 就冲突了）
- webworker ⽀持多线程，但是不能访问 DOM

解决⽅案 - 异步

### 61 事件循环 Eventloop（宏任务，微任务）

 ![事件循环1](/../../../../Typora图库/Web前端/事件循环1.png)

 从上图我们可以看出，js主线程它是有一个**执行栈**的，所有的js代码都会在执行栈里运行。在执行代码过程中，如果遇到一些异步代码(比如setTimeout,ajax,promise.then以及用户点击等操作),那么浏览器就会将这些代码放到一个线程(在这里我们叫做**幕后线程**)中去等待，不阻塞主线程的执行，主线程继续执行栈中剩余的代码，当幕后线程（background thread）里的代码准备好了(比如setTimeout时间到了，ajax请求得到响应),该线程就会将它的**回调函数放到任务队列**中等待执行。而当主线程执行完栈中的所有代码后，它就会检查**任务队列**是否有任务要执行，如果有任务要执行的话，那么就将该任务放到执行栈中执行。如果当前**任务队列**为空的话，它就会一直循环等待任务到来。因此，这叫做事件循环。 

正确的⼀次 Event loop 顺序是这样的

- 执行一个宏任务，如果执行栈中没有就从任务队列中获取
- 执行过程中如果产生微任务，就加他添加到微任务队列中
- 宏任务执行完毕之后，立即依次执行微任务队列中的所有微任务
- 当前宏任务执行完毕之后，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕之后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的 界⾯响应，我们可以把操作 DOM 放⼊微任务中

![1600494262832](/../../../../Typora图库/Web前端/事件循环.png)

语言标准（js引擎）提供的是微任务，微任务包括 process.nextTick (nodejs)  ， promise ， Object.observe ，MutationObserver
异步任务之间，宿主环境（浏览器、node）提供的方法是宏任务，宏任务包括 script ， setTimeout ， setInterval ， setImmediate ， I/O ，UI renderin



**1.Promise/then、catch中的任务怎么执行**

Promise中的异步体现在`then`和`catch`中，`then`和`catch`中的代码一定要等Promise中的代码执行完才能执行，而不是并发执行

因此，**写在Promise的代码是被当做同步任务来执行的**，在主线程的执行栈中，一旦轮到它执行了就会立即执行

而`then`和`catch`中代码会被加入到微任务队列中，等同步任务全部执行完，才会被加入执行栈中执行。

需要注意的是，**`then`和`catch`中代码是被加入到微任务队列中**的而不是任务队列，不要受“主线程之外，事件触发线程管理着一个任务队列，只要异步任务（如定时器，http请求）出现，就会在任务队列中放置一个事件”这句话的影响，这句话所说的异步任务指的是浏览器渲染进程新开的线程来执行的异步任务。

**2.async/await中的任务怎么执行**

async/await与Promise的作用相同，async/await 本身就是promise+generator的语法糖。

**async中的代码是被当做同步任务来执行的**，在主线程的执行栈中，一旦轮到它执行了就会立即执行。

await实际上是一个让出线程的标志，await后面的表达式会先执行一遍，**将await后面的代码加入到微任务队列中**，然后就会跳出整个async函数来执行后面的代码。

**3.setTimeout中的任务怎么执行**

JS引擎线程在在解析JS代码时，遇到setTimeout，浏览器渲染进程会新开一个线程定时器触发线程，此时，setTimeout中的回调函数将加入任务队列里面，等主线程执行栈中上一个宏任务执行完毕，在下一轮事件循环时回调函数才从任务队列中被添加到执行栈中执行

**4.分析例子**

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');

/*
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/
```

- 上面是一段JS代码，JS引擎线程开始解析，这时，宏任务队列中只有一个script(整体代码)任务

- 然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 `console` 语句，直接输出 `script start`。输出之后，script 任务继续往下执行，遇到 `setTimeout`，其作为一个宏任务源，则会先将其任务分发到对应的队列中

- script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出`async1 start`。

  遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出`async2`，然后将await后面的代码也就是`console.log('async1 end')`加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码。

- script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 `.then` 则会被分发到 microtask 的 `Promise` 队列中去。所以会先输出 `promise1`，然后执行 `resolve`，将 `promise2` 分配到对应队列。

- script任务继续往下执行，最后只有一句输出了 `script end`，至此，全局任务就执行完毕了。

  根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。

- 在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， `Promise` 队列有的两个任务`async1 end`和`promise2`，因此按先后顺序输出 `async1 end，promise2`。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。

- 第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 `setTimeout`，取出直接输出即可，至此整个流程结束。

### 62 消息队列

 消息就是注册异步任务时添加的回调函数。 

 ![img](/../../../../Typora图库/Web前端/消息队列.png) 

### 63 promise

**Promise 出现的原因 & 业界实现**

 在 Promise 出现以前，在我们处理多个异步请求嵌套时， 为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的**回调地狱**～产生**回调地狱**的原因归结起来有两点：

1. **嵌套调用**，第一个函数的输出往往是第二个函数的输入；
2. **处理多个异步请求并发**，开发时往往需要同步请求最终的结果。

原因分析出来后，那么问题的解决思路就很清晰了：

1. **消灭嵌套调用**：通过 Promise 的链式调用可以解决；
2. **合并多个任务的请求结果**：使用 Promise.all 获取合并多个任务的错误处理。

Promise 正是用一种更加友好的代码组织方式，解决了异步嵌套的问题。

可以把 Promise 看成⼀个状态机。**初始是 pending 状态，可以通过函数 resolve 和reject ，将状态转变为 fulfilled 或者 rejected 状态，状态⼀旦改变就不能再次变化。then 函数会返回⼀个 Promise 实例，并且该返回值是⼀个新的实例⽽不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的**，如果返回的是⼀个相同实例的话，多个 then 调⽤就失去意义了。 

```javascript
let fs = require('fs')

fs.readFile('./name.txt','utf8',function(err,data){
  fs.readFile(data, 'utf8',function(err,data){
    fs.readFile(data,'utf8',function(err,data){
      console.log(data);
    })
  })
})

//promise解决
let fs = require('fs')

function read(filename) {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) reject(err);
      resolve(data);
    })
  })
}

read('./name.txt').then((data)=>{
  return read(data) 
}).then((data)=>{
  return read(data)  
}).then((data)=>{
    console.log(data);
},err=>{
    console.log(err);
})

```

**基础版 Promise**

```javascript
const p1 = new Promise((resolve, reject) => {
  console.log('create a promise');
  resolve('成功了');
})

console.log("after new promise");

const p2 = p1.then(data => {
  console.log(data)
  throw new Error('失败了')
})

const p3 = p2.then(data => {
  console.log('success', data)
}, err => {
  console.log('faild Error: ', err)
})

```

 控制台输出： 

```
"create a promise"
"after new promise"
"成功了"
"faild Error: 失败了"
```

- 首先我们在调用 Promise 时，会返回一个 Promise 对象。

- 构建 Promise 对象时，需要传入一个 **executor 函数**，Promise 的主要业务流程都在 executor 函数中执行。

- 如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。

- Promise 的状态不可逆，同时调用 resolve 函数和 reject 函数，默认会采取第一次调用的结果。

 以上简单介绍了 Promise 的一些主要的使用方法，结合 Promise/A+ 规范，我们可以分析出 Promise 的基本特征： 

> **promise 有三个状态：`pending`，`fulfilled`，or `rejected`；**「规范 Promise/A+ 2.1」
>
> `new promise`时， 需要传递一个`executor()`执行器，执行器立即执行；
>
> `executor`接受两个参数，分别是`resolve`和`reject`；
>
> promise  的默认状态是 `pending`；
>
> promise 有一个`value`保存成功状态的值，可以是`undefined/thenable/promise`；「规范 Promise/A+ 1.3」
>
> promise 有一个`reason`保存失败状态的值；「规范 Promise/A+ 1.5」
>
> **promise 只能从`pending`到`rejected`, 或者从`pending`到`fulfilled`，状态一旦确认，就不会再改变**；
>
> promise 必须有一个`then`方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」
>
> 如果调用 then 时，promise 已经成功，则执行`onFulfilled`，参数是`promise`的`value`；
>
> 如果调用 then 时，promise 已经失败，那么执行`onRejected`, 参数是`promise`的`reason`；
>
> 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调`onRejected`；

**then 的链式调用&值穿透特性**

我们都知道，promise 的优势在于可以链式调用。在我们使用 Promise 的时候，当 then 函数中 return 了一个值，不管是什么值，我们都能在下一个 then 中获取到，这就是所谓的**then 的链式调用**。而且，当我们不在 then 中放入参数，例：`promise.then().then()`，那么其后面的 then 依旧可以得到之前 then 返回的值，这就是所谓的**值的穿透**。那具体如何实现呢？简单思考一下，如果每次调用 then 的时候，我们都重新创建一个 promise 对象，并把上一个 then 的返回结果传给这个新的 promise 的 then 方法，不就可以一直 then 下去了么？那我们来试着实现一下。这也是手写 Promise 源码的重中之重。

> then 的参数 `onFulfilled` 和 `onRejected` 可以缺省，如果 `onFulfilled` 或者 `onRejected`不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；
>
> promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个“新的promise"；
>
> 如果 then 的返回值 x 是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；
>
> 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调中；
>
> 如果 then 的返回值 x 是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛出异常，就走下一个 then 的失败；
>
> 如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中；
>
> 如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略；

**Proimise对象方法：all()、race()、reject()和resolve()**：

- all()用于将多个Promise实例包装成一个新的Promise实例，只有当所有的Promise实例的状态都为fulfilled，新实例才会变为fulfilled，否则就取第一个rejected的状态作为新的实例的状态；
- race()包装的新Promise实例会根据第一个率先改变状态的实例来决定其状态。
- resolve()和reject()用于将现有的非Promise对象转换为Promise对象。

**Promise中的then的异常处理方法和catch有什么区别？**

 第一，reject是用来抛出异常的，catch是用来处理异常的；第二：reject是Promise的方法，而then和catch是Promise实例的方法（Promise.prototype.then 和 Promise.prototype.catch）。 

```js
let p = new Promise()
p.catch()
p.reject() // 没有这个东西
Promise.reject()
Promise.catch() // 没有这个东西
```

主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。  

1. 使用promise.then(onFulfilled, onRejected) 的话
   - 在 onFulfilled 中发生异常的话，在 onRejected 中是捕获不到这个异常的。
2. 在 promise.then(onFulfilled).catch(onRejected) 的情况下
   - then 中产生的异常能在 .catch 中捕获

then的第二个参数和catch捕获错误信息同时可以捕获的时候会**就近原则**，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。 

```js
const promise = new Promise((resolve, rejected) => {
    throw new Error('test');
});

//此时只有then的第二个参数可以捕获到Promise内部抛出的错误信息
promise.then(res => {
    throw new Error('hello');
}, err => {
    console.log(err);
}).catch(err1 => {
    console.log(err1);
});

//此时只有catch可以捕获到Promise的onFulfilled抛出的错误信息
p
  .then(function () {
    throw new Error()
  }, function () {
    // won't capture this error
  })
  .catch(function () {
    // will capture the error
  })
```

两个捕获方法的比较：

```js
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
```

 上面代码中，第二种写法要好于第一种写法，理由是**第二种写法可以捕获前面then方法执行中的错误**（如果前面几个then时，某一个then抛出异常，后面then不会执行，类似break，直接进入catch捕捉异常），也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 

### 64 完成⼀个Dialog组件，说说你设计的思路？

- 该组件需要提供hook 指定渲染位置，默认渲染在body下⾯。
- 然后改组件可以指定外层样式，如宽度等
- 组件外层还需要⼀层mask 来遮住底层内容，点击mask 可以执⾏传进来的onCancel 函数关闭Dialog 。
- 另外组件是可控的，需要外层传⼊visible 表示是否可⻅。
- 然后Dialog 可能需要⾃定义头head和底部footer ，默认有头部和底部，底部有⼀个确认按钮和取消按钮，确认按钮会执⾏外部传进来的onOk 事件，然后取消按钮会执⾏外部传进来的onCancel 事件。
- 当组件的visible 为true 时候，设置body 的overflow 为hidden ，隐藏body 的滚动条，反之显示滚动条。
- 组件⾼度可能⼤于⻚⾯⾼度，组件内部需要滚动条。
- 只有组件的visible 有变化且为ture 时候，才重渲染组件内的所有内容

### 65 ajax、axios、fetch区别

**jQuery ajax**

```js
$.ajax({
	type: 'POST',
	url: url,
	data: data,
	dataType: dataType,
	success: function () {},
	error: function () {}
});
```

优缺点：

- 本身是针对MVC 的编程,不符合现在前端MVVM 的浪潮
- 基于原⽣的XHR 开发， XHR 本身的架构不清晰，已经有了fetch 的替代⽅案
- JQuery 整个项⽬太⼤，单纯使⽤ajax 却要引⼊整个JQuery ⾮常的不合理（采取个性化打包的⽅案⼜不能享受CDN服务）

**axios**

```javascript
axios({
	method: 'post',
	url: '/user/12345',
	data: {
		firstName: 'Fred',
		lastName: 'Flintstone'
	}
})
.then(function (response) {
	console.log(response);
})
.catch(function (error) {
	console.log(error);
});
```

优缺点：

- 从浏览器中创建 XMLHttpRequest
- 从 node.js 发出 http 请求
- ⽀持 Promise API
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- ⾃动转换JSON 数据
- 客户端⽀持防⽌CSRF/XSRF

**fetch**

```javascript
try {
	let response = await fetch(url);
	let data = response.json();
	console.log(data);
} catch(e) {
	console.log("Oops, error", e);
}
```

优缺点：

- fetcht 只对⽹络请求报错，对400 ， 500 都当做成功的请求，需要封装去处理
- fetch 默认不会带cookie ，需要添加配置项
- fetch 不⽀持abort ，不⽀持超时控制，使⽤setTimeout 及Promise.reject 的实现的超时控制并不能阻⽌请求过程继续在后台运⾏，造成了量的浪费
- fetch 没有办法原⽣监测请求的进度，⽽XHR可以

### 66 深浅拷贝

浅拷贝---浅拷贝是指复制对象的时候，只对第一层键值对进行独立的复制，如果对象内还有对象，则只能复制嵌套对象的地址

深拷贝---深拷贝是指复制对象的时候完全的拷贝一份对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。其实只要递归下去，把那些属性的值仍然是对象的再次进入对象内部一 一进行复制即可。

**浅克隆**

  **浅克隆**之所以被称为**浅克隆**，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.

```js
// 浅克隆函数
function shallowClone(o) {
  const obj = {};
  for ( let i in o) {
    obj[i] = o[i];
  }
  return obj;
}
// 被克隆对象
const oldObj = {
  a: 1,
  b: [ 'e', 'f', 'g' ],
  c: { h: { i: 2 } }
};

const newObj = shallowClone(oldObj);
console.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }
console.log(oldObj.c.h === newObj.c.h); // true
```

 我们可以看到,很明显虽然`oldObj.c.h`被克隆了,但是它还与`oldObj.c.h`相等,这表明他们依然指向同一段堆内存,这就造成了如果对`newObj.c.h`进行修改,也会影响`oldObj.c.h`,这就不是一版好的克隆. 

 有一个**新的api`Object.assign()`**也可以实现浅复制. 

```js
let a = {
	age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

当然我们也可以通过展开运算符（…） 来解决

```js
let a = {
	age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
```



**深克隆**

1. JSON.parse方法： JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆. 

   ```js
   const newObj = JSON.parse(JSON.stringify(oldObj));
   ```

   确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.

   > 1.他无法实现对函数 、RegExp等特殊对象的克隆

   > 2.会抛弃对象的constructor,所有的构造函数会指向Object

   > 3.对象有循环引用,会报错

2. 构造一个深克隆函数

    由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。  这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略. 

   ```js
   /**
   * deep clone
   * @param  {[type]} parent object 需要进行克隆的对象
   * @return {[type]}        深克隆后的对象
   */
   const clone = parent => {
     // 维护两个储存循环引用的数组
     const parents = [];
     const children = [];
   
     const _clone = parent => {
       if (parent === null) return null;
       if (typeof parent !== 'object') return parent;
   
       let child, proto;
   
       if (isType(parent, 'Array')) {
         // 对数组做特殊处理
         child = [];
       } else if (isType(parent, 'RegExp')) {
         // 对正则对象做特殊处理
         child = new RegExp(parent.source, getRegExp(parent));
         if (parent.lastIndex) child.lastIndex = parent.lastIndex;
       } else if (isType(parent, 'Date')) {
         // 对Date对象做特殊处理
         child = new Date(parent.getTime());
       } else {
         // 处理对象原型
         proto = Object.getPrototypeOf(parent);
         // 利用Object.create切断原型链
         child = Object.create(proto);
       }
   
       // 处理循环引用
       const index = parents.indexOf(parent);
   
       if (index != -1) {
         // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象
         return children[index];
       }
       parents.push(parent);
       children.push(child);
   
       for (let i in parent) {
         // 递归
         child[i] = _clone(parent[i]);
       }
   
       return child;
     };
     return _clone(parent);
   };
   
   ```

   当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。 

3.  在生产环境中最好用`lodash`的深克隆实现. `_.clonedeep(value)`

### 67 js⾃定义事件

三要素： `document.createEvent()` `event.initEvent()` `element.dispatchEvent()`

```javascript
// (en:⾃定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加⾃定义事件，triggerEve
window.onload = function(){
	var demo = document.getElementById("demo");
	demo.addEvent("test",function(){console.log("handler1")});
	demo.addEvent("test",function(){console.log("handler2")});
	demo.onclick = function(){
		this.triggerEvent("test");
	}
}
Element.prototype.addEvent = function(en,fn){
	this.pools = this.pools || {};
	if(en in this.pools){
		this.pools[en].push(fn);
	}else{
		this.pools[en] = [];
		this.pools[en].push(fn);
	}
}
Element.prototype.triggerEvent = function(en){
	if(en in this.pools){
		var fns = this.pools[en];
		for(var i=0,il=fns.length;i<il;i++){
			fns[i]();
		}
	}else{
		return;
	}
}
```

### 68 typeof 与 instanceof 区别

**typeof 对于基本类型，除了 null 都可以显示正确的类型**。**对于 null 来说，虽然它是基本类型，但是会显示 object** ，这是⼀个存在很久了的 Bug

**typeof 对于对象，除了函数都会显示 object**，所以说 typeof 并不能准确判断变量到底是什么类型

**instanceof 可以正确的判断对象的类型**，因为**内部机制是通过判断对象的原型链中是不是能找到类型的 prototype**

如果我们想判断⼀个对象的正确类型，这时候可以考虑使⽤ instanceof ，因为内部机制是通过原型链来判断的

对于原始类型来说，你想直接通过 instanceof 来判断类型是不⾏的

#### 重写instanceof

```js
function instanceOf(instance, klass) {
  let proto = instance.__proto__;
  let prototype = klass.prototype;
  while (true) {
    if (proto === null) return false;
    if (proto === prototype) return true;
    proto = proto.__proto__;
  }
}
```

### 69 Proxy

Proxy 是 ES6 中新增的功能，可以⽤来**⾃定义对象中的操作**。 对目标对象加一层“拦截”（“代理”），外界对对象的访问、修改都必须先通过这层拦截层。因而它提供了一个机制可以对外界的访问进行过滤和改写。 

简单来说:`Proxy`对象就是可以让你去对JavaScript中的一切合法对象的基本操作进行自定义.然后用你自定义的操作去覆盖其对象的基本操作.也就是当一个对象去执行一个基本操作时,其执行的过程和结果是你自定义的,而不是对象的. 

 用法：`var proxy = new Proxy(p1,p2);` p1是要被代理的目标对象，p2是配置对象。 

```js
let p = new Proxy(target, handler);
// `target` 代表需要添加代理的对象
// `handler` ⽤来⾃定义对象中的操作
//可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听
let onWatch = (obj, setBind, getLogger) => {
	let handler = {
		get(target, property, receiver) {
		getLogger(target, property)
		return Reflect.get(target, property, receiver);
	},
	set(target, property, value, receiver) {
		setBind(value);
		return Reflect.set(target, property, value);
	}
};
return new Proxy(obj, handler);
};
let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
	value = v
}, (target, property) => {
	console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

我们就可以看到 Proxy 与 setter 和 getters 之间的区别。它们不仅在语法上有所不同（Proxy 更为冗长），而且在与原始对象的交互方面也有所不同。Proxy会创建一个**新对象**供你与之交互，而不是与原始对象进行交互，原始对象在使用 setter/getter 时会直接修改。与 setter/getter 相比，Proxy 可以让你做更多的事情。它们更快（声明后）并且更加灵活，使其成为状态管理等用例的理想解决方案。

Proxy 带来了很多可定制性，使开发人员可以控制 JS 的某些**元功能（meta-functionalities）**。所以它们并不是向后兼容的，并且没有任何完全兼容的 polyfill 的选项存在。

对于**代理模式`Proxy`的作用**主要体现在三个方面:

1、 拦截和监视外部对对象的访问

2、 降低函数或类的复杂度

3、 在复杂操作前对操作进行校验或对所需资源进行管理

Proxy实例可以作为其它对象的原型对象。支持13个拦截方法，列表如下：

```js
get set has ownKeys getOwnPropertyDescriptor defineProperty deleteProperty getPrototypeOf setPrototypeOf isExtensible preventExtensions apply construct
```

值得注意的是：**Proxy不是对目标对象透明的代理**——即使不做任何拦截的情况下无法保证代理对象与目标对象行为的完全一致。（主要原因在于代理时，目标对象内部的this会指向代理对象）

### 70 Reflect

与Proxy一样是ES6为**语言层面的用于操作对象提供的新API**，目前它所拥有的对象方法与Proxy对象一一对应

**引入目的**：

1.将Object对象上一些属于语言内部的方法放在Reflect上（目前都可以放）

2.修改Object对象上某些方法的返回值，使得更加合理化（健壮）

3.让Object对象的操作从命令式完全转化为函数式

### 71 Number.isNaN()

  **`Number.isNaN()`** 方法确定传递的值是否为 `NaN`，并且检查其类型是否为 `Number`。  在 JavaScript 中，`NaN` 最特殊的地方就是，我们不能使用相等运算符（`==`) 和 `===`）来判断一个值是否是 `NaN`，因为 `NaN == NaN` 和 `NaN === NaN` 都会返回 `false`。因此，必须要有一个判断值是否是 `NaN` 的方法。

**和全局函数 `isNaN()`相比，`Number.isNaN()` 不会自行将参数转换成数字**，只有在参数是值为 `NaN` 的数字时，才会返回 `true`。

```js
Number.isNaN(NaN);        // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0)       // true

// 下面这几个如果使用全局的 isNaN() 时，会返回 true。
Number.isNaN("NaN");      // false，字符串 "NaN" 不会被隐式转换成数字 NaN。
Number.isNaN(undefined);  // false
Number.isNaN({});         // false
Number.isNaN("blabla");   // false

// 下面的都返回 false
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(37);
Number.isNaN("37");
Number.isNaN("37.37");
Number.isNaN("");
Number.isNaN(" ");

Number.isNaN = Number.isNaN || function(value) {
    return typeof value === "number" && isNaN(value);
}
```

### 72 document.write和innerHTML的区别

1. write是DOM方法,向文档写入HTML表达式或JavaScript代码，可列出多个参数，参数被顺序添加到文档中 ；innerHTML是DOM属性,设置或返回调用元素开始结束标签之间的HTML元素。

2. 两者都可向页面输出内容,innerHTML比document.write更灵活。

   当文档加载时调用document.write直接向页面输出内容，文档加载结束后调用document.write输出内容会重写整个页面。通常按照两种的方式使用 write() 方法：一是在使用该方在文档中输出 HTML，二是在调用该方法的的窗口之外的窗口、框架中产生新文档（务必使用close关闭文档）。

   在读模式下，innerHTML属性返回与调用元素的所有子节点对应的HTML标记，在写模式下，innerHTML会根据指定的值创建新的DOM树替换调用元素原先的所有子节点。

3. 两者都可动态包含外部资源如JavaScript文件
   通过document.write插入`<script>`元素会自动执行其中的脚本；
   大多数浏览器中，通过innerHTML插入`<script>`元素并不会执行其中的脚本。 

## 四、webpack

WebPack 是⼀个**模块打包⼯具**，你可以使⽤WebPack 管理你的模块依赖，并编绎输出模块们所需的静态⽂件。它能够很好地管理、打包Web 开发中所⽤到的HTML 、Javascript 、CSS 以及各种静态⽂件（图⽚、字体等），让开发过程更加⾼效。对于不同类型的资源， webpack 有对应的模块加载器。webpack 模块打包器会分析模块间的依赖关系，最后 ⽣成了优化且合并后的静态资源

### 1 打包体积 优化思路

提取第三⽅库或通过引⽤外部⽂件的⽅式引⼊第三⽅库
代码压缩插件UglifyJsPlugin
服务器启⽤gzip压缩
按需加载资源⽂件 require.ensure
优化devtool 中的source-map
剥离css ⽂件，单独打包
去除不必要插件，通常就是开发环境与⽣产环境⽤同⼀套配置⽂件导致

### 2 打包效率

开发环境采⽤增量构建，启⽤热更新
开发环境不做⽆意义的⼯作如提取css 计算⽂件hash等
配置devtool
选择合适的loader
个别loader 开启cache 如babel-loader
第三⽅库采⽤引⼊⽅式
提取公共代码
优化构建时的搜索路径 指明需要构建⽬录及不需要构建⽬录
模块化引⼊需要的部分

### 3 Loader

loader 就是⼀个node 模块，它输出了⼀个函数。当某种资源需要⽤这个loader 转换时，这个函数会被调⽤。并且，这个函数可以通过提供给它的this 上下⽂访问Loader API 。 

reverse-txt-loader：

```javascript
// 定义
module.exports = function(src) {
	//src是原⽂件内容（abcde），下⾯对内容进⾏处理，这⾥是反转
	var result = src.split('').reverse().join('');
	//返回JavaScript源码，必须是String或者Buffer
	return `module.exports = '${result}'`;
}
//使⽤
{
	test: /\.txt$/,
	use: [
		{
			'./path/reverse-txt-loader'
		}
	]
},
```

### 4 说⼀下webpack的⼀些plugin，怎么使⽤webpack对项⽬进⾏优化

构建优化

- 减少编译体积 ContextReplacementPugin 、IgnorePlugin 、babel-pluginimport、babel-plugin-transform-runtime

- 并⾏编译 happypack 、thread-loader 、uglifyjsWebpackPlugin 开启并⾏
- 缓存 cache-loader 、hard-source-webpack-plugin 、uglifyjsWebpackPlugin 开启缓存、babel-loader 开启缓存
- 预编译 dllWebpackPlugin && DllReferencePlugin 、auto-dll-webapck-plugin

性能优化

- 减少编译体积 Tree-shaking 、Scope Hositing
- hash 缓存 webpack-md5-plugin
- 拆包 splitChunksPlugin 、import() 、require.ensure

**使⽤webpack对项⽬进⾏优化**

- 对于 Webpack4 ，打包项⽬使⽤ production 模式，这样会⾃动开启代码压缩
- 使⽤ ES6 模块来开启 tree shaking ，这个技术可以移除没有使⽤的代码
- 优化图⽚，对于⼩图可以使⽤ base64 的⽅式写⼊⽂件中
- 按照路由拆分代码，实现按需加载

### 5 如何实现⼀个插件

- 调⽤插件 apply 函数传⼊ compiler 对象
- 通过 compiler 对象监听事件

⽐如你想实现⼀个编译结束退出命令的插件

```javascript
apply (compiler) {
	const afterEmit = (compilation, cb) => {
		cb()
		setTimeout(function () {
			process.exit(0)
		}, 1000)
	}
	compiler.plugin('after-emit', afterEmit)
}
module.exports = BuildEndPlugin
```

### 6 webpack 和 gulp 区别

gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。

webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。



## 其他

### 1 babel原理

ES6、7 代码输⼊ -> babylon 进⾏解析 -> 得到AST （抽象语法树）->plugin ⽤b abel-traverse 对AST 树进⾏遍历转译 ->得到新的AST 树->⽤babel-generator 通过AST 树⽣成ES5 代码

- 本质就是编译器，当代码转为字符串⽣成 AST ，对 AST 进⾏转变最后再⽣成新的代码
- 分为三步：词法分析⽣成 Token ，语法分析⽣成 AST ，遍历 AST ，根据插件变换相应的节点，最后把 AST 转换为代码

### 2 TS和JS

- 语言层面：JavaScript和TypeScript都是ECMAScript（ECMA-262）的具体实现。

- 执行环境层面：浏览器引擎和Node.js都能够直接运行JavaScript，但无法直接运行TypeScript。

- 时序层面：TypeScript被真正执行前，会通过编译转换生成JavaScript，之后才能被解释执行。

   ![img](/../../../../Typora图库/Web前端/ts和js.png) 

​	*TypeScript*是一种由微软开发的自由和开源的编程语言。它**是*JavaScript*的一个超集**，兼容JavaScript，可以载入JS代码然后运行。它与JavaScript相比进步的地方包括：**加入注释，让编译器理解所支持的对象和函数，编译器会移除注释，不会增加开销**。 而JavaScript只是一个脚本语言，并非设计用于开发大型 Web 应用，*JavaScript* 没有提供**类和模块**的概念，而TypeScript扩展实现了这些特性。它扩展了 *JavaScript* 的语法，因此现有的JavaScript代码可与其代码一起工作无需任何修改，它**通过类型注解提供编译时的静态类型检查**。***TypeScript* 最大的特点就是类型化**，因此才叫做TypeScript。比起弱类型的JavaScript，类型化的TypeScript显得更加容易维护。

![1600164633053](/../../../../Typora图库/Web前端/ts和js区别.png)

#### 接口

 接口：用来建立某种代码约定，使得其他开发者在调用程序或创建类时必须遵循接口的某种代码约定；  它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。 

 命名一般使用大驼峰法。 

```js
interface Person {
    readonly id: number;//只读
    name: string;
    age?: number;//可选
    [propName: string]: any;//可索引属性，共有支持两种索引签名：字符串和数字
    [index: number]: string;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};
```

**ts中interface与class的区别：**

interface:接口只声明成员方法，不做实现。

class:类声明并实现方法。

也就是说：interface只是定义了这个接口会有什么，但是没有告诉你具体是什么。

**extends 与 implement的区别：**

（1）extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承。

（2）java中**不支持多重继承，但是可以用接口来实现**，这样就要用到implements，继承只能继承一个类，但**implements可以实现多个接口**，用逗号分开就行了

` class A extends B implements C,D,E`

implements就是实现的意思, 顾名思义它实现一个已经定义好的接口中的方法！

#### 泛型

**泛型（Generics）**是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 

**any和泛型的区别：**

　　使用any：**使用`any`类型会导致这个函数可以接收任何类型的`arg`参数，**这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。

```js
function identity(arg: any): any {
    return arg;
}
```

　　给identity添加了类型变量`T`。 **`T`帮助我们捕获用户传入的类型**（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了 `T`当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 参数化的类型，一般用来限制集合的内容；指定只能放某个类型的元素 

```js
function identity<T>(arg: T): T {
    return arg;
}
```

　　注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看`myString`的值，然后把`T`设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。

#### 类

属性和方法

使用 class 定义类，使用 constructor 定义构造函数。
通过 new 生成新实例的时候，会自动调用构造函数。

```js
class Animal {
    constructor(name) {
        this.name = name;
    }
    sayHi() {
        return `My name is ${this.name}`;
    }
    eat() {
        return 'happy';
    }
}

let a = new Animal('Jack');
console.log(a.sayHi()); // My name is Jack
```

 使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。  

父类包含了一个构造函数，它必须调用 super()，它会执行子类的构造函数。 而且，在构造函数里访问 this的属性之前，我们一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 

```js
class Cat extends Animal {
    constructor(name) {
        super(name);      // 调用父类的 constructor(name)
        console.log(this.name);
    }
    // 方法重写
    sayHi() {             
        return 'Meow, ' + super.sayHi();    // 调用父类的 sayHi()
    }
}

let c = new Cat('Tom');   // Tom
c.sayHi();                // Meow, My name is Tom
c.eat();                  //'happy'
```

 使用 getter 和 setter 可以改变属性的赋值和读取行为 

 使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用 

 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 

 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 

 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 .**使用 private 修饰的属性或方法，在子类中也是不允许访问的** 

 使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 

 abstract 用于定义抽象类和其中的抽象方法。 抽象类是不允许被实例化的 , 抽象类中的抽象方法必须被子类实现 .  **抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。** 

 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 

#### ts转js方法



### 3 Java和js区别

相同之处包括：

- 它们的语法和 C 语言都很相似；
- 它们都是**面向对象**的（虽然实现的方式略有不同）；
- JavaScript 在设计时参照了 Java 的命名规则；

Java是一门**面向对象编程语言**，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。

JavaScript是一种**直译式脚本语言**，是一种**动态类型、弱类型、基于原型**的语言。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。

**Java和JavaScript的区别**

- Java是面向对象的语言，JavaScript是脚本语言，是基于对象和事件驱动的语言。
- Java的源代码在执行之前必须经过编译，而JavaScript的代码不需要，可以由浏览器直接解释执行。
- Java变量在使用之前必须声明，而JavaScript不需要。
- Java和JavaScript代码的格式不一样；Java的语法规则比JavaScript要严格的多，功能要强大的多。
- JavaScript是动态类型语言；而Java是静态类型语言。java在定义了一个数组的长度以后就不能再改变了，但是javascript却可以。
- java主要在服务端运行；javascript主要运行在客户端浏览器中。
- JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的。

### 4 ⾯向对象编程（OOP），⾯向过程编程，函数式编程（FP）

- ⾯向过程就是**分析出解决问题所需要的步骤**，然后⽤函数把这些步骤⼀步⼀步实现，使⽤的时候⼀个⼀个依次调⽤就可以了
  -  面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤 
  -  基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：**任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行**，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。 
  -  若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。 
  - 优点：将复杂的问题流程化，进而简单化
  - 缺点：程序的可扩展性极差，因为**一套流水线或者流程就是用来解决一个问题**，就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。
  - 应用场景：面向过程的程序设计一般**用于那些功能一旦实现之后就很少需要改变的场景**， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。
- ⾯向对象是**把构成问题事务分解成各个对象**，建⽴对象的⽬的不是为了完成⼀个步骤，⽽是为了**描叙某个事物在整个解决问题的步骤中的⾏为**
  - ⾯向对象是以**功能**来划分问题，⽽不是步骤
  -  将整个任务封装成一个大的类，在这个类里面详细分解执行每个步骤，只需要执行类就可以完成任务 
- 函数式： 将计算机的运算视为数学意义上的运算，比起面向过程，函数式**更加注重的是执行结果而非执行的过程** 。 将编程分成N件事情，分配每件事情为一个函数，然后要按步骤执行函数完成。
  -  Python提供了很多函数式编程好的特性，如lambda，map，reduce，filter 

总结

- 面向过程：需要你自己去一步一步的执行

- 面向函数：也是需要自己去一步一步执行，只是执行的过程已经提前设定好了

- 面向对象：让机器人去执行 ，因为已经设定好执行步骤，你只需等待结果就好了

因此，在我看来，面向过程和对象，是自己在干活，面向对象，是先创造机器人，然后让机器人去干活。

站在计算机程序角度来讲，面向过程（函数）和面向对象的本质理解为：

- 面向过程（函数）的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

- 面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

总的来说：面向对象是将事物高度抽象化，面向对象必须先建立抽象模型，之后直接使用模型就行了；面向过程是一种自顶向下的编程!

![img](/../../../../Typora图库/Web前端/面向编程.png) 

### 5 类型语言

 ![img](/../../../../Typora图库/Web前端/类型语言.png) 

- 动态类型语言：在运行期进行类型检查的语言，也就是在编写代码的时候可以不指定变量的数据类型，比如Python和Ruby

- 静态类型语言：它的数据类型是在编译期进行检查的，也就是说变量在使用前要声明变量的数据类型，这样的好处是把类型检查放在编译期，提前检查可能出现的类型错误，典型代表C/C++和Java

- 强类型语言，一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。举个例子：如果你定义了一个double类型变量a,不经过强制类型转换那么程序int b = a无法通过编译。典型代表是Java。

- 弱类型语言：它与强类型语言定义相反,允许编译器进行隐式的类型转换，典型代表C/C++。

### 6 ES6

#### ES和JS

 1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。 

 ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现 

**JavaScript由三部分组成：**

ES 作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象 

 DOM（文档对象模型）把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。 

 BOM （浏览器对象模型）支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 

#### ES2015

1. **strict模式**

严格模式，限制一些用法，'use strict';

2. **Array增加方法**

增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法

PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now

3. **Object方法**

Object.getPrototypeOf

Object.create

Object.getOwnPropertyNames

Object.defineProperty

Object.getOwnPropertyDescriptor

Object.defineProperties

Object.keys

Object.preventExtensions / Object.isExtensible

Object.seal / Object.isSealed

Object.freeze / Object.isFrozen

PS：只讲有什么，不讲是什么。

#### ES6 新特性

- 内置对象扩展

  - String扩展

    - 新增模板字符串（为JavaScript 提供了简单的字符串插值功能）

      - 基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
      - ES6反引号(``)直接搞定；

    - includes(str, [position]) 返回布尔值,是否找到参数字符串

      startsWidth(str, [position]) 返回布尔值,表示参数字符串是否在原字符串的头部或指定位置

      endsWith(str, [position]) 表示参数字符串是否在原字符串的尾部或指定位置

      repeat() 返回一个新字符串,表示将原字符串重复n次

  - Array扩展

    - 扩展运算符(...可以把数组中的每一项展开)
    -  Array.from() 
    -  数组实例find() findIndex() 
    -  数组实例includes() 
    -  fill() 
    -  Array.of() 
    -  Set() 

  - for-of 和for-in

    -  for...of 用于遍历一个迭代器，如数组： 

      ```js
      let letter = ['a', 'b', 'c'];
      letter.size = 3;
      for (let letter of letters) {
        console.log(letter);
      }
      // 结果: a, b, c
      ```

    -  for...in 用来遍历对象中的属性 

      ```js
      let stu = ['Sam', '22', '男'];
      stu.size = 3;
      for (let stu in stus) {
        console.log(stu);
      }
      // 结果: Sam, 22, 男
      ```

- 函数

  - 箭头函数

    - 箭头函数内部的`this`指向外部作用域中的`this`,箭头函数没有自己的`this`
    - 箭头函数中内部没有`arguments`
    - 箭头函数不能作为构造函数

  - 不定参数：Spread / Rest 操作符

    -  Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。 

    -  当被用于迭代器中时，它是一个 Spread 操作符： 

      ```js
      function foo(x,y,z) {
        console.log(x,y,z);
      }
       
      let arr = [1,2,3];
      foo(...arr); // 1 2 3
      ```

    -  当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符： 

      ```js
      function foo(...args) {
        console.log(args);
      }
      foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
      ```

  -  函数参数的默认值 

    ```js
    // ES5 中给参数设置默认值的变通做法
    function fn(x, y) {
        y = y || 'world';
        console.log(x, y);
    }
    fn(1)
    // ES6 中给函数设置默认值
    function fn(x, y = 'world') {
        console.log(x, y);
    }
    fn(2)
    fn(2,3)
    ```

- 异步编程Promise、Generator和Async

- 元编程相关Proxy和Reflect

- 增加了let 和const 命令，⽤来声明变量。

- 增加了块级作⽤域（let 命令实际上就增加了块级作⽤域）。

- 引⼊module 模块的概念

  - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
  -  CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 

- 二进制和八进制字面量

  -  通过在数字前面添加 0o 或者0O 即可将其转换为八进制值： 

    ```js
    let oValue = 0o10;
    console.log(oValue); // 8
     
    let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`
    console.log(bValue); // 2
    ```

- 对象和数组解构

  ```js
  // 对象
  const student = {
      name: 'Sam',
      age: 22,
      sex: '男'
  }
  // 数组
  // const student = ['Sam', 22, '男'];
  
  // ES5；
  const name = student.name;
  const age = student.age;
  const sex = student.sex;
  console.log(name + ' --- ' + age + ' --- ' + sex);
  
  // ES6
  const { name, age, sex } = student;
  console.log(name + ' --- ' + age + ' --- ' + sex);
  ```

- 类

  - 对象超类： 允许在对象中使用 super 方法

    ```js
    var parent = {
      foo() {
        console.log("Hello from the Parent");
      }
    }
     
    var child = {
      foo() {
        super.foo();
        console.log("Hello from the Child");
      }
    }
     
    Object.setPrototypeOf(child, parent);
    child.foo(); // Hello from the Parent
                 // Hello from the Child
    ```

  -  class之间可以通过extends关键字实现继承, 

  - ES6怎么写class：在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。class 的本质是 function。它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

    ```javascript
    //常规写法
    function Person(name,age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.sayInfo = function () {
        console.log(`${this.name}是${this.age}岁`)
    }
    const liLei = new Person('LiLei',20)
    liLei.sayInfo()
    //LiLei是20岁
    
    //类
    class Person{ //定义了一个名字为Person的类
        constructor(name,age){ //constructor是一个构造方法，用来接收参数
            this.name = name;  //this代表的是实例对象
            this.age = age;
        }
        sayInfo(){
            console.log(`${this.name}是${this.age}岁`)
        }
    }
    const liLei = new Person('LiLei',21)
    liLei.sayInfo()
    ```

### 7 MVVM

MVVM（Model–View–Viewmodel）是一种软件架构模式。

MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。

 简单的讲，MVVM是MVC的改进版。 **MVC**中的**M**就是单纯的从网络获取回来的数据模型，**V**指的我们的视图界面，而**C**就是我们的ViewController。

在其中，ViewController负责View和Model之间调度，View发生交互事件会通过target-action或者delegate方式回调给ViewController，与此同时ViewController还要承担把Model通过KVO、Notification方式传来的数据传输给View用于展示的责任。 **随着业务越来越复杂，视图交互越复杂，导致Controller越来越臃肿。**

所以为了解决这个问题，MVVM就闪亮登场了。他把View和Contrller都放在了View层（相当于把Controller一部分逻辑抽离了出来），Model层依然是服务端返回的数据模型。**而ViewModel充当了一个UI适配器的角色，也就是说View中每个UI元素都应该在ViewModel找到与之对应的属性。除此之外，从Controller抽离出来的与UI有关的逻辑都放在了ViewModel中，这样就减轻了Controller的负担。**

 ![img](/../../../../Typora图库/Web前端/MVVM.png) 

从以上的架构图中，我们可以很清晰的梳理出各自的分工。

- **View层**：视图展示。包含UIView以及UIViewController，View层是可以持有ViewModel的。
- **ViewModel层**：视图适配器。暴露属性与View元素显示内容或者元素状态一一对应。一般情况下ViewModel暴露的属性建议是readOnly的，至于为什么，我们在实战中会去解释。还有一点，ViewModel层是可以持有Model的。
- **Model层**：数据模型与持久化抽象模型。数据模型很好理解，就是从服务器拉回来的JSON数据。而持久化抽象模型暂时放在Model层，是因为MVVM诞生之初就没有对这块进行很细致的描述。按照经验，我们通常把数据库、文件操作封装成Model，并对外提供操作接口。（有些公司把数据存取操作单拎出来一层，称之为**DataAdapter层**，所以在业内会有很多MVVM的变种，但其本质上都是MVVM）。
- **Binder**：MVVM的灵魂。可惜在MVVM这几个英文单词中并没有它的一席之地，它的最主要作用是在View和ViewModel之间做了双向数据绑定。如果MVVM没有Binder，那么它与MVC的差异不是很大。

我们发现，正是因为View、ViewModel以及Model间的清晰的持有关系，所以在三个模块间的数据流转有了很好的控制。

# 高阶部分

## React专题

### 1 React 中 keys 的作⽤是什么？

Keys 是 React ⽤于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯⼀性。**在 React Diff 算法中React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动⽽来的元素，从⽽减少不必要的元素重渲染**。此外React 还需要借助 Key 值来判断元素与本地状态的关联关系

### 2 传⼊ setState 函数的第⼆个参数的作⽤是什么？

该函数会在setState 函数调⽤完成并且组件开始重渲染的时候被调⽤，我们可以**⽤该函数来监听渲染是否完成**

```javascript
this.setState(
	{ username: 'tylermcginnis33' },
	() => console.log('setState has finished and the component has re-rendere
)
this.setState((prevState, props) => {
	return {
		streak: prevState.streak + props.count
	}
})
```

比如我们需要在设置状态值后立即访问它

```js
   handleChange = count => {
      this.setState({ count });
      this.props.callback(this.state.count); // Old state value
    };
    
   handleChange = count => {
      this.setState({ count }, () => {
        this.props.callback(this.state.count); // Updated state value
      });
    };
```



### 3 React 中 refs 的作⽤是什么

- Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄
- 可以为元素添加ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第⼀个参数返回

**应该使用 Refs 的情况**

以下是应该使用 refs 的情况：

- 需要管理焦点、选择文本或媒体播放时
- 触发式动画
- 与第三方 DOM 库集成

### 4 React 函数组件和类组件的区别

函数组件和类组件当然是有区别的，而且**函数组件的性能比类组件的性能要高**，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。

 两者最明显的不同就是在语法上，函数组件是一个纯函数，它接收一个`props`对象返回一个`react`元素。而类组件需要去继承`React.Component`并且创建`render`函数返回`react`元素，这将会要更多的代码，虽然它们实现的效果相同。 

函数组件没有this,没有生命周期，没有状态state；类组件有this,有生命周期，有状态state。

 函数式组件经常被忽略的点：**函数式组件捕获了渲染所用的值。** 



### 5 

### 6 如何告诉 React 它应该编译⽣产环境版

通常情况下我们会使⽤ **Webpack 的 DefinePlugin ⽅法来将 NODE_ENV变量值设置为 production** 。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的⼤⼩， React 使⽤了 Uglify插件来移除⽣产环境下不必要的注释等信息

### 7 概述下 React 中的事件处理逻辑

为了解决跨浏览器兼容性问题， React 会**将浏览器原⽣事件（ Browser Native Event ）封装为合成事件（ SyntheticEvent ）传⼊设置的事件处理器中**。这⾥的合成事件提供了与原⽣事件相同的接⼝，不过它们屏蔽了底层浏览器的细节差异，保证了⾏为的⼀致性。另外有意思的是， React 并没有直接将事件附着到⼦元素上，⽽是**以单⼀事件监听器的⽅式将所有的事件发送到顶层进⾏处理**。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的⽬的

### 8 Flux

 Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。 

Flux 的最⼤特点，就是数据的"单向流动"。

- ⽤户访问 View
- View 发出⽤户的 Action
- Dispatcher 收到Action ，要求 Store 进⾏相应的更新
- Store 更新后，发出⼀个"change" 事件
- View 收到"change" 事件后，更新⻚⾯

### 9 Redux中间件

 Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。 

**Redux遵循的三个原则是什么？**

1. ***单一事实来源：***整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。
2. ***状态是只读的：***改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。
3. ***使用纯函数进行更改：***为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。

 Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。 

Redux 由以下组件组成：

1. **Action** – 这是一个用来描述发生了什么事情的对象。
2. **Reducer** – 这是一个确定状态将如何变化的地方。
3. **Store** – 整个程序的状态/对象树保存在Store中。
4. **View** – 只显示 Store 提供的数据。

中间件提供第三⽅插件的模式，**⾃定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流**，实现如异步action ， action 过滤，⽇志输出，异常报告等功能

- redux-logger ：提供⽇志输出
- redux-thunk ：处理异步操作
- redux-promise ：处理异步操作， actionCreator 的返回值是promise

优点：

**结果的可预测性 -**  由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。

**可维护性 -**  代码变得更容易维护，具有可预测的结果和严格的结构。

**服务器端渲染 -**  你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。

**开发人员工具 -**  从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。

**社区和生态系统 -**  Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。

**易于测试 -**  Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。

**组织 -**  Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。



缺点：

- ⼀个组件所需要的数据，必须由⽗组件传过来，⽽不能像flux 中直接从store 取。
- 当⼀个组件相关数据更新时，即使⽗组件不需要⽤到这个组件，⽗组件还是会重新render ，可能会有效率影响，或者需要写复杂的shouldComponentUpdate 进⾏判断。

#### Reducer

Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。

#### Store

Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。

#### **Redux与Flux有何不同？**

![1600172169457](/../../../../Typora图库/Web前端/redux和flux.png)

### 10 React为什么需要Hook

对于React或者其它的基于Component的框架来说，页面是由一个个UI组件构成的。独立的组件可以在同一个项目中甚至不同项目中进行复用，这十分有利于前端开发效率的提高。可是除了UI层面上的复用，一些**状态相关**（stateful）或者**副作用相关**（side effect）的**非UI逻辑**在不同组件之间复用起来却十分困难。

使用高阶组件来封装组件的这些逻辑其实会有以下的问题：

- **高阶组件的开发对开发者不友好**：开发者（特别是初级开发者）需要花费一段时间才能搞懂其中的原理并且适应它的写法。
- **高阶组件之间组合性差**：由于要为组件添加不同的功能，我们要为同一个组件嵌套多个高阶组件。这种嵌套写法的高阶组件可能会导致很多问题，其中一个就是**props丢失**的问题。如果你使用的高阶组件都是自己写的话还好，因为调试和修改起来都比较简单，如果你使用的是第三方的库的话就很头痛了。
- **容易发生wrapper hell**：这个问题在上面嵌套多重高阶组件的时候就会出现，具体会造成我们在React Devtools查看和调试某个组件的时候十分困难。 ![img](/../../../../Typora图库/Web前端/wrapperhell.png) 

和高阶组件类似，renderProps也会存在同样的问题。基于这些原因，React需要一个**新的用来复用组件之间非UI逻辑的方法**，所以Hook就这么诞生了。总的来说，Hook相对于高阶组件和renderProps在复用代码逻辑方面有以下的优势：

- **写法简单**：每一个Hook都是一个函数，因此它的写法十分简单，而且开发者更容易理解。
- **组合简单**：Hook组合起来十分简单，组件只需要同时使用多个hook就可以使用到它们所有的功能。
- **容易扩展**：Hook具有很高的可扩展性，你可以通过自定义Hook来扩展某个Hook的功能。
- **没有wrapper hell**：Hook不会改变组件的层级结构，也就不会有wrapper hell问题的产生。

除了用来替代难用的HOC和renderProps来解决组件非UI逻辑复用的问题之外，其实Hook还解决了以下这些问题。

**组件的生命周期函数不适合side effect逻辑的管理**

**我们可能会在组件的同一个生命周期函数放置很多互不关联的side effect逻辑**。举个例子，如果我们想在用户查看某个用户的详情页面的时候将浏览器当前标签页的title改为当前用户名的话，就需要在组件的componentDidMount生命周期函数里面添加`document.title = this.props.userName`这段代码，可是这段代码和之前订阅用户状态的逻辑是互不关联的，而且随着组件的功能变得越来越复杂，这些不关联而又放在一起的代码只会变得越来越多，于是你的组件逐渐变得难以测试。由此可见Class Component的生命周期函数并不适合用来管理组件的side effect逻辑。

那么这个问题Hook又是如何解决的呢？由于每个Hook都是一个函数，所以你可以**将和某个side effect相关的逻辑都放在同一个函数（Hook）里面**（useEffect Hook）。这种做法有很多好处，首先关联的代码都放在一起，可以十分方便代码的维护，其次实现了某个side effect的Hook还可以被不同的组件进行复用来提高开发效率。

**不友好的Class Component**

由于JS本身的原因，在Class Component中你要手动为注册的event listener绑定this,**每个事件监听函数都要手动绑定this的酸爽感觉**，乏味而且容易引发bug.

除了对开发者不友好，Class Component对机器也很不友好。例如Class Component的生命周期函数很难被minified。其次，Class Component的存在可能会阻碍React后面的发展。新的理念 Compiler as Framework的兴起，一些将框架的概念放到了编译时以去除production code里面的runtime代码来加快应用的首屏加载速度，这个方案已经开始被逐渐采纳了，而且未来有可能会成为潮流。因此React要想得到进一步的发展的话，就必须让开发者更多地使用Function Component而不是Class Component。

Hook出来后解决了Function Component没有状态管理和生命周期函数等功能的问题，因为开发者可以使用**useState** Hook来在Function Component使用**state**以及**useEffect** Hook来实现一些和**生命周期函数类似的功能**。最重要的是，React将所有复杂的实现都封装在框架里面了，开发者无需学习函数式编程和响应式编程的概念也可以很好地使用Hook来进行开发。



我主要论述了React为啥要有Hook，总的来说是以下三个原因：

- Component非UI逻辑复用困难。
- 组件的生命周期函数不适合side effect逻辑的管理。
- 不友好的Class Component。

### 11 react组件的划分业务组件技术组件？

- 根据组件的职责通常把组件分为UI组件和容器组件。
- UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。
- 两者通过React-Redux 提供connect ⽅法联系起来

### 12 react⽣命周期函数

 ![img](/../../../../Typora图库/Web前端/react生命周期.png) 

**React生命周期可以分为两条执行流程：**

1、初始化：初始进入页面 → constructor → componentWillMount → render → componentDidMount → componentWillUnmount；

2、更新：setState → componentWillReceiveProps → shouldComponentUpdate → componentWillUpdate → render → componentDidUpdate → componentWillUnmount。

 ![img](/../../../../Typora图库/Web前端/react生命周期初始化.png) 

1、首先，进入页面，会初始化页面数据(state, props, context等…)，等待备用；

2、然后，设置**生命状态**为：MOUNTING；

3、接下来，在componentWillMount中，合并state/callback，***生命状态*** 会被重置为 null，之后是渲染页面(即执行render)；

> **setState**操作，只是把state合并到初始化状态中，而根本不会触发render **；**在这里更新state，就等同于直接写在this.state中，所以，在此生命周期中的setState根本***没有意义***；

4、最后，渲染完以后，执行componentDidMount，这里使用setState即会正常触发重新渲染了，更新state。(接下来，就是**更新流程**了！！)

 ![img](/../../../../Typora图库/Web前端/react生命周期更新.png) 

1、首先，react会比较前后元素、状态等是否不同，如果不同则正式发起更新；

2、然后，***生命状态*** 被设置为RECEIVE_PROPS(注意：此时生命周期中，setState不会触发更新，而是会做其他处理)；

3、接下来，componentWillReceiveProps中的setState就不会执行更新，而是合并挂载起来，等待render时统一更新；到这里，**生命状态** 会重置为null；然后shouldComponentUpdate中会判断是否更新；之后是componentWillUpdate。

> **敲黑板了！！！！**  shouldComponentUpdate和componentWillUpdate执行的时候，**生命状态** 已经被重置为null，在它们里面的setState会触发更新，那么在其间使用呢？会造成什么？答案就是：在一个更新周期还没有render之前，再次发起updateComponent，直接导致递归更新，死循环！相信我！等待你的，就是浏览器崩溃！！所以在他们里面🚫禁止🚫使用setState。

4、最后，渲染页面；再执行componentDidUpdate

> 它里面执行setState，会触发更新，不同的是render完成之后再发起的reRender。虽然这儿区别于上面两个生命周期中使用的情况，但是会一遍一遍的更新，这肯定也是不合理的，所以需要有条件的使用setState。

**最后呢**，简单介绍一下，退出页面的流程。此流程中， 首先**生命状态**也会被赋予值为UNMOUNTING， 然后执行componentWillUnmount，最后**生命状态**重置为null，做卸载页面组件和状态等处理。

> 在componentWillUnmount中使用setState，因为等待的是页面卸载，所以改变state是没有意义的。

#### 生命周期执行顺序

- 只执行一次： constructor、componentWillMount、componentDidMount

- 执行多次：render 、子组件的componentWillReceiveProps、componentWillUpdate、componentDidUpdate

- 有条件的执行：componentWillUnmount（页面离开，组件销毁时）

- 不执行的：根组件（ReactDOM.render在DOM上的组件）的componentWillReceiveProps（因为没有父组件给传递props）

componentWillMount 在渲染前调用,在客户端也在服务端。

componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。
componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。

shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 
可以在你确认不需要更新组件时使用。

componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。

componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。

componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。

#### **生命周期中setState的使用情况：**

- 无意义使用：componentWillMount，componentWillUnmount；

- 有条件使用：componentDidUpdate；

- 禁止使用：componentWillUpdate，shouldComponentUpdate；

- 正常使用：componentWIllReceiveProps，componentDidMount。

**生命周期中setState是否触发更新：**

- componentWillMount和componentWillReceiveProps中，setState会被react内部处理，而不触发render；

- 其他生命周期均正常出发更新渲染。

#### 生命周期中渲染优化

 Reac更新视图必须触发Render，但是这样往往又很影响性能（因为有dom改动），React利用特有的diff算法采用虚拟DOM，是的性能有了很大的提升。 

触发Render的条件：

- 首次加载组件
- 使用了setState（更新了Props）
- Props更新了(父级传给子级的值改变了)

很多情况下我们可以直接避免很多2、3情况导致的性能问题。

**shouldComponentUpdate** 这个⽅法⽤来判断是否需要调⽤render⽅法重新描绘dom。 是在render渲染之前触发的,只要在这里加以判断就可以有效阻止 **'无用'的render** 触发。 因为dom的描绘⾮常消耗性能，如果我们能在shouldComponentUpdate⽅法中能够写出更优化的dom diff 算法，可以极⼤的提⾼性能

**componentWillReceiveProps**

1、componentWillReceiveProps函数有一个参数nextProps，它是一个 { 对象 } ，它是update时候（下一次）父组件传递过来的props。

2、有些生命周期函数只执行一次，而有的执行多次，其中componentWillReceiveProps执行多次，而constructor等执行一次。

3、还需知道在子组件中每次传递过来的this.props对象其实和componentWillReceiveProps的nextProps是一样的，都是最新的。

4、componentWillReceiveProps生命周期是在更新子组件最先执行的，优先于compoentWillUpdate，更优先于render。

5、render函数里不能使用setState()，否则会造成死循环。

大部分情况下 componentWillReceiveProps 生命周期函数是没用的，即可以略去不写，但是在constructor函数中初始化了某个state，必须用 componentWillReceiveProps 来更新state，不可省去，否则render中的state将得不到更新。
同时如果您想在子组件监听watch值变化做处理，也可以用到componentWillReceiveProps

使用componentWillReceiveProps的时候，<u>不要去向上分发</u>，调用父组件的相关setState方法，否则会成为死循环。

#### 在⽣命周期中的哪⼀步异步获取数据

组件挂载时有关的生命周期有以下几个:

- constructor()
- componentWillMount()
- render()
- componentDidMount()

上面这些方法的调用是有次序的，由上而下，也就是当说如果你要获取外部数据并加载到组件上，**只能在组件"已经"挂载到真实的网页上才能作这事情**，其它情况你是加载不到组件的。

<u>componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重渲染。</u>所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。

constructor被调用是在组件准备要挂载的最一开始，所以此时组件尚未挂载到网页上。

componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重渲染，所以它<u>一般不会用来作加载数据之用</u>，它也很少被使用到。

一般的从后台(服务器)获取的数据，都会与组件上要用的数据加载有关，所以都在componentDidMount方法里面作。虽然与组件上的数据无关的加载，也可以在constructor里作，但**constructor是作组件state初绐化工作**，并不是设计来作加载数据这工作的，所以**所有有副作用的代码都会集中在componentDidMount方法里**。



我们应当**将异步获取数据放到 componentDidMount 函数中执⾏**，主要原因有下:

- React 下⼀代调和算法 Fiber 会通过开始或停⽌渲染的⽅式优化应⽤性能，其会影响到componentWillMount 的触发次数。对于 componentWillMount 这个⽣命周期函数的调⽤次数会变得不确定， React 可能会多次频繁调⽤ componentWillMount 。如果我们将异步获取数据放到 componentWillMount 函数中，那么显⽽易⻅其会被触发多次，⾃然也就不是好的选择。
- 如果我们将异步获取数据放置在⽣命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调⽤了setState 函数将数据添加到组件状态中，对于未挂载的组件则会报错。⽽在componentDidMount 函数中进⾏异步获取数据则能有效避免这个问题

#### 生命周期中获取数据

React 类组件的`2`个生命周期方法:

1.  `componentDidMount()`：组件挂载后执行
2.  `componentDidUpdate(prevProps)`:当 `props` 或 `state` 改变时执行

使用hook的话用`useEffect`。

#### 生命周期方法要如何对应到 Hook？

- `constructor`：**函数组件不需要构造函数。你可以通过调用 `useState`来初始化 state。**如果计算的代价比较昂贵，你可以传一个函数给 `useState`。
- `getDerivedStateFromProps`：改为 在渲染时安排一次更新。
- `shouldComponentUpdate`：**详见 `React.memo`.**
- `render`：这是**函数组件体本身**。
- `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`：**`useEffect` Hook**可以表达所有这些的组合。
- `getSnapshotBeforeUpdate`，`componentDidCatch` 以及 `getDerivedStateFromError`：目前还没有这些方法的 Hook 等价写法，但很快会被添加。

### 13 React性能优化

React 性能优化的理念的主要方向就是这两个：

1. 减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。
2. 减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。

 列举出可有效提升react性能的几种方法 ：

1. 使用**React.Memo**来缓存组件、

    父组件的每次状态更新，都会导致子组件重新渲染，即使传入子组件的状态没有变化，为了减少重复渲染，我们可以使用React.memo来缓存组件，这样只有当传入组件的状态值发生变化时才会重新渲染。如果传入相同的值，则返回缓存的组件。 

2. 使用**useMemo**缓存大量的计算

    有时渲染是不可避免的，但如果您的组件是一个功能组件，重新渲染会导致每次都调用大型计算函数，这是非常消耗性能的，我们可以使用新的useMemo钩子来“记忆”这个计算函数的计算结果。这样只有传入的参数发生变化后，该计算函数才会重新调用计算新的结果。 

3. 使用**React.PureComponent , shouldComponentUpdate**

   父组件状态的每次更新，都会导致子组件的重新渲染，即使是传入相同props。但是这里的重新渲染不是说会更新DOM,而是每次都会调用diif算法来判断是否需要更新DOM。这对于大型组件例如组件树来说是非常消耗性能的。
   在这里我们就可以使用React.PureComponent , shouldComponentUpdate生命周期来确保只有当组件props状态改变时才会重新渲染。

   PureComponent会进行**浅比较**来判断组件是否应该重新渲染，对于传入的基本类型props，只要值相同，浅比较就会认为相同，**对于传入的引用类型props，浅比较只会认为传入的props是不是同一个引用**，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的props。
   需要注意的是在对于**那些可以忽略渲染时间的组件或者是状态一直变化的组件则要谨慎使用PureComponent，因为进行浅比较也会花费时间**，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用memo来包裹小组件，也可以提升性能。

4. **避免使用内联对象**

   使用内联对象时，react会在每次渲染时重新创建对此对象的引用，这会导致接收此对象的组件将其视为不同的对象,因此，该组件对于prop的浅层比较始终返回false,导致组件一直重新渲染。 

   许多人使用的内联样式的间接引用，就会使组件重新渲染，可能会导致性能问题。为了解决这个问题，我们可以保证该对象只初始化一次，指向相同引用。另外一种情况是传递一个对象，同样会在渲染时创建不同的引用，也有可能导致性能问题，我们可以利用ES6扩展运算符将传递的对象解构。这样组件接收到的便是基本类型的props，组件通过浅层比较发现接受的prop没有变化，则不会重新渲染。

5. **避免使用匿名函数**

    虽然匿名函数是传递函数的好方法（特别是需要用另一个prop作为参数调用的函数），但它们在每次渲染上都有不同的引用。  为了保持对作为prop传递给React组件的函数的相同引用，您可以将其声明为类方法（如果您使用的是基于类的组件）或使用useCallback钩子来帮助您保持相同的引用（如果您使用功能组件）。 

6. **懒加载**，延迟加载不是立即需要的组件

   可以使用新的React.Lazy和React.Suspense轻松完成。

7. **调整CSS而不是强制组件加载和卸载**

   渲染成本很高，尤其是在需要更改DOM时。例如想要一次只能看到一个项目时，你可能想要卸载不可见的组件，并在它变得可见时将其重新加载。如果加载/卸载的组件“很重”，则此操作可能非常消耗性能并可能导致延迟。在这些情况下，最好通过CSS隐藏它，同时将内容保存到DOM。 

   另外一点，将不透明度调整为0对浏览器的成本消耗几乎为0（因为它不会导致重排），并且应尽可能优先于更改visibility 和 display。 

8. 使用**React.Fragment**避免添加额外的DOM

### 14 虚拟dom

虚拟dom 相当于**在js 和真实dom 中间加了⼀个缓存**，利⽤dom diff 算法避免了没有必要的dom 操作，从⽽提⾼性能

具体实现步骤如下

- ⽤ JavaScript 对象结构表示 DOM 树的结构；然后⽤这个树构建⼀个真正的 DOM 树，插到⽂档当中
- 当状态变更的时候，重新构造⼀棵新的对象树。然后⽤新的树和旧的树进⾏⽐较，记录两棵树差异
- 把2所记录的差异应⽤到步骤1所构建的真正的DOM 树上，视图就更新

#### diff算法

- 把树形结构按照层级分解，只⽐较同级元素。
- 给列表结构的每个单元添加唯⼀的key 属性，⽅便⽐较。
- React 只会匹配相同 class 的 component （这⾥⾯的class 指的是组件的名字）。假如节点类型不⼀样，那么react 会直接删除该节点，然后直接创建新的节点插⼊到其中
- 合并操作，调⽤ component 的 setState ⽅法的时候, React 将其标记为 - dirty .到每⼀个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
- 选择性⼦树渲染。假如节点类型⼀样，那么会⽐较prop 是否有更新，假如有prop 不⼀样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其⼦节点进⾏⽐较，⼀层⼀层往下，直到没有⼦节点

#### react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不⼀样的时候

通常我们输出节点的时候都是map⼀个数组然后返回⼀个ReactNode ，为了⽅便react 内部进⾏优化，我们必须给每⼀个reactNode 添加key ，这个key prop 在设计值处不是给开发者⽤的，⽽是给react⽤的，⼤概的作⽤就是给每⼀个reactNode 添加⼀个身份标识，⽅便react进⾏识别，在重渲染过程中，如果key⼀样，若组件属性有所变化，则react 只更新组件对应的属性；没有变化则不更新，如果key不⼀样，则react先销毁该组件，然后重新创建该组件

####  Shadow DOM和Virtual DOM有什么区别？ 

**Shadow DOM**

Shadow DOM是浏览器提供的一个可以允许将隐藏的DOM树添加到常规的DOM树中——它以shadow root为起始根节点，在这个根节点的下方，可以是任意元素，和普通的DOM元素一样。

必须附加在一个元素上，可以是HTML文件中的一个元素，也可以是脚本中创建的元素；可以是原生的元素 

 是Web Components标准，为Web组件提供了封装，Shadow DOM使得这些东西与主文档的DOM保持分离 

**Virtual DOM**

 是虚拟的DOM，其本质上是JavaScript对象，用于模拟DOM对象，在需要操作DOM的地方，先操作Virtual DOM，在render到真实DOM上，以达到更好的性能 

虚拟DOM是由js实现的避免DOM树频繁更新，通过js的对象模拟DOM中的节点，然后通过特定的render方法将它渲染成真实的节点，数据更新时，渲染得到新的 Virtual DOM，与上一次得到的 Virtual DOM 进行 diff，得到所有需要在 DOM 上进行的变更，然后在 patch 过程中应用到 DOM 上实现UI的同步更新。

### 15 **受控组件和非受控组件**

![1600171723739](/../../../../Typora图库/Web前端/受控组件和非受控组件.png)

### 16 **高阶组件（HOC）**

 高阶组件是**重用组件逻辑的高级方法**，是一种源于 React 的组件模式。 他们**接收一个组件并返回一个新的组件**！  要记住的是，虽然名称是**高阶组件**，但是高阶组件不是组件，而是**函数**！ 既然是函数，那就可以有参数，有返回值。从上面可以看出，这个函数接收一个组件 `WrappedComponent` 作为参数 ，返回**加工过**的新组件 `EnhancedComponent`。其实**高阶组件就是设计模式里的装饰者模式**。

可以说，组件是把 props 转化成 UI，而高阶组件是把一个组件转化成另外一个组件。

```js
//一个简单的高阶组件
import React, { Component } from 'react';

export default (WrappedComponent) => {
  return class EnhancedComponent extends Component {
    // do something
    render() {
      return <WrappedComponent />;
    }
  }
}
```

 从上面的代码可以看出，我们可以对传入的原始组件 `WrappedComponent` 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而**加工**出你想要的组件 `EnhancedComponent` 。把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用。 

什么时候去使用？**当你的组件之间出现重复的模式 / 逻辑的时候**。

**HOC 不会修改传入的组件，也不会使用继承来复制其行为**。相反，HOC 通过将组件*包装*在容器组件中来*组成*新组件。HOC 是纯函数，没有副作用。被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 `data` prop。**HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的**。

HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。不要试图在 HOC 中修改组件原型（或以其他方式改变它）。 这样做会产生一些不良后果。其一是输入组件再也无法像 HOC 增强之前那样使用了。更严重的是，如果你再用另一个同样会修改 `componentDidUpdate` 的 HOC 增强它，那么前面的 HOC 就会失效！同时，这个 HOC 也无法应用于没有生命周期的函数组件。

最常见的 HOC 签名如下： 

```javascript
// React Redux 的 `connect` 函数
const ConnectedComment = connect(commentSelector, commentActions)(CommentList);

/*如果你把它分开，就会更容易看出发生了什么。*/

// connect 是一个函数，它的返回值为另外一个函数。
const enhance = connect(commentListSelector, commentListActions);
// 返回值为 HOC，它会返回已经连接 Redux store 的组件
const ConnectedComment = enhance(CommentList);
```

换句话说，`connect` 是一个返回高阶组件的高阶函数！

HOC可用于许多任务，例如：

- 代码重用，逻辑和引导抽象
- 渲染劫持
- 状态抽象和控制
- Props 控制

### 17 createElement 与 cloneElement 的区别是什么

createElement 函数是 JSX 编译之后使⽤的创建 React Element 的函数，⽽ cloneElement 则是⽤于复制某个元素并传⼊新的 Props

### 18 React Hooks 使用详解

1. useState

    **更新state的函数会直接替换state，而不是像以前setState会合并新老state** 

    因为useState的更新函数会直接替换老的state，所以我们在对对象或者数组的state做增删的时候不能像以前直接对数组使用push，pop，splice等直接改变数组的方法 ，正确的方法应该是使用数组解构生成一个新数组， 在数组后面加上我们新增的随机数达成数组新增项，使用filter数组过滤方法来实现我们删除其中项的操作。 

    **setState是异步的** 

    设置新值不会立即生效，通常它会在下一个可用的渲染上完成，或者可以进行批量处理以优化性能。因此，在设置状态值之后立即访问该值可能不会得到最新的更新结果。这个问题可以通过使用setState的可选的第二个参数来解决，这个参数是一个回调函数，它在状态值被最新的值更新完成后会被调用。 

    不过，这与钩子（hook）的做法有很大不同，因为useState钩子的setter函数没有第二个类似于setState的回调参数。在这种情况下，官方推荐的做法是使用useEffect钩子。 

   ```js
      //wrong
   	handleChange = count => {
         this.setState({ count });
         this.props.callback(this.state.count); // Old state value
       };
       
   	//right
      handleChange = count => {
         this.setState({ count }, () => {
           this.props.callback(this.state.count); // Updated state value
         });
       };
   	
   	//hook
       const [count, setCount] = useState(0)
   
       useEffect(() => {
         callback(count); // Will be called when the value of count changes
       }, [count, callback]);
   
       const handleChange = value => {
         setCount(value)
       };
   ```

   **每次渲染都是独立闭包的坑**

   当我们先执行异步增加函数(handleSyncAdd)，再执行同步函数(handleAdd)，同步执行完毕再执行异步时，异步函数里面的count为之前执行时闭包里面的值(0)。 这种情况我们要使用**回调式函数更新** 

   ```js
   import React, { useState } from "react";
   
   function Comment() {
     const [count, setCount] = useState(0);
     const handleAdd = () => setCount(count + 1);
     const handleSyncAdd = () => {
       setTimeout(() => {
       // 获取的是闭包中的state
         setCount(count + 1);
       }, 1000);
     };
     return (
       <div>
         <p>{count}</p>
         <button onClick={handleAdd}>增加</button>
         <button onClick={handleSyncAdd}>异步增加</button>
       </div>
     );
   }
   
   export default Comment;
   
   //right
   import React, { useState } from "react";
   
   function Comment() {
     const [count, setCount] = useState(0);
     const handleAdd = () => setCount(count + 1);
     const handleSyncAdd = () => {
       setTimeout(() => {
       // 改成回调函数更新，每次回调函数执行时会接收之前的state，而不是闭包中的state
         setCount(count => count + 1);
       }, 1000);
     };
     return (
       <div>
         <p>{count}</p>
         <button onClick={handleAdd}>增加</button>
         <button onClick={handleSyncAdd}>异步增加</button>
       </div>
     );
   }
   
   export default Comment;
   ```

2. useEffect

   useEffect 可以实现我们在类组件中的`componentDidMount`、`ComponentDidUpdate`和`componentWillUnmount`的功能呢，只不过被合并成为一个API。

   与 `componentDidMount` 或 `componentDidUpdate` 不同的是，**使用 `useEffect` 不会阻塞浏览器更新屏幕**，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。

   直接使用useEffect传入一个回调函数，会在组件初次渲染及每次更新渲染时执行 。 很多时候我们只需要组件初次加载做一些事，如ajax获取数据等，我们只需要在useEfffect的第二个参数传入一个空数组。 也可以在第二个数组中传入值，表明根据这个值update时执行effect 

   在项目中我们需要在组件卸载时清除定时器、监听等，<u>使用useEffect返回一个函数，这个函数会在组件卸载时调用完成componentWillUnmout的功能</u> 。

3. useLayoutEffect 

   这个是用在处理DOM的时候,<u>当你的useEffect里面的操作需要处理DOM,并且会改变页面的样式,就需要用这个,否则可能会出现出现**闪屏问题**</u>, useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制。[举例](https://juejin.im/post/6844904008402862094)

4. useMemo

   在依赖的某一属性改变的时候自动执行里面的计算并返回最终的值(并缓存，依赖性改变时才重新计算)，对于性能消耗比较大的一定要使用useMemo不然每次更新都会重新计算。

   ```js
   import React, { useState, useMemo } from 'react'
   
   function Parent() {
     const [count, setCount] = useState(0)
     const [price, setPrice] = useState(1)
     const handleCountAdd = () => setCount(count + 1)
     const handlePriceAdd = () => setPrice(price + 1)
     // 使用useMemo在count和price改变时自动计算总价
     const all = useMemo(() => count * price, [count, price])
     return (
       <div>
         parent, {count}
         <button onClick={handleCountAdd}>增加数量</button>
         <button onClick={handlePriceAdd}>增加价格</button>
         <p>count: {count}, price: {price} all: {all}</p>
       </div>
     )
   }
   ```

5.  useCallback 

   useCallback不同于useMemo的是，**useMemo是缓存的值，useCallback是缓存的函数**，父组件给子组件传递参数为普通函数时，父组件每次更新子组件都会更新，但是大部分情况子组件更新是没必要的，这时候我们<u>用useCallback来定义函数，并把这个函数传递给子组件，子组件就会根据依赖项再更新了</u>

   ```js
   import React, { useState, useCallback, useEffect } from 'react';
   function Parent() {
       const [count, setCount] = useState(1);
       const [val, setVal] = useState('');
    
       const callback = useCallback(() => {
           return count;
       }, [count]);
       return <div>
           <h4>{count}</h4>
           <Child callback={callback}/>
           <div>
               <button onClick={() => setCount(count + 1)}>+</button>
               <input value={val} onChange={event => setVal(event.target.value)}/>
           </div>
       </div>;
   }
    
   function Child({ callback }) {
       const [count, setCount] = useState(() => callback());
       useEffect(() => {
         console.log(123);
           setCount(callback());
       }, [callback]);
       return <div>
           {count}
       </div>
   }
   
   export default Parent
   
   ```

6.  useContext 

    useContext可以实现类似react-redux插件的功能，上层组件使用createContext创建一个context，并使用<MyContext.Provider>来传递context，下层组件使用useContext来接收context。 

7. useRef 

    React Hooks中用来获取DOM节点 

8. useReducer

   useReducer和redux中reducer类似，<u>useState 的替代方案</u>。它接收一个形如 (state, action) => newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。

   在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。

   ```js
   import React, { useReducer } from 'react'
   
   function Parent() {
     const reducer = (state, action) => {
       switch (action.type) {
         case 'add':
           return {count: state.count + 1}
         case 'reduce':
           return {count: state.count - 1}
         default:
           throw new Error()
       }
     }
     let initialState = 0
     const init = (initialState) => ({
       count: initialState
     })
     // 第三个参数为惰性初始化函数，可以用来进行复杂计算返回最终的initialState，如果initialState较简单可以忽略此参数
     const [state, dispatch] = useReducer(reducer, initialState, init)
     return (
       <div>
         <p>{state.count}</p>
         <button onClick={() => dispatch({type: 'add'})}>add</button>
         <button onClick={() => dispatch({type: 'reduce'})}>reduce</button>
       </div>
     )
   }
   
   export default Parent
   ```

### 19 我现在有⼀个button，要⽤react在上⾯绑定点击事件，要怎么做？

```javascript
class Demo {
	render() {
		return <button onClick={(e) => {
			alert('我点击了按钮')
		}}>
		按钮
		</button>
	}
}
```

你觉得你这样设置点击事件会有什么问题吗？

由于onClick 使⽤的是匿名函数，所有每次重渲染的时候，会把该onClick 当做⼀个新的prop 来处理，会将内部缓存的onClick 事件进⾏重新赋值，所以相对直接使⽤函数来说，可能有⼀点的性能下降

修改：

```javascript
class Demo {
	onClick = (e) => {
		alert('我点击了按钮')
	}
	render() {
		return <button onClick={this.onClick}>
		按钮
		</button>
	}
```

### 20 给我介绍⼀下react（mvvm，虚拟dom，redux）

1. 以前我们没有jquery的时候，我们⼤概的流程是**从后端通过ajax获取到数据然后使⽤jquery⽣成dom结果然后更新到⻚⾯当中**，但是随着业务发展，我们的项⽬可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们⼜需要重新组装⼀次dom结构，然后更新⻚⾯，这样我们**⼿动同步dom和数据的成本就越来越⾼**，⽽且频繁的操作dom，也使我们**⻚⾯的性能慢慢的降低**。
2. 这个时候mvvm出现了，**mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以⼤⼤降低我们⼿动去维护dom更新的成本**，mvvm为react的特性之⼀，虽然react属于单项数据流，需要我们⼿动实现双向数据绑定。
3. 有了mvvm还不够，因为**如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了⻚⾯性能)的问题**，为了解决这个问题，react内部实现了⼀套**虚拟dom结构**，也就是⽤js实现的⼀套dom结构，他的作⽤是讲真实dom在js中做⼀套缓存，每次有数据更改的时候，react内部先使⽤算法，也就是鼎鼎有名的diff算法对dom结构进⾏对⽐，**找到那些我们需要新增、更新、删除的dom节点，然后⼀次性对真实DOM进⾏更新，这样就⼤⼤降低了操作dom的次数**。 那么diff算法是怎么运作的呢，⾸先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且⽤新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对⽐这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。
4. react**设计之初是主要负责UI层的渲染**，虽然每个组件有⾃⼰的state，state表示组件的状态，当状态需要变化的时候，需要使⽤setState更新我们的组件，但是，我们想通过⼀个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到⽗组件当中，让⽗组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要⼀直往下传，⽆疑加⼤了我们代码的复杂度，我们需要⼀个**状态管理中⼼**，来帮我们管理我们状态state。
5. 这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某⼀个state有变化的时候，依赖到这个state的组件就会进⾏⼀次重渲染，这样就解决了我们的我们需要⼀直把state往下传的问题。redux有action、reducer的概念，**action为唯⼀修改state的来源，reducer为唯⼀确定state如何变化的⼊⼝**，这使得redux的数据流⾮常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。
6. 后来，社区就出现了另外⼀套解决⽅案，也就是mobx，它推崇代码简约易懂，只需要定义⼀个可观测的对象，然后哪个组价使⽤到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，⽽且mobx内部也做好了是否重渲染组件的⽣命周期shouldUpdateComponent，不建议开发者进⾏更改，这使得我们使⽤mobx开发项⽬的时候可以简单快速的完成很多功能，连redux的作者也推荐使⽤mobx进⾏项⽬开发。但是，随着项⽬的不断变⼤，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以**针对于⼩项⽬来说，社区推荐使⽤mobx，对⼤项⽬推荐使⽤redux**

### 21 React特点，优点，限制

特点：

1. 它使用**虚拟DOM **而不是真正的DOM。
2. 它可以用**服务器端渲染**。
3. 它遵循**单向数据流**或数据绑定。

优点：

1. 它提高了应用的性能
2. 可以方便地在客户端和服务器端使用
3. 由于 JSX，代码的可读性很好
4. React 很容易与 Meteor，Angular 等其他框架集成
5. 使用React，编写UI测试用例变得非常容易

限制：

1. React 只是一个库，而不是一个完整的框架
2. 它的库非常庞大，需要时间来理解
3. 新手程序员可能很难理解
4. 编码变得复杂，因为它使用内联模板和 JSX

#### 说说React有哪些坑点

在使用react 中经常会遇到各种个样的问题，如果对react不熟悉则会对遇到的问题感到莫名其妙而束手无策，接下来分析一下react中容易遇到的问题和注意点。

1、setState()是异步的
this.setState()会调用render方法，但并不会立即改变state的值，state是在render方法中赋值的。所以执行this.setState()后立即获取state的值是不变的。同样的直接赋值state并不会出发更新，因为没有调用render函数。

2、组件的生命周期
componentWillMount，componentDidMount 只有在初始化的时候才调用。
componentWillReceivePorps，shouldComponentUpdate，componentWillUpdata，componentDidUpdate 只有组件在更新的时候才被调用，初始化时不调用。

3、reducer必须返回一个新的对象才能触发组件的更新
因为在connect函数中会对新旧两个state进行浅对比，如果state只是值改变但是引用地址没有改变，connect会认为它们相同而不触发更新。

4、无论reducer返回的state是否改变，subscribe中注册的所有回调函数都会被触发。

5、组件命名的首字母必须是大写，这是类命名的规范。

7、按需加载时如果组件是通过export default 暴露出去，那么require.ensure时必须加上default。

```js
require.ensure([], require => {
    cb(null, require('../Component/saleRecord').default)
},'saleRecord')
```

10、componentWillUpdate中可以直接改变state的值，而不能用setState。

11、如果使用es6class类继承react的component组件，constructor中必须调用super，因为子类必须用super继承component的this，否则实例化的时候会报错。

12、组件卸载之前，加在dom元素上的监听事件，和定时器需要手动清除，因为这些并不在react的控制范围内，必须手动清除。指的是在this.refs.xxx这种真实dom上addEventListener这样添加的监听事件，在组件卸载的时候要手动清除(removeEventListener)，react组件上的onClick这种不用管，react帮我们处理好了

### 22 JSX

 JSX 是JavaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。 

```jsx
render(){
    return(        
        <div>
            <h1> Hello World from Edureka!!</h1>
        </div>
    );
}
```

**为什么浏览器无法读取JSX？**

浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。

### 23 组件

#### render()

每个React组件强制要求必须有一个 **render()**。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 `<form>`、`<group>`、`<div>` 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。

Reac更新视图必须触发Render，但是这样往往又很影响性能（因为有dom改动），React利用特有的diff算法采用虚拟DOM，是的性能有了很大的提升。

但是我们在开发中还是要注意性能优化，避免没有意义的Render。

触发Render的条件：

- 首次加载组件
- 使用了setState（更新了Props）
- Props更新了(父级传给子级的值改变了)

很多情况下我们可以直接避免很多2、3情况。

#### Props

 Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。 

#### State

状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 `this.state()` 访问它们。使用setState更新。


# 题目
### 处理输入输出

单行输入

```js
while(line=readline()){
    var lines = line.split(' ');
    var a = parseInt(lines[0]);
    var b = parseInt(lines[1]);
    function add(m,n){
        return m+n;
    }
    print(add(a,b));
}
```

多行输入

```js
//固定多行输入
let lineNum; // 获取第一行输入的数字，即行数
let lines = []
while(lineNum = parseInt(readline())){
  for(let i = 0; i < lineNum; i++) {
  	lines.push(readline()); // 遍历行数，依次获取每一行的字符
	}
}
print(lines) // 一次性全部输出所有结果
/*
eg：
输入：3
     1 2
     2 3
得到的是 line // 3
        lines // ['1 2', '3 4']
*/

//任意行数输入
let line;
while(line=readline()){ // 有多个输入样例，只要每一行有数据，就会继续循环读取单行数据
    var lines = line.trim().split(' '); // 去掉每一行的首尾空格，用空格分隔每一行的数据
    var a = parseInt(lines[0]);  // 将分隔出的字符串转为整型，并存储在变量 a 中
    var b = parseInt(lines[1]);
    print(a+b);
}
/*
输入：1 2
     3 4
     6 1
输出：3
     7
     7
*/

// 直接将每一行的数据（字符串）存入数组 lines 中：
let lines = [], tmp;
while(tmp = readline()){
  lines.push(tmp);
}
print(lines);
/*
输入：1 2
     3 4
     6
输出：1 2,3 4,6
*/
```

输出

用 print() 和 console.log() 都可以，多行输入会根据你的print个数来自动折行；或者利用print(lines + ‘\n’); 来折行。 

Node实现单行输入

```js
var readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})
rl.on('line', function(line) {
  //line为输入的单行字符串，split函数--通过空格将该行数据转换为数组。
  var arr= line.split(' ')
 //数组arr的每一项都是字符串格式，如果我们需要整型，则需要parseInt将其转换为数字
  console.log(parseInt(arr[0]) + parseInt(arr[1]));
}
```

Node实现多行输入（固定行数）

```js
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
var inputArr = [];
rl.on('line', function (input) {
    inputArr.push(input);
    var nLine = +inputArr[0];
    if (inputArr.length == (nLine + 1)) {
        var arr = inputArr.slice(1);
        console.log(arr);
        inputArr = [];
    }
});
/*
输入：
4
32
12
34
23
输出：
[ '32', '12', '34', '23' ]
*/
```

Node实现多行输入（行数不固定）

```js
process.stdin.resume();
process.stdin.setEncoding('ascii');
  
var input = "";
var input_array = "";
  
process.stdin.on('data', function (data) {
    input += data;
});
  
process.stdin.on('end', function () {
    input_array = input.split("\n");
　　 //示例代码
    var len = input_array.length;
    var result = [];
    for(var i=0; i<len; i++){
        var temp = input_array[i].trim().split(' ');
        for(var j=0; j<temp.length; j++){
            if(temp[j]!=='' && result.indexOf(temp[j]) == -1){
                result.push(temp[j]);
            }
        }
    }
    console.log(result.length);
});
```

## 前端实现

### 1 如何在⻚⾯上实现⼀个圆形的可点击区域？

**1. map和area**

```xml
<img src="./peppa.png" usemap="#Map">
<map name="Map" id="Map">
    <area shape="circle" coords="200,200,100" href="#rect" alt="圆形">
</map>
```

将img和map标签连起来的是usemap，它的值是map的id
 area属性：

- shape：表示热点区域的形状，支持rect（矩形），circle（圆形），poly（多边形）
- coords：表示热点区域的坐标，(0,0)表示图片左上角。rect四个值分别表示左上角坐标和右下角坐标。circle三个值分别表示圆心坐标和半径。poly有若干个值，每两个表示一个坐标点。
- href：表示链接到某个地址，和<a>标签差不多
- alt：对该区域描述，类似于<img>的alt

**2. CSS3的border-radius属性**

```csharp
<div class="content"></div>
.content{
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: 1px solid #ccc;
}
var content = document.getElementsByClassName("content")[0]
content.addEventListener("click",function(){
    alert("aaa")
})
```

**3. js实现**
 原理：设定一个坐标原点和半径，获取鼠标的x,y轴位置，当鼠标的位置与原点的位置不超过半径时，可点击。

```jsx
document.onclick = function(e){
    let [x,y,r] = [100,100,100] // x,y为坐标原点，r为半径
    let x1 = e.clientX; // 获取x坐标
    let y1 = e.clientY; // 获取y坐标
    let dis = Math.abs(Math.sqrt((Math.pow(x-x1,2)+Math.pow(y-y1,2))))
    if(dis<r){
        alert("bbb")
    }
}
```

- Math.abs()：取绝对值
- Math.sqrt()：开平方
- Math.pow(num,n)：num的n次方

## JS题目

### 1 ["1", "2", "3"].map(parseInt) 答案是多少

[1, NaN, NaN] 

parseInt 需要两个参数 (val, radix) ，其中radix 表示解析时⽤的基数。

 map方法中接受一个函数function，用来处理遍历数组中的每一个元素。  这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，第二个参数代表该元素的索引。 

下面我们来分析一下['1', '2', '3'].map(parseInt);（**相当于parseInt(x, x.indexof())**）

1. parseInt('1', 0); // radix为0时，使用默认的10进制。
2. parseInt('2', 1); // radix值在2-36，无法解析，返回NaN
3. parseInt('3', 2); // 基数为2，2进制数表示的数中，最大值小于3，无法解析，返回NaN

map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]

### 2 如何通过JS判断⼀个数组

- instanceof ⽅法：instanceof 运算符是⽤来测试⼀个对象是否在其原型链原型构造函数的属性

  ```javascript
  var arr = [];
  arr instanceof Array; // true
  ```

- constructor ⽅法：constructor 属性返回对创建此对象的数组函数的引⽤，就是返回对象相对应的构造
  函数

  ```javascript
  var arr = [];
  arr.constructor == Array; //true
  ```

- Object的toString方法

  ```javascript
  Object.prototype.toString.call(value) == '[object Array]'
  // 利⽤这个⽅法，可以写⼀个返回数据类型的⽅法
  var isType = function (obj) {
  	return Object.prototype.toString.call(obj).slice(8,-1);
  }
  ```

- ES5 新增⽅法isArray()

  ```javascript
  var a = new Array(123);
  var b = new Date();
  console.log(Array.isArray(a)); //true
  console.log(Array.isArray(b)); //false
  ```

### 3 快速的让⼀个数组乱序

```javascript
var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(function(){
	return Math.random() - 0.5;
})
console.log(arr);
```

### 4 如何渲染⼏万条数据并不卡住界⾯

应该⼀次渲染部分 DOM ，那么就可以通过requestAnimationFrame 来每 16 ms 刷新⼀次

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Document</title>
</head>
<body>
    <ul>控件</ul>
	<script>
		setTimeout(() => {
			// 插⼊⼗万条数据
			const total = 100000
			// ⼀次插⼊ 20 条，如果觉得性能不好就减少
			const once = 20
			// 渲染数据总共需要⼏次
			const loopCount = total / once
			let countOfRender = 0
			let ul = document.querySelector("ul");
			function add() {
				// 优化性能，插⼊不会造成回流
				const fragment = document.createDocumentFragment();
				for (let i = 0; i < once; i++) {
					const li = document.createElement("li");
					li.innerText = Math.floor(Math.random() * total);
					fragment.appendChild(li);
				}
				ul.appendChild(fragment);
				countOfRender += 1;
				loop();
			}
			function loop() {
				if (countOfRender < loopCount) {
				window.requestAnimationFrame(add);
			}
		}
		loop();
	}, 0);
</script>
</body>
</html>
```

### 5 数组去重⽅法总结

**⽅法⼀、利⽤ES6 Set去重（ES6中最常⽤）**

```javascript
function unique (arr) {
return Array.from(new Set(arr))
}
```

**⽅法⼆、利⽤for嵌套for，然后splice去重（ES5中最常⽤）**

```javascript
function unique(arr){
	for(var i=0; i<arr.length; i++){
		for(var j=i+1; j<arr.length; j++){
			if(arr[i]==arr[j]){ //第⼀个等同于第⼆个，splice⽅法删除
				arr.splice(j,1);
				j--;
			}
		}
	}
	return arr;
}
```

**⽅法三、利⽤indexOf去重**

```javascript
function unique(arr) {
	if (!Array.isArray(arr)) {
		console.log('type error!')
		return
	}
	var array = [];
		for (var i = 0; i < arr.length; i++) {
			if (array .indexOf(arr[i]) === -1) {
				array .push(arr[i])
			}
		}
	return array;
}
```

新建⼀个空的结果数组， for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push 进数组

**⽅法四、利⽤sort()**

```javascript
function unique(arr) {
	if (!Array.isArray(arr)) {
		console.log('type error!')
		return;
	}
	arr = arr.sort()
	var arrry= [arr[0]];
	for (var i = 1; i < arr.length; i++) {
		if (arr[i] !== arr[i-1]) {
			arrry.push(arr[i]);
		}
	}
	return arrry;
}
```

利⽤sort() 排序⽅法，然后根据排序后的结果进⾏遍历及相邻元素⽐对

**⽅法五、利⽤对象的属性不能相同的特点进⾏去重**

```javascript
function unique(arr) {
	if (!Array.isArray(arr)) {
		console.log('type error!')
		return
	}
	var arrry= [];
	var obj = {};
	for (var i = 0; i < arr.length; i++) {
		if (!obj[arr[i]]) {
			arrry.push(arr[i])
			obj[arr[i]] = 1
		} else {
			obj[arr[i]]++
		}
	}
	return arrry;
}
```

**⽅法六、利⽤includes**

```javascript
function unique(arr) {
	if (!Array.isArray(arr)) {
		console.log('type error!')
		return
	}
	var array =[];
	for(var i = 0; i < arr.length; i++) {
		if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
			array.push(arr[i]);
		}
	}
	return array
}
```

**⽅法七、利⽤hasOwnProperty**

```javascript
function unique(arr){
    var array=[], obj={};
    for(let i=0; i<arr.length; i++){
        if(!obj.hasOwnProperty(arr[i])){
            array.push(arr[i]);
            obj[arr[i]] = true;
        }
    }
    return array;
}
```

利⽤hasOwnProperty 判断是否存在对象属性

**⽅法⼋、利⽤filter**

```javascript
function unique(arr) {
	return arr.filter(function(item, index, arr) {
		//当前元素，在原始数组中的第⼀个索引==当前索引值，否则返回当前元素
		return arr.indexOf(item, 0) === index;
	});
}
```

**⽅法九、利⽤递归去重**

```javascript
function unique(arr) {
	var array= arr;
	var len = array.length;
	array.sort(function(a,b){ //排序后更加⽅便去重
		return a - b; 
	});
	function loop(index){
		if(index >= 1){
			if(array[index] === array[index-1]){
				array.splice(index,1);
			}
			loop(index - 1); //递归loop，然后数组去重
		} 
	}
	loop(len-1);
	return array; 
}
```

**⽅法⼗、利⽤Map数据结构去重**

```javascript
function arrayNonRepeatfy(arr) {
	let map = new Map();
	let array = new Array(); // 数组⽤于返回结果
	for (let i = 0; i < arr.length; i++) {
		if(map.has(arr[i])) { // 如果有该key值
			map.set(arr[i], true); 
		} else {
			map.set(arr[i], false); // 如果没有该key值
			array.push(arr[i]); 
		} 
	}
	return array; 
}
```

**⽅法⼗⼀、利⽤reduce+includes**

```javascript
function unique(arr){
    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);
}
```

**⽅法⼗⼆、[...new Set(arr)]**

```javascript
[...new Set(arr)]
//代码就是这么少----（其实，严格来说并不算是⼀种，相对于第⼀种⽅法来说只是简化了代码）
```

### 6 实现⼀个对⻚⾯某个节点的拖曳

- 给需要拖拽的节点绑定mousedown , mousemove , mouseup 事件
- mousedown 事件触发后，开始拖拽
- mousemove 时，需要通过event.clientX 和clientY 获取拖拽位置，并实时更新位置
- mouseup 时，拖拽结束

- 需要注意浏览器边界的情况

### 7 写⼀个通⽤的事件侦听器函数

```javascript
// event(事件)⼯具集，来源：github.com/markyun
markyun.Event = {
	// 视能⼒分别使⽤dom0||dom2||IE⽅式 来绑定事件
	// 参数： 操作的元素,事件名称 ,事件处理程序
	addEvent : function(element, type, handler) {
		if (element.addEventListener) {
			//事件类型、需要执⾏的函数、是否捕捉
			element.addEventListener(type, handler, false);
		} else if (element.attachEvent) {
			element.attachEvent('on' + type, function() {
			handler.call(element);
		});
	} else {
		element['on' + type] = handler;
	}
},
// 移除事件
removeEvent : function(element, type, handler) {
	if (element.removeEventListener) {
		element.removeEventListener(type, handler, false);
	} else if (element.datachEvent) {
		element.detachEvent('on' + type, handler);
	} else {
		element['on' + type] = null;
	}
},
// 阻⽌事件 (主要是事件冒泡，因为IE不⽀持事件捕获)
stopPropagation : function(ev) {
	if (ev.stopPropagation) {
		ev.stopPropagation();
	} else {
		ev.cancelBubble = true;
	}
},
// 取消事件的默认⾏为
preventDefault : function(event) {
	if (event.preventDefault) {
		event.preventDefault();
	} else {
		event.returnValue = false;
	}
},
// 获取事件⽬标
getTarget : function(event) {
	return event.target || event.srcElement;
}
```

### 8 求⼀个字符串的字节⻓度

假设：⼀个英⽂字符占⽤⼀个字节，⼀个中⽂字符占⽤两个字节

```javascript
function GetBytes(str){
	var len = str.length;
	var bytes = len;
	for(var i=0; i<len; i++){
		if (str.charCodeAt(i) > 255) bytes++;
	}
	return bytes;
}
alert(GetBytes("你好,as"));
```

### 9 循环中解决 var 定义函数的问题 (setTimeout)

```js
for ( var i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
```

⾸先因为 setTimeout 是个异步函数，所有会先把循环全部执⾏完毕，这时候 i 就是6 了，所以会输出⼀堆 6 。

```js
//解决办法两种，第⼀种使⽤闭包
for (var i = 1; i <= 5; i++) {
	(function(j) {
		setTimeout(function timer() {
		console.log(j);
		}, j * 1000);
	})(i);
}

//第⼆种就是使⽤ setTimeout 的第三个参数
for ( var i=1; i<=5; i++) {
	setTimeout( function timer(j) {
		console.log( j );
	}, i*1000, i);
}

//第三种就是使⽤ let 定义 i 了,因为对于 let 来说，他会创建⼀个块级作⽤域
for ( let i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
```

### 10 定义⼀个log⽅法，让它可以代理console.log的⽅法

```javascript
function log(){
	console.log.apply(console, arguments);
};
```

### 11 输出今天的⽇期

```javascript
var d = new Date();
// 获取年，getFullYear()返回4位的数字
var year = d.getFullYear();
// 获取⽉，⽉份⽐较特殊，0是1⽉，11是12⽉
var month = d.getMonth() + 1;
// 变成两位
month = month < 10 ? '0' + month : month;
// 获取⽇
var day = d.getDate();
day = day < 10 ? '0' + day : day;
alert(year + '-' + month + '-' + day);
```

### 12 ⽤js实现随机选取10–100之间的10个数字，存⼊⼀个数组，并排序

```javascript
var iArray = [];
funtion getRandom(istart, iend){
	var iChoice = istart - iend +1;
	return Math.floor(Math.random() * iChoice + istart;
}
for(var i=0; i<10; i++){
	iArray.push(getRandom(10,100));
}
iArray.sort();
```

### 13 提取URL中的各个GET参数

有这样⼀个URL ： `http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e` ，请写⼀段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value 形式返回到⼀个json 结构中，如{a:'1', b:'2', c:'', d:'xxx', e:undefined}

```javascript
function serilizeUrl(url) {
	var result = {};
	url = url.split("?")[1];
	var map = url.split("&");
	for(var i = 0, len = map.length; i < len; i++) {
		result[map[i].split("=")[0]] = map[i].split("=")[1];
	}
	return result;
}
```

### 14 清除字符串前后的空格

```javascript
if (!String.prototype.trim) {
	String.prototype.trim = function() {
		return this.replace(/^\s+/, "").replace(/\s+$/,"");
	}
}
```

### 15 实现每隔⼀秒钟输出1,2,3...数字

```javascript
for(var i=0;i<10;i++){
	(function(j){
		setTimeout(function(){
			console.log(j+1)
		},j*1000)
	})(i)
}

```

### 16 判断输⼊是不是回⽂字符串

```javascript
function run(input) {
	if (typeof input !== 'string') return false;
	return input.split('').reverse().join('') === input;
}

```

### 17 数组扁平化处理

1. 递归

   ```js
   var arr = [1, [2, [3, 4]]];
   
   function flatten(arr) {
       var result = [];
       for (var i = 0, len = arr.length; i < len; i++) {
           if (Array.isArray(arr[i])) {
               result = result.concat(flatten(arr[i]))
           }
           else {
               result.push(arr[i])
           }
       }
       return result;
   }
   ```
2. reduce
    ```javascript
    function flatten(arr){
        return arr.reduce(function(prev,item){
            return prev.concat(Array.isArray(item) ? flatten(item) : item);
        },[]);
    }
    ```

3. 扩展运算符

   ```js
   var arr = [1, [2, [3, 4]]];
   console.log([].concat(...arr)); // [1, 2, [3, 4]]
   
   function flatten(arr) {
       while (arr.some(item => Array.isArray(item))) {
           arr = [].concat(...arr);
       }
       return arr;
   }
   ```

4.  toString/join & split

    只适于数组的元素都是数字 

   ```js
   function flatten(arr) {
       return arr.toString().split(',').map(function(item) {
           return Number(item);
       })
   } 
   
   function flatten(arr) {
       return arr.join(',').split(',').map(function(item) {
           return parseInt(item);
       })                                
   } 
   ```

5. Underscore

   _.flatten

   ```js
   _.flatten([1, [2], [3, [[4]]]]);
   => [1, 2, 3, 4];
   
   //如果设第二个参数为true，只展开一维
   console.log(_.flatten([1, [2], [3, [4, [5, [6, [7]]]]]], true)); 
   => [1, 2, 3, [4, [5, [6, [7]]]]];
   ```

6. flat

    这是ES6提供的方法，用于数组扁平化，这个方法返回一个新的数组，并不会改变原数组。 flat() 默认扁平一层嵌套 ， 可以带一个整数参数表示扁平的层数 ， 如果对于无论多少层嵌套的数组都想转成一维数组，可以用Infinity关键字作为参数 。

   ```js
   let array = [1, [[2, 3], 4]]
   console.log(array.flat())
   // 打印[1, [2, 3], 4]
   
   let array = [1, [[2, 3], 4]]
   console.log(array.flat(2))
   // 打印[1, 2, 3, 4]
   
   
   let array = [1, [[2, 3], 4]]
   console.log(array.flat(Infinity))
   // 打印[1, 2, 3, 4]
   ```

   

### 18 从八道面试题看JavaScript DOM事件机制

- 2,1

  ```js
  <div class="test1">
      <div class="test2"></div>
  </div>
  <script>
      document.querySelector('.test1').addEventListener('click',function () {
          console.log(1)
      })
      document.querySelector('.test2').addEventListener('click',function () {
          console.log(2)
      })
  </script>
  
  ```

- 1,2

  ```js
  <div class="test1">
      <div class="test2"></div>
  </div>
  <script>
      document.querySelector('.test1').addEventListener('click', function () {
          console.log(1)
      }, true)
      document.querySelector('.test2').addEventListener('click', function () {
          console.log(2)
      }, true)
  </script>
  
  ```

- 2,1

  ```js
  <div class="test1">
      <div class="test2"></div>
  </div>
  <script>
      document.querySelector('.test1').addEventListener('click', function () {
          console.log(1)
      })
      document.querySelector('.test2').addEventListener('click', function () {
          console.log(2)
      }, true)
  </script>
  
  ```

- 1,2

  ```js
  <div class="test1">
      <div class="test2"></div>
  </div>
  <script>
      document.querySelector('.test1').addEventListener('click', function () {
          console.log(1)
      }, true)
      document.querySelector('.test2').addEventListener('click', function () {
          console.log(2)
      })
  </script>
  
  ```

 解答：

事件机制是**先进行捕获，再进行冒泡** .

 对`addEventListener`的第三个参数 ，`useCapture` 可选，Boolean，**在DOM树中，注册了listener的元素， 是否要先于它下面的EventTarget，调用该listener**。 当useCapture(设为true) 时，沿着DOM树向上冒泡的事件，不会触发listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。

- 1,2

  ```js
  <div class="test1"></div>
  <script>
      document.querySelector('.test1').addEventListener('click', function () {
          console.log(1)
      })
      document.querySelector('.test1').addEventListener('click', function () {
          console.log(2)
      }, true)
  </script>
  
  ```

解答： 若是被监听的元素没有子元素，那么哪一个监听代码写在前面，就先执行哪一个！ 

- 1,2,1

  ```js
  <label>Click me <input type="text"></label>
  <script>
      document.querySelector('label').addEventListener('click',function () {
          console.log(1)
      })
      document.querySelector('input').addEventListener('click',function () {
          console.log(2)
      })
  </script>
  
  ```

解答： 由于label和input是有绑定的，**点击label后，浏览器自动帮你再点击一次label过程**，就是先进行一次事件机制，这一次对内部input元素的事件监听是无论不问的，因此先打出`1`结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，因此接着打出了`2,1` 

### 19 作用域题目

题一：

```js
var a = 1;
function fn() {
  console.log('1:' + a);

  var a = 2;
  bar()
  console.log('2:' + a)
}

function bar() {
  console.log('3:' + a)
}

fn()

/**
1:undefined
3:1
2:2
*/

```

第一个 a 打印的值是 `1:undefined` 而不是 1。因为我们在 `fn()` 中定义了变量 a，用 var 定义的变量会在当前作用域提升，但是并不会携带赋给变量的值一起提升。

第二个 a 打印的值是 `3:1` 而不是 2。因为函数 bar 是定义在全局作用域中的，所以作用域链是 bar -> global，bar 里面没有定义a，所以就会顺着作用域链向上找，然后在 global 中找到了 a。

第三个 a 打印的值是 `2:2`。这句话所在的作用域链是 fn -> global，执行 `console.log('2:' + a)` 会首先在 fn 作用域里查找 a，找到有 a，并且值为2，所以结果就是2。

题二：

```js
var a = 1;
function fn() {
  console.log('1:' + a);
  a = 2
}

a = 3;
function bar() {
  console.log('2:' + a);
}

fn();
bar();

/**
1:3
2:2
*/

```

第一个 a 打印的值是 `1:3`，既不是 undefined 也不是 1。首先， `fn` 中的 `a = 2` 是给变量 a 赋值，并没有定义变量。然后，执行函数 `fn`，在查找变量 a 时，此时查找的变量就是全局变量 a，不过此时 a 的值为3。

第二个 a 打印的值是 `2:2`。函数 bar 所能访问的作用域链为 bar->global，在执行函数 bar 时，a 的值已经被修改成了 2。

前面的东西可能有点啰嗦冗余，我们稍稍提炼总结一下。

> 在JavaScript中，通过 `let` 和 `const` 定义的变量具有块级作用域的特性。
>
> 通过 `var` 定义的变量会在它自身的作用域中进行提升，而 `let` 和 `const` 定义的变量不会。
>
> **每个JavaScript程序都具有一个全局作用域，每创建一个函数都会创建一个作用域**。
>
> 在创建函数时，将这些函数进行嵌套，它们的作用域也会嵌套，形成作用域链，**子作用域可以访问父作用域，但是父作用域不能访问子作用域**。
>
> 在执行一个函数时，如果我们需要查找某个变量值，那么会去这个函数被 **定义** 时所在的作用域链中查找，一旦找到需要的变量，就会停止向上查找。
>
> “变量的**值**由函数定义时的位置决定”这句话有歧义，准确说是**查找**变量时，是去定义这个函数时所在的作用域链查找。

 其实记住2条规则，大部分作用域的面试题都可以解，**1、function 提升 优先 var 2、(function)同名的，后面覆盖前面。** 

#### 变量提升和函数提升

在开始阐述之前，我们来看一段代码，看看结果是什么？

```js
alert(a);
function a(){ alter(2); }
alert(a);
var a = 1
alert(a);
var a = 3;
alert(a);
function a(){ alter(4); }
alert(a);
a();
```

这里先揭晓答案：

> - 第一个 `alert(a)`  弹出 `function a(){ alter(4); }` 函数体
> - 第二个 `alter(a)`  弹出 `function a(){ alter(4); }` 函数体
> - 第三个 `alter(a)`  弹出 **1**
> - 第四个 `alter(a)`  弹出 **3**
> - 第五个 `alter(a)`  弹出 **3**
> - 最后一行报错 `a is not a function`

下面来分析一下这段代码： 其实在 `javascript` 开始执行代码之前，有一个 **预解析（预编译）** 的过程，这个过程会产生 **变量提升** 和 **函数提升** ，其实整个执行过程可以分为两部分，方便理解：

1. **预解析** 这个过程，会把 关键字 `var` 、 `function` 、 **参数** 提取出来

上面这段代码 **预解析** 的过程是：

```js
// 第1行，没有关键字 ， 不解析
// 第2行，遇到 function 关键字，解析到全局的头部
a = function a(){ alter(2); }
// 第3行，没有关键字 ， 不解析
// 第4行，遇到关键字 var ， 解析到全局的头部
a = undefined
// 第5行，没有关键字 ， 不解析
// 第6行，遇到关键字 var ， 解析到全局的头部
a = undefined
// 第8行，遇到 function 关键字，解析到全局的头部
a = function a(){ alter(4); }
// 第9行，没有关键字 ， 不解析
// 第10行，a() 函数调用
```

此时这里有4个同名变量 a ，依循规则是：**`function` 优先与 `var`, 同名的后面覆盖前面的** 

因此，`a = function a(){ alter(2); }` 替换掉下面的2个 `a = undefined` ，`a = function a(){ alter(4); }` 又替换掉 `a = function a(){ alter(2); }` ,最终只剩下 `a = function a(){ alter(4); }`

**预解析（预编译）** 后的代码样子是这样的

```js
var a = function a(){ alter(4); }
alert(a);
alert(a);
a = 1
alert(a);
a = 3;
alert(a);
alert(a);
a();

```

执行代码，就是执行的这段代码，依次从上到下执行，最后的 `a()` 函数调用，这时的 `a` 已被 **表达式** 赋值成 **3** ，而报错 `a is not a function`

#### 全局作用域和局部作用域

再看这段代码

```js
var a = 1;
function fn1(){
    alert(a);
    var a = 2;
}
fn1();
alert(a);

```

这里先揭晓答案：

- 第一个 `alert(a)` 弹出 `undefined`
- 第二个 `alert(a)` 弹出 **1** 

`JavaScript` 的作用域只用两种，一个是全局的，一个是函数的，也称为 **全局作用域** 和 **局部作用域** ；**局部作用域** 可以访问 **全局作用域** 。但是 **全局作用域** 不能访问 **局部作用域**

同样用 **预解析（预编译）** 的方法来分析这段代码

1. **预解析（预编译）** 全局作用域

```js
// 第1行，遇到 var 关键字，解析到全局的头部
a = undefined
// 第2行，遇到 function 关键字，解析到全局的头部
fn1 = function fn1(){
    alert(a);
    var a = 2;
}
// 第3行，没有遇到关键字，不解析
// 第4行，没有遇到关键字，不解析

```

1. 开始执行代码

第1行，遇到表达式 `a = 1`, **a** 被赋值成 **1** 
 第6行，遇到函数调用 `fn1()` ,开始 **预解析（预编译）** 局部

1. **预解析（预编译）** 局部作用域

```js
// 第3行，没有遇到关键字，不解析
// 第4行，遇到 var 关键字，解析到局部
a = undefined

```

开始执行 **局部** 代码：第3行，弹出 `undefined` 第4行，遇到表达式，把局部 **a** 改成 **2**

局部执行完成，继续执行全局：第7行，弹出 **1** ，因为全局和局部是两个独立的作用域

#### 作用域链

如果，把上面👆代码，稍作修改

```js
var a = 1;
function fn1(){
    alert(a);
    a = 2;
}
fn1();
alert(a);

```

去掉了 `function` 里的 `var` ，结果就会不一样 这次，输出的是：

- 第一个 `alert` 弹出 **1**
- 第二个 `alert` 弹出 **2** ：因为在解析局部是没有发现 `var a` ，如是在执行时，就会去全局查找，找到了全局的 `a = 1` ，所以 第一个 `alert` 弹出 **1** ，而不是 `undefined` ,这个就是 **作用域链**

#### 匿名函数表达式、具名函数表达式

在来看看这段代码👇

```js
var a = 3;
function fn() {
    foo();
    function foo() {
        console.log(1);
    }
    foo();
    var foo = function() {
        console.log(2);
    };
    foo();
    var bar = function foo() {
        if(a > 3) return;
        console.log(++a);
        foo();
    };
    foo();
    bar();
}
fn();

```

先揭晓答案：

> - 第1个 `foo()` 输出的是 **1**
> - 第2个 `foo()` 输出的是 **1**
> - 第3个 `foo()` 输出的是 **2**
> - 第4个 `foo()` 输出的是 **2**
> - 最后的 `bar()` 输出的是 **4**

以上代码包含了 **函数声明** 、 **匿名函数表达式** 、 **具名函数表达式** ，**匿名函数表达式** 、 **具名函数表达式** 是把函数体赋值给一个变量，因此拥有和变量相同的特性 **变量提升** ，而 **具名函数表达式** 的函数名只能在函数内部使用。

了解了这些，再来分析段代码

- **全局预解析**

```js
a = undefined
fn = function fn(){
    ...
}

```

- **执行代码** 第1行，遇到表达式,把 **a** 的值改变成3 ;最后行，遇到函数调用，重新 **预解析** 局部
- **局部预解析**

```js
// 第4行，遇到 function 关键字，解析到局部的头部
foo = function(){
    console.log(1);
}
// 第8行，遇到 var 关键字，解析到局部的头部
foo = undefined
// 第12行，遇到 var 关键字，解析到局部的头部
bar = undefined

```

由于有两个同名变量 `foo` ，遵循 `function` 优先 `var` 因此， `foo = undefined` 被干掉

**局部预解析** 完之后的代码应该是这个样子👇

```js
var a = 3
function fn() {
    var foo = function foo() {
        console.log(1);
    }
    var bar;
    foo();
    foo();
    foo = function foo() {
        console.log(2);
    };
    foo();
    bar = function foo() {
        if(a > 3) return;
        console.log(++a);
        foo();
    };
    foo();
    bar();
}
fn();

```

- **执行局部代码** 
  第1个 `foo()` 输出的是 **1** 
  第2个 `foo()` 输出的是 **1** 
  第3个 `foo()` 输出的是 **2** 
  第4个 `foo()` 输出的是 **2** ，注意这个 `foo()` 输出的是上面 `foo = function foo() {console.log(2);}` 的内容，因为 **具名函数表达式** 的函数名只能在函数内部使用，在外部无法访问。
  最后的 `bar()` 输出的是 **4** ，这里才是输出 `function foo() {if(a > 3) return;console.log(++a);foo();}` 里的内容，而且，这个函数体内也有自身的调用，结果 `a` 变量 **+1** ，说明可以调用，其实，可以用 `bar.name` 输出的就是 `foo`

**所以，注意：**

> - `bar = function foo()` , 不要用这种写法 ，优雅的写法是 **变量名** 和 **函数名** 保持一致 `foo = function foo()`
>
> - 不推荐使用 
>
> 匿名函数表达式
>
> ，有以下 👇 几个缺点 
>
>   - 在追踪栈中没函数名，调试困难
>   - 如果需要引用自身，只能用非标准的 `arguments.callee`（ES5严格模式禁用）

#### **作用域相关笔试题，严格模式，setTimeout**

第一题：

```js
console.log(a());// 2
var a = function b(){
    console.log(1);
}
console.log(a());// 1
function a(){
    console.log(2);
}
console.log(a());// 1
console.log(b());// reference error

```

代码编译后，变量提升，函数优先，赋值语句中b为右值，非变量声明，所以代码等价于

```js
function a(){
    console.log(2);
}
var a;
console.log(a());// 2
a = function (){
    console.log(1);
}
console.log(a());// 1

console.log(a());// 1
console.log(b());// reference error

```

第二题：

```js
function test() {
    console.log(a);// undefined
    console.log(b);// reference error
    console.log(c);// reference error
    var a = b =1;// 等价于 var a=1;b=1;
    let c = 1;
}
test();
console.log(b);// 1
console.log(a);// reference error

```

var 声明的变量会变量提升，并依附函数作用域，而**b变量未声明就作为左值，会变成全局变量，但是不会变量提升**；

第三题：

```js
"use strict";
function test() {
    console.log(a);// undefined
    console.log(b);// reference error
    console.log(c);// reference error
    var a = b =1;// 直接抛出语法错误
    let c = 1;
}
test();
console.log(b);// reference error
console.log(a);// reference error

```

**进入严格模式后，b=1这种语法会直接出错，不会变成全局变量**

第四题：

- 4.1题

```js
for(var i=0;i<5;i++){
  setTimeout(function(){console.log(i)},0); // 5 5 5 5 5 
}

```

i 依附函数作用域，执行过程只有一个i，而setTimeout是异步函数，需要等栈中的代码执行完后再执行，此时i已经变为5

- 4.2题

```js
for(let i=0;i<5;i++){
  setTimeout(function(){console.log(i)},0); // 1 2  3  4
}

```

let 依附for的块级作用域，代码等价于

```js
for(let i=0;i<5;i++){
  let j = i;
  setTimeout(function(){console.log(j)},0); // 1 2  3  4
}

```

可以看出每次循环都产生一个新的内存单元，异步函数执行时，取到的值为当时保持的快照值。

- 4.3题

```js
for(var i=0;i<5;i++){
 (function(i){
   setTimeout(function(){console.log(i)},0); // 1 2  3  4
  })(i);
}

```

使用IIFE来创建快照值，将for 循环的i 传递给立即执行表达式中的参数i，i是基本数据类型，为赋值传递，会产生一个新的内存单元，每次循环都产生一个快照值，所以异步函数执行的时候，取到的值为当时保持的快照值。

- 4.4题

```js
for(var i={j:0};i.j<5;i.j++){
 (function(i){
   setTimeout(function(){console.log(i.j)},0); // 5 5 5 5 5
  })(i);
}

```

i不是基本数据类型，为引用传递，i始终指向同一内存单元

- 4.5题

```js
for(let i={j:0};i.j<5;i.j++){
   setTimeout(function(){console.log(i.j)},0); // 5 5 5 5 5
}

```

与上面4.4题同理

- 4.6题
  如何改变4.4题的立即执行表达式，输出1，2，3，4

```js
for(var i={j:0};i.j<5;i.j++){
 (function(i){
   setTimeout(function(){console.log(i.j)},0); // 1 2 3 4
  })(JSON.parse(JSON.stringify(i)));
}

```

将i序列化和反序列化，产生新的内存单元值，不让i指向同一内存单元

### 20 this指向

 **this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定，this最终指向调用它的对象。** 

*例子1*

```js
function flora(){
    var Animal = "🐱";
    console.log(this.Animal); //undefined
    console.log(this); //Window
}
flora();
```

实际上，这里调用`flora();`是由window对象调用的,把`flora();`改成`window.flora();`控制台打印的同样是Window。

*例子2*

```js
var flora = {
    Animal:"🐱",
    say:function(){
        console.log(this.Animal);  //🐱
    }
}
flora.say();
```

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定，这里`flora`调用了`say`，所以this指向对象`flora`。

*例子3-1*

```js
var flora = {
    Animal:"🐱",
    say:function(){
        console.log(this.Animal);  //🐱
    }
}
window.flora.say();
```

*例子3-2*

```js
var flora = {
    Animal:"🐱",
    mars:{
        Animal:"🐶",
        say:function(){ 
            console.log(this.Animal);  //🐶
    	}
    }
}
flora.mars.say();
```

例子3-1的this竟然没有指向`window`，例子3-2的this竟然没有指向`flora`，不是说this最终指向调用他的对象吗？！！ 结论竟然失效了，其实也不是，对于这种多层调用的情况

> 一个含有this的函数不管被多少花里胡哨的对象调用，this也只是指向它上一级的对象 

*例子4*

```js
var flora = {
    Animal:"🐱",
    mars:{
        Animal:"🐶",
        say:function(){ 
            console.log(this);   //window
            console.log(this.Animal);  //undefined
    	}
    }
}
var pink = flora.mars.say;
pink();
```

…fá生了什么，this怎么指向了window？ 别急，想想我们的理论：**this最终指向调用它的对象**；

什么时候调用了它？是不是`pink()`的时候，这个跟上面的🌰不一样，上面的例子直接执行了`say`;

没有哪一句话可以让我们直接判断this指向，分析的时候小心一点就可以啦(⁎⁍̴̛ᴗ⁍̴̛⁎)

*例子5-1*

```js
function flora(){
    this.animal = "🐱";
}
var blue = new flora();
console.log(blue.animal); //🐱
```

这里`blue`对象之所以可以打印出函数`flora`里面的`animal`是因为**new可以改变this的指向**

其实可以这么理解，我们在`var blue = new flora();`的时候，复制了一个`flora`到`blue`里面

> 注意⚠️这个时候并没有执行，而调用的时候是blue对象，所以this指向的就是blue 

为什么`blue`有`animal`属性，因为`flora`已经复制到了`blue`对象中。

*如果构造函数有返回值呢？*⬇️

*例子5-2*

```js
function flora(){
    this.animal = "🐱";   
    return {}
}
var blue = new flora();
console.log(blue.animal); //undefined

function flora(){
    this.animal = "🐱";   
    return function(){};
}
var blue = new flora();
console.log(blue.animal); //undefined
```

返回的是一个对象，this指向的就是那个返回的对象；

*例子5-3*

```js
function flora(){
    this.animal = "🐱";   
    return 1;
}
var blue = new flora();
console.log(blue.animal); //🐱

function flora(){
    this.animal = "🐱";   
    return undefined;
}
var blue = new flora();
console.log(blue.animal); //🐱
```

如果返回的不是对象，this还是指向这个函数的实例

*例子5-4*

```js
function flora(){
    this.animal = "🐱";   
    return null
}
var blue = new flora();
console.log(blue.animal); //🐱
```

比较特别的是：虽然`null`属于对象，但是返回`null`依然指向函数实例

> Null类型只有一个值的数据类型，这个特殊值是null。从逻辑角度来看，null值表示一个空对象指针，这也是使用typeof操作符检测null值时会返回"object"的原因 

**补充**

1. 箭头函数：箭头函数本身是没有this,但我们用到this的时候,他会找定义函数时所处环境的this.
2. 在严格模式下，默认的this不是window，是undefined。(使用了"user strict"启用严格模式)
3. new之所以可以改变this的指向，跟apply有关，还有其他方法可以改变this指向，后续文章会提到

给大家做两道测试题吧！😎

*测试题1*

```js
 var animal = '🐱';
 function flora() {
    var animal = '🐶';
    console.log(this.animal);
 }
 window.flora(); 
 
 var obj = {
    animal: '🐷',
    say: function() {
        console.log(this.animal);
    }
 }
 obj.say(); 
 
 var mrz = obj.say;
 window.mrz();
```

答案：🐱 🐷 🐱

*测试题2*

```js
 var animal = '🐱';
 (function() {
    var animal = '🐶';
    console.log(this.animal);
 })()
 
 function flora() {
    var animal = '🐷';
    function mrz() {
        console.log(this.animal);
    }
    mrz(); 
 }
 flora();
```

答案：🐱 🐱

1. 因为匿名函数没有名字，所以就挂给`window`
2. 谁调用`mrz`那么就指向谁，它不是`window`调用的，也不是`flora`调用的，没有人管它，那么它就指向`window`，无主函数

### 21 事件总线 | 发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.cache = {};
  }

  on(name, fn) {
    if (this.cache[name]) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }

  off(name, fn) {
    const tasks = this.cache[name];
    if (tasks) {
      const index = tasks.findIndex((f) => f === fn || f.callback === fn);
      if (index >= 0) {
        tasks.splice(index, 1);
      }
    }
  }

  emit(name) {
    if (this.cache[name]) {
      for (let fn of this.cache[name]) {
        fn();
      }
    }
  }


  emit(name, once = false) {
    if (this.cache[name]) {
      // 创建事件副本，如果回调函数内继续注册相同事件，触发时，会造成死循环
      const tasks = this.cache[name].slice()
      for (let fn of tasks) {
        fn();
      }
      if (once) {
        delete this.cache[name]
      }
    }
  }
}

```

### 22 柯里化

只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

```js
function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      func.apply(this, args);
    } else {
      return function (...args2) {
        curried.apply(this, args.concat(args2));
      };
    }
  };
}
```

 实现多参数传递累加

```js
function add(){
    // 1 把所有参数转换成数组
    let args = Array.prototype.slice.call(arguments)
    // 2 再次调用add函数，传递合并当前与之前的参数
    let fn = function() {
        let arg_fn = Array.prototype.slice.call(arguments)
        return add.apply(null, args.concat(arg_fn))
    }
    // 3 最后默认调用，返回合并的值
    fn.toString = function() {
        return args.reduce(function(a, b) {
            return a + b
        })
    }
    return fn
}

// ES6写法
function add () {
    let args = [...arguments];
    let fn = function(){
        return add.apply(null, args.concat([...arguments]))
    } 
    fn.toString = () => args.reduce((a, b) => a + b)
    return fn;
}

add(1)(3,4)(3,5)    // 16
add(2)(2)(3,5)      // 12

```

### 23 无限累加函数

```js
function add(a) {
    function sum(b) { // 使用闭包
        a = b ? a + b : a; // 累加
        return sum;
    }
    sum.toString = function() { // 只在最后一次调用
        return a;
    }
    return sum; // 返回一个函数
}

add(1)              // 1
add(1)(2)           // 3
add(1)(2)(3)        // 6
add(1)(2)(3)(4)     // 10 

```

- `add`函数内部定义`sum`函数并返回，实现连续调用
- `sum`函数形成了一个闭包，每次调用进行累加值，再返回当前函数`sum`
- `add()`每次都会返回一个函数`sum`，直到最后一个没被调用，默认会触发`toString`方法，所以我们这里重写`toString`方法，并返回累计的最终值`a`

这样说才能理解:

`add(10)`: 执行函数`add(10)`，返回了`sum`函数，注意这一次没有调用`sum`，默认执行`sum.toString`方法。所以输出`10`；

`add(10)(20)`: 执行函数`add(10)`，返回sum(此时a为10)，再执行`sum(20)`，此时`a为30`，返回`sum`，最后调用`sum.toString()`输出`30`。 add(10)(20)...(n)依次类推。

### 24 异步并发数限制

```js
/**
 * 关键点说明
 * 1. new promise 一经创建，立即执行
 * 2. 使用 Promise.resolve().then 可以把任务加到微任务队列，防止立即执行迭代方法
 * 3. 微任务处理过程中，产生的新的微任务，会在同一事件循环内，追加到微任务队列里
 * 4. 使用 race 在某个任务完成时，继续添加任务，保持任务按照最大并发数进行执行
 * 5. 任务完成后，需要从 doingTasks 中移出
 */
function limit(count, array, iterateFunc) {
  const tasks = [];
  const doingTasks = [];
  let i = 0;
  const enqueue = () => {
    if (i === array.length) {
      return Promise.resolve();
    }
    const task = Promise.resolve().then(() => iterateFunc(array[i++]));
    tasks.push(task);
    const doing = task.then(() => doingTasks.splice(doingTasks.indexOf(doing), 1));
    doingTasks.push(doing);
    const res = doingTasks.length >= count ? Promise.race(doingTasks) : Promise.resolve();
    return res.then(enqueue);
  };
  return enqueue().then(() => Promise.all(tasks));
}

// test
const timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));
limit(4, [1000, 1000, 1000, 1000], timeout).then((res) => {
  console.log(res);
})

```

### 24 异步串行 | 异步并行

 实现一个异步加法 

```js
function asyncAdd(a, b, callback) {
  setTimeout(function () {
    callback(null, a + b);
  }, 1000);
}

// 0. promisify
const promiseAdd = (a, b) => new Promise((resolve, reject) => {
  asyncAdd(a, b, (err, res) => {
    if (err) {
      reject(err)
    } else {
      resolve(res)
    }
  })
})

// 1. 串行处理
async function serialSum(...args) {
  return args.reduce((task, now) => task.then(res => promiseAdd(res, now)), Promise.resolve(0))
}

// 2. 并行处理
async function parallelSum(...args) {
  if (args.length === 1) return args[0]
  const tasks = []
  for (let i = 0; i < args.length; i += 2) {
    tasks.push(promiseAdd(args[i], args[i + 1] || 0))
  }
  const results = await Promise.all(tasks)
  return parallelSum(...results)
}

// 测试
(async () => {
  const res1 = await serialSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
  console.log(res1)
  const res2 = await parallelSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
  console.log(res2)
})()

```

### 25 手写promise

```js
class MyPromise {
  constructor(func) {
    this.status = 'pending'
    this.value = null
    this.resolvedTasks = []
    this.rejectedTasks = []
    this._resolve = this._resolve.bind(this)
    this._reject = this._reject.bind(this)
    try {
      func(this._resolve, this._reject)
    } catch (error) {
      this._reject(error)
    }
  }

  _resolve(value) {
    setTimeout(() => {
      this.status = 'fulfilled'
      this.value = value
      this.resolvedTasks.forEach(t => t(value))
    })
  }

  _reject(reason) {
    setTimeout(() => {
      this.status = 'reject'
      this.value = reason
      this.rejectedTasks.forEach(t => t(reason))
    })
  }

  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      this.resolvedTasks.push((value) => {
        try {
          const res = onFulfilled(value)
          if (res instanceof MyPromise) {
            res.then(resolve, reject)
          } else {
            resolve(res)
          }
        } catch (error) {
          reject(error)
        }
      })
      this.rejectedTasks.push((value) => {
        try {
          const res = onRejected(value)
          if (res instanceof MyPromise) {
            res.then(resolve, reject)
          } else {
            reject(res)
          }
        } catch (error) {
          reject(error)
        }
      })
    })
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }
}

// 测试
new MyPromise((resolve) => {
  setTimeout(() => {
    resolve(1);
  }, 500);
})
  .then((res) => {
    console.log(res);
    return new MyPromise((resolve) => {
      setTimeout(() => {
        resolve(2);
      }, 500);
    });
  })
  .then((res) => {
    console.log(res);
  }, err => {
    console.log('==>', err);
  });
```

# 计算机基础

### 1 请简述一下TCP的三次握手和四次挥手协议

![1599053200896](/../../../../Typora图库/Web前端/三次握手.png)

![1599053232230](/../../../../Typora图库/Web前端/四次挥手.png)

**三次握手：**

（1）  第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

（2）  第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

（3）  第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？**

建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。
 （1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。
 （2）采用三次握手是为了**防止失效的连接请求报文段突然又传送到主机B，因而产生错误**。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
 （3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。

**四次挥手：**

（1）第一次挥手：Client发送一个FIN=1，用来关闭Client到Server的数据传送，发送序号seq=u （等于前面已经传送过来的数据的最后一个字节的序号加1） ，Client进入FIN_WAIT_1状态。
 （2）第二次挥手：Server收到FIN后，发送一个ACK=1，确认序号为ack=u+1给Client， 并且带上自己的序列号seq=v ，Server进入CLOSE_WAIT状态。
 （3）第三次挥手：Server发送一个FIN=1，ack=u+1，用来关闭Server到Client的数据传送， 由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，Server进入LAST_ACK状态。

（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK=1给Server，确认序号ack=w+1， 而自己的序列号是seq=u+1， Client就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当client撤销相应的TCB后，才进入CLOSED状态。

 （5）Server 只要收到了Client发出的确认，立即进入CLOSED状态，完成四次挥手。

**为什么要四次挥手？**

　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

### 2  简单介绍一下HTTP的长连接和短连接  

HTTP的长连接和短连接本质上是TCP长连接和短连接。**HTTP属于应用层协议**.

**短连接:**

浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

**长连接:**

当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

**TCP短连接:**

client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在 client/server间传递一次读写操作

 **TCP长连接:**

client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

### 3 TCP/IP协议

 ![这里写图片描述](/../../../../Typora图库/Web前端/TCPIP五层模型.png) 

​      TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，**由网络层的IP协议和传输层的TCP协议组成**。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。传输层（TCP/UDP）提供**端到端**(end to end)的服务。 

　　IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是**不可靠**的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。 IP 协议位于 TCP/IP 协议的第三层——**网络层**。与传输层协议相比，网络层的责任是提供**点到点**(hop by hop)的服务。

 　**TCP是面向连接的通信协议**，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以**只能用于端到端的通讯**。TCP提供的是一种**可靠的数据流服务**，采用“**带重传的肯定确认**”技术来实现传输的可靠性。TCP还采用一种称为**“滑动窗口”的方式进行流量控制**，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

**TCP**报文首部格式：

![1599136506395](/../../../../Typora图库/Web前端/TCP报文首部.png)

ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。
FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

#### TCP怎么实现可靠传输

确认和重传机制：建立连接、发送包时的确认，运输过程中校验失败、丢包或延时发送端重传

数据排序：把数据分成很多包，按顺序进行传输

流量控制：滑动窗口和计时器

拥塞控制：慢启动、拥塞避免、快速重传、快速恢复

**流量控制**

作用于接收方，控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。由滑动窗口实现

- 滑动窗口：TCP进行流量控制的方式，接收方通过告诉对方自己的窗口大小，从而控制发送方的发送速度，以防止由于发送方发送速度过快而导致自己被淹没的现象
- 计时器：发送端收到为0的窗口后开启一个计时器，时间到了之后发包询问现在的滑动窗口，防止死锁（接收端发回的不为0的窗口的包丢失，双方相互等待

**拥塞控制**

作用于网络，防止过多的数据注入到网络中，避免出现网络负载过大的情况。

- 拥塞：对网络中某一资源的需求超过了该资源所能提供的可用部分，影响到网络性能

- 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

  - **慢启动和拥塞避免**

    - 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。拥塞窗口一开始设为1 ，每收到一次确认，就让拥塞窗口变为原来的两倍，当窗口值为16时（慢启动门限），改为加法增大，每次+1，直到网络拥塞。拥塞时让新的慢启动门限设为拥塞时的一半，并把拥塞窗口置为1，再让他重复，这时一瞬间会将网络数据量大量降低。
    - 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。
  - **快重传和快恢复**

    - 快重传：接收方每收到一个失序的报文段（收完2后就收到了4说明3丢了）就立即发出包2的重复确认，这样可以让发送方尽早知道丢包了。发送端连续收到三个重复确认就立即重传3
    - 快恢复：发送方收到3个连续确认时，把慢开始门限减半，把拥塞窗口的值置为慢开始门限的一半，实行拥塞避免算法，每次确认收到后+1

- 拥塞窗口：发送方使用的流量控制，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

#### 滑动窗口

IP层协议属于不可靠的协议，IP层并不关系数据是否发送到了对端，TCP通过确认机制来保证数据传输的可靠性，在比较早的时候使用的是send--wait--send的模式，其实这种模式叫做stop-wait模式，<u>发送数据方在发送数据之后会启动定时器，但是如果数据或者ACK丢失，那么定时器到期之后，收不到ACK就认为发送出现状况，要进行重传</u>。这样就会降低了通信的效率，这种方式被称为 positive acknowledgment with retransmission (PAR)

可以假设一下，来优化一下PAR效率低的缺点，比如我让发送的每一个包都有一个id，接收端必须对每一个包进行确认，这样设备A一次多发送几个片段，而不必等候ACK，同时接收端也要告知它能够收多少，这样发送端发起来也有个限制，当然还需要保证**顺序性**，不要乱序，对于乱序的状况，我们可以允许等待一定情况下的乱序，比如说<u>先缓存提前到的数据，然后去等待需要的数据，如果一定时间没来就DROP掉，来保证顺序性</u>！

在TCP/IP协议栈中，滑动窗口的引入可以解决此问题，先来看从概念上数据分为哪些类

1. Sent and Acknowledged：这些数据表示已经发送成功并已经被确认的数据，比如图中的前31个bytes，这些数据其实的位置是在窗口之外了，因为窗口内顺序最低的被确认之后，要移除窗口，实际上是窗口进行合拢，同时打开接收新的带发送的数据
2. Send But Not Yet Acknowledged：这部分数据称为发送但没有被确认，数据被发送出去，没有收到接收端的ACK，认为并没有完成发送，这个属于窗口内的数据。
3. Not Sent，Recipient Ready to Receive：这部分是尽快发送的数据，这部分数据已经被加载到缓存中，也就是窗口中了，等待发送，其实这个窗口是完全有接收方告知的，接收方告知还是能够接受这些包，所以发送方需要尽快的发送这些包
4. Not Sent，Recipient Not Ready to Receive： 这些数据属于未发送，同时接收端也不允许发送的，因为这些数据已经超出了发送端所接收的范围

对于接收端也是有一个接收窗口的，类似发送端，接收端的数据有3个分类，因为接收端并不需要等待ACK所以它没有类似的接收并确认了的分类，情况如下
1.  Received and ACK Not Send to Process：这部分数据属于接收了数据但是还没有被上层的应用程序接收，也是被缓存在窗口内
2.  Received  Not ACK: 已经接收并，但是还没有回复ACK，这些包可能输属于Delay ACK的范畴了
3.  Not Received：有空位，还没有被接收的数据。

**发送窗口和可用窗口**
对于发送方来讲，窗口内的包括两部分，就是发送窗口（已经发送了，但是没有收到ACK），可用窗口，接收端允许发送但是没有发送的那部分称为可用窗口。

1. Send Window ： 20个bytes 这部分值是有接收方在三次握手的时候进行通告的，同时在接收过程中也不断的通告可以发送的窗口大小，来进行适应
2. Window Already Sent: 已经发送的数据，但是并没有收到ACK。

**滑动窗口原理**

TCP并不是每一个报文段都会回复ACK的，可能会对两个报文段发送一个ACK，也可能会对多个报文段发送1个ACK【累计ACK】，比如说发送方有1/2/3 3个报文段，先发送了2,3 两个报文段，但是接收方期望收到1报文段，这个时候2,3报文段就只能放在缓存中等待报文1的空洞被填上，如果报文1，一直不来，报文2/3也将被丢弃，如果报文1来了，那么会发送一个ACK对这3个报文进行一次确认。

举一个例子来说明一下滑动窗口的原理：

1. 假设32~45 这些数据，是上层Application发送给TCP的，TCP将其分成四个Segment来发往internet

2. seg1 32~34 seg3 35~36 seg3 37~41 seg4 42~45  这四个片段，依次发送出去，此时假设接收端之接收到了seg1 seg2 seg4

3. 此时接收端的行为是回复一个ACK包说明已经接收到了32~36的数据，并将seg4进行缓存（保证顺序，产生一个保存seg3 的hole）

4. 发送端收到ACK之后，就会将32~36的数据包从发送并没有确认切到发送已经确认，提出窗口，这个时候窗口向右移动

5. 假设接收端通告的Window Size仍然不变，此时窗口右移，产生一些新的空位，这些是接收端允许发送的范畴

6. 对于丢失的seg3，如果超过一定时间，TCP就会重新传送（重传机制），重传成功会seg3 seg4一块被确认，不成功，seg4也将被丢弃

就是不断重复着上述的过程，随着窗口不断滑动，将真个数据流发送到接收端，实际上接收端的Window Size通告也是会变化的，接收端根据这个值来确定何时及发送多少数据，从对数据流进行流控。

### 4 TCP和UDP  

TCP（Transmission Control Protocol 传输控制协议）是一种**面向连接的、可靠的、基于字节流的传输层通信协议**，由IETF的RFC 793定义。

UDP（用户数据报协议）是**面向无连接的通讯协议**，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现**广播**发送。UDP通讯时不需要接收方确认，属于**不可靠**的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。

UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。

每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：

　　（1）源端口号；

　　（2）目标端口号；

　　（3）数据报长度；

　　（4）校验值。

使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。

**TCP与UDP区别**

- TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。
- TCP提供可靠的服务，通过连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。
- TCP面向字节流；UDP面向报文。
- TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
- TCP首部开销字节；UDP的首部开销小，只有个字节。
- TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。

### 5 Socket 基本概念

Socket 是对 **TCP/IP 协议的一种封装**，是**应用层与TCP/IP协议族通信的中间软件抽象层**。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

Socket 还可以认为是一种**网络间不同计算机上的进程通信的一种方法**，利用**三元组（ip地址，协议，端口）**就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。

### 6 HTTP和HTTPS

 **https的SSL加密是在传输层实现的。** 

HTTP：超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。HTTP协议传输数据以明文形式显示。

HTTPS：HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

PS：TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。

**HTTP特点**：

HTTP协议传输数据以明文形式显示。

1. 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作

2. 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。

3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应

4. 简单快速、灵活

5. 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性

**HTTPS特点**：

基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护

数据不是明文传输，而且HTTPS有如下特点：

1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容

2. 验证身份：通过证书认证客户端访问的是自己的服务器

3. 保护数据完整性：防止传输的内容被中间人冒充或者篡改

 **HTTPS和HTTP的区别**：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**HTTPS的优点**

　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：

　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

**HTTPS的缺点**

　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：

　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

　  （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

**HTTP劫持**

在正常的数据流中插入特定的网络数据报文，让客户端解释错误的数据，并以弹出新窗口的形式向使用者展示小广告或网页内容

步骤：

- 在TCP连接中标识HTTP协议链接；

- 改HTTP响应体；

- 将篡改后的数据包抢先回发到用户，这样后面的数据包在到达后会被直接丢弃。而客户端显示改后的网页

防范：

- 事前加密：HTTPS，防止明文传输被挟持，（但防不了DNS挟持）

- 事中加密：拆分HTTP请求数据包，运营商的旁路设备没有完整的TCP/IP协议栈，不能标记，web服务器有完整的TCP/IP协议栈，能把接收到的数据包拼成完整的HTTP请求，不影响服务

- 事后屏蔽：前端显示HTTP时对内容进行检测，在DOM结构发生变化时触发回调

 

**HTTPS挟持**：伪造证书来进行挟持



### 6 HTTPS实现原理（SSL握手）

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 因为只有服务器有private key可以解密，所以不用担心中间人拦截这个加密的密钥 

　　（5）Web服务器利用自己的私钥解密出会话密钥。

　　（6）Web服务器利用会话密钥加密与客户端之间的通信。

 ![img](/../../../../Typora图库/Web前端/SSL原理.jpg) 

**加密过程（SSL握手）**

![1599138130415](/../../../../Typora图库/Web前端/SSL握手.png)

1. client向server发送请求https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。

2. server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。

3. 随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

4. 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。

5. 客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。

6. 传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。

7. 服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。

8. 客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。

9. 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。

### 7 HTTP通信传输

![1599138204301](/../../../../Typora图库/Web前端/HTTP通信传输.png)

​         客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的运用层协议，所以通信的过程其实是对应数据的入栈和出栈。  

![1599138249369](/../../../../Typora图库/Web前端/HTTP通信传输2.png)

报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。

### 8 DNS 

DNS 的作⽤就是**通过域名查询到具体的 IP**。DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。

**DNS劫持**：通过劫持DNS服务器，获得某域名的解析记录控制权，修改此域名的解析结果。把原来对A域名的访问转入B域名，返回错误的查询结果。可能是一些产品的持续的推广

区别：DNS劫持倾向于持续性，访问一个界面时强行推送广告，HTTP劫持频率多变，劫持过程也非常快，一般多出现于网站小尾巴

#### DNS 解析

- 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
- 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
- 路由缓存：路由器也有 DNS 缓存。
- ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
- 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）

### 9 对称加密与非对称加密

 **对称加密**：加密和解密用的是同一个密码或者同一套逻辑的加密方式。  这个密码也叫对称秘钥，其实这个对称和不对称指的就是**加密和解密用的秘钥是不是同一个**。 

nodejs 的 crypto 模块是一个专门用于各种加密的模块，可以用来取摘要（hash），加盐摘要（hmac），对称加密，非对称加密等。使用 crypto 进行对称加密很简单，crypto 模块提供了 Cipher 类用于加密数据，Decipher 用于解密。

**常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6**




 **非对称加密**用的是一对秘钥，分别叫做公钥（public key）和私钥（private key），也叫非对称秘钥。非对称秘钥既可以用于加密还可以用于认证。

服务器和客户端必然是要交换秘钥的，而正是因为非对称秘钥由于有一个交换秘钥这一过程可能会被中间人窃取秘钥，一旦对称加密秘钥被窃取，而且被分析出加密算法的话，那么传输的数据对于中间人来说就是透明的。所以**对称加密的致命性缺点就是无法保证秘钥的安全性**。

那么非对称加密就能保证秘钥的安全性了吗？是的，秘钥可以大胆的公开，被公开的秘钥就叫公钥。非对称加密的秘钥由加密算法计算得出，是成对的，**可以被公开的那个秘钥称之为公钥**，**不能公开的那个私有的秘钥叫私钥**。

非对称加密为什么安全的关键就是：**使用秘钥对中的一个秘钥加密，加密后的数据只能通过另一个秘钥解密**。也就是说使用一对秘钥中的公钥加密数据，只能通过另一个私钥解密出数据。或者反过来，使用一对秘钥中的私钥进行加密的数据，只能通过另一个公钥解密出来。由此可见，从**加密的角度来看，公钥和私钥其实作用是等同的，都可以用于加密或解密，只不过当我们使用非对称秘钥用于加密数据时往往是用公钥进行加密**。

**在 https 的加密中，加密传输的数据本身使用的是对称加密，加密对称秘钥时使用的非对称加密**。整个过程中即便 server 端的公钥被中间人知道了内容，但是没有保存在 server 端的私钥，你是无法破译使用公钥加密的对称秘钥的。公钥原本就是可以被随意公开的，拿到也没用，解密需要的是私钥。非对称加密或者说公钥加密之所以能保证加密安全就是因为**私钥是保密不公开的，攻击者没有私钥无法破译**。

**常见的非对称加密有 RSA、ECC（椭圆曲线加密算法）、Diffie-Hellman、El Gamal、DSA（数字签名用）。**



**非对称加密和对称加密对比**

1. 对称加密是一个秘钥，非对称加密是一对，两个秘钥
2. 非对称加密比起对称加密更安全，因为不存在秘钥泄露问题，公钥即便被知道也没关系
3. 由于使用非对称加密在计算上特别复杂，所以一般来说对称加密的加密解密的速度相对于非对称加密快很多
4. 非对称秘钥还可以用于认证

由于以上第三条，所以在 https 中传输数据时不会使用非对称加密加密传输数据，传输数据时有可能数据本身很大，那样的话非对称加密更耗时了，所以传输数据时不会使用非对称加密的方式加密。



**对称加密优缺点：**

对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。



**非对称加密优缺点：**

安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。



**hash 算是加密吗？**

我觉得不算，hash 是不可逆的，加密应该是可以根据加密后的数据还原的。

**base 64 算是加密吗？**

是对称加密，对称秘钥就是 base 64 字符码表。

**非对称加密绝对安全吗？**

没有什么加密是绝对安全的，非对称加密存在交换公钥时公钥被篡改的问题。

### 10 

### 11 列举几种常见的协议，并简述他们的作用

**ICMP协议**：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
 **TFTP协议**：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
 **HTTP协议**：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
 **DHCP协议**：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
 **NAT协议**：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
 **DHCP协议**：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

**ARP**：是地址解析协议，作用是完成IP地址到硬件地址的映射。
**RARP**：是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。

 **TLS**：安全传输层协议用于在两个通信应用程序之间提供保密性和数据完整性。 

**TCP对应的协议：**
 （1） FTP：定义了文件传输协议，使用21端口。
 （2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
 （3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
 （4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
 （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。

 **UDP对应的协议：**
 （1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
 （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
 （3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。

### 12 IP，TCP，UDP，ICMP校验和的区别和计算

**IP数据报的校验和只检验IP数据报的首部。**

当发送IP包时，需要计算IP报头的校验和：

1. 把校验和字段置为0；
2. 对IP头部中的每16bit进行二进制求和；
3. 如果和的高16bit不为0，则将和的高16bit和低16bit反复相加，直到和的高16bit为0，从而获得一个16bit的值；
4. 将该16bit的值取反，存入校验和字段。

**当接收IP包时，需要对报头进行确认，检查IP头是否有误，算法同上2、3步，然后判断取反 的结果是否为0，是则正确，否则有错**。

**UDP和TCP的校验和**

UDP数据报计算校验和的方法和IP数据报校验和的方法相似，但是**UDP的校验和是将首部和数据部分一起都校验**。

UDP首部检验和与IP首部校验和的计算方法相同，在程序中使用同一个函数来计算。

需要注意的是，由于UDP首部中不包含源地址与目标地址等信息，为了保证UDP校验的有效性，**在进行UDP校验和的计算时，需要增加一个UDP伪首部的校验和**。

伪首部共有12字节，包含如下信息：

1. 源IP地址
2. 目的IP地址
3. 保留字节(置0,为了字节对齐)
4. 传输层协议号(TCP是6)
5. UDP报文长度(报头+数据)。

伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等。

**TCP 的校验和计算方法同UDP一样，同样要加上一个伪头部，区别是伪头部的协议码是0x06，长度是整个TCP报文的长度（包含TCP头部）。**

**ICMP效验和**
ICMP校验和的计算方法一样，只不过只是对ICMP包整个进行校验和，没有伪头部，也不包括IP包头部。

**IP,TCP,UDP,ICMP校验和的区别**

- IP校验和=IP头部的计算
- TCP，UDP校验和=伪首部+TCP/UDP报头+数据
- ICMP校验和=ICMP报头+数据

### 13 CDN

CDN的全称是Content Delivery Network，即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应

内容分发⽹络，基本思路是尽可能避开互联⽹上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie

### 14 子网掩码的计算

在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。
1)将子网数目转化为二进制来表示
2)取得该二进制的位数，为 N
3)取得该IP地址的类子网掩码，将其主机地址部分的的前N位置 1 即得出该IP地址划分子网的子网掩码。

1. 利用子网数计算

   如欲将B类IP地址168.195.0.0划分成27个子网：
   1)27+1=11100
   2)该二进制为五位数，N = 5
   3)将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到255.255.248.0，即为划分成 27个子网的B类IP地址 168.195.0.0的子网掩码。

2. 利用主机数计算

   1)将主机数目转化为二进制来表示
   2)如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为 N，这里肯定 N<8。如果大于254，则 N>8，这就是说主机地址将占据不止8位。
   3)使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。
   如欲将B(c)类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台(17)：
   1) 700=1010111100
   2)该二进制为十位数，N = 10(1001)
   3)将该B类地址的子网掩码255.255.0.0的主机地址全部置 1，得到255.255.255.255，然后再从后向前将后10位置0，即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。

### 15 OSI模型

 ![这里写图片描述](/../../../../Typora图库/Web前端/OSI模型.png) 

 ![这里写图片描述](/../../../../Typora图库/Web前端/OSI-TCPIP.png) 

第7层 应用层
应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。

第6层 表达层
表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。

第5层 会话层
会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。

第4层 传输层
传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。

第3层 网络层
网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络资料。例如:互联网协议（IP）等。

第2层 数据链路层
数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。

分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。

第1层 物理层
物理层（Physical Layer）在局部局域网上传送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。

### 16 CPU组成

 CPU由**控制器**和**运算器**这两个主要部件组成。 

**1．控制器**

控制器是整个计算机系统的指挥中心。在控制器的指挥控制下，运算器、存储器和输入/输出设备等部件协同工作，构成了一台完整的通用计算机。

控制器根据程序预定的指令执行顺序，从主存取出一条指令，按该指令的功能，用硬件产生所需的带有时序标志的一系列微操作控制信号，控制计算机内各功能部件的操作，协调和指挥整个计算机完成指令的功能。

控制器通常由程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、时序发生器和操作控制器组成。其主要功能包括：

1. 从主存中取出一条指令，并指出下一条指令在主存中的位置；
2. 对指令进行译码，并产生相应的操作控制信号，以便启动规定的动作；
3. 指挥并控制CPU、主存和输入/输出设备之间数据流动的方向。

**2．运算器**

运算器是计算机中用于实现数据加工处理等功能的部件，它接受控制器的命令，负责完成对操作数据的加工处理任务，其核心部件是算术逻辑单元(Arithmetic Logic Unit，ALU)。

相对控制器而言，运算器接受控制器的命令而进行动作，即运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件。

运算器由算术逻辑单元(ALU)、累加寄存器（AC）、数据寄存器（DR）和程序状态字寄存器（PSW）组成。它有两个主要功能：

1. 执行所有的算术运算；
2. 执行所有的逻辑运算，并进行逻辑测试。

**在CPU中至少要有六类寄存器：指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、数据寄存器（DR）、累加寄存器（AC）、程序状态字寄存器（PSW）。**

这些寄存器用来暂存一个计算机字，其数目可以根据需要进行扩充。

**1.数据寄存器（DR）**

数据寄存器（Data Register，DR）主要作为CPU和主存、外设之间信息传输的中转站，用以弥补CPU和主存、外设之间操作速度上的差异。

数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一个数据字时，也暂时将它们存放在数据寄存器中。

数据寄存器的作用是 ：

1. 作为CPU和主存、外围设备之间信息传送的中转站；
2. 弥补CPU和主存、外围设备之间在操作速度上的差别；
3. 在单累加器结构的运算器中，数据寄存器还可兼作操作数寄存器。

**2.指令寄存器**

指令寄存器（Instruction Register，IR）用来保存当前正在执行的一条指令。

当执行一条指令时，先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。

一条指令被划分为操作码和地址码2个字段。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器（Instruction Decoder，ID）就是完成这项工作的。

指令译码器对来自指令寄存器的操作码部分进行译码，以产生操作性质的控制电位，并将其送到微操作控制线路上，在时序部件定时信号作用下，产生具体的操作控制信号。

指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。

**3.程序计数器**

程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的单元地址。

在程序执行之前，首先必须将程序的首地址，即程序的第一条指令所在的主存单元地址送入PC。因此PC的内容即是从主存提取的第一条指令的地址。

当执行指令时，CPU能自动递增PC的内容，使其始终保持将要执行的下一条指令的主存地址，为取下一条指令做好准备。若为单字长指令，则(PC)+1PC，若为双字长指令，则(PC)+2PC，以此类推。

但是，当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段指定，而不是像通常那样通过顺序递增PC的内容来取得。

因此，程序计数器的结构应当是具有寄存信息和计数两种功能的结构。

**4.地址寄存器**

地址寄存器（Address Register，AR）用来保存CPU当前所访问的主存单元的地址。

由于在主存和CPU之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。

当CPU和主存进行信息交换，即CPU向主存存入/取出数据时，或者CPU从主存中读出指令时，都要使用地址寄存器和数据寄存器。

同样，如果我们把外围设备的设备地址作为像主存的地址单元那样来看待，那么，当CPU和外围设备交换信息时，我们同样要使用地址寄存器和数据寄存器。

**5.累加寄存器**

累加寄存器通常简称累加器（Accumulator，AC），是一个通用寄存器。

累加器的功能是：当运算器的算术逻辑单元(ALU)执行算术或逻辑运算时，为ALU提供一个工作区，可以为ALU暂时保存一个操作数或运算结果。

显然，运算器中至少要有一个累加寄存器。

**6.程序状态字寄存器**

程序状态字（Program Status Word，PSW）用来表征当前运算的状态及程序的工作方式。

程序状态字寄存器保存由算术指令和逻辑指令运行或测试的结果所建立起来的各种条件码内容，如运算结果进/借位标志(C)、运算结果溢出标志（O)、运算结果为零标志(Z)、运算结果为负标志(N)、运算结果符号标志（S）等，这些标志位通常分别用1位触发器来保存。

除此之外，程序状态字寄存器还保存中断和系统工作状态等信息，以便CPU和系统及时了解机器运行状态和程序运行状态。

因此，程序状态字寄存器是一个保存各种状态条件标志的寄存器。